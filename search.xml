<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>25 条示例代码让你的代码更简洁</title>
    <url>/post/92ec9a680643/</url>
    <content><![CDATA[<h1 id="25-条示例代码让你的代码更简洁"><a href="#25-条示例代码让你的代码更简洁" class="headerlink" title="25 条示例代码让你的代码更简洁"></a>25 条示例代码让你的代码更简洁</h1><p>JavaScript 无处不在，从 PC 端到移动设备端，甚至是后端，都在使用 JavaScript。</p>
<p>在本文中，我将尝试一些可用来使代码看起来更简洁的实践方案。</p>
<h2 id="1、使用默认参数代替短路或条件"><a href="#1、使用默认参数代替短路或条件" class="headerlink" title="1、使用默认参数代替短路或条件"></a>1、使用默认参数代替短路或条件</h2><p>默认参数通常比短路更简洁。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SomeMethod</span>(<span class="params">paramThatCanBeUndefined</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> localValue = paramThatCanBeUndefined || <span class="string">&quot;Default Value&quot;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(localValue);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SomeMethod</span>(); <span class="comment">// Default Value</span></span><br><span class="line"><span class="title class_">SomeMethod</span>(<span class="string">&quot;SomeValue&quot;</span>); <span class="comment">// SomeValue</span></span><br></pre></td></tr></table></figure>

<p>尝试以下方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SomeMethod</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="variable language_">console</span>.log(paramThatCanBeUndefined)</span></span><br><span class="line"><span class="params">  <span class="comment">// ...</span></span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params">SomeMethod() <span class="comment">// Default Value</span></span></span><br><span class="line"><span class="params">SomeMethod(<span class="string">&quot;SomeValue&quot;</span>) <span class="comment">// SomeValue</span></span></span><br></pre></td></tr></table></figure>

<p>声明：Falsy 值，如’’，””，false，null，0，和 NaN 将不会被默认值替代：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SomeMethod</span>(<span class="params">paramThatCanBeUndefined = <span class="string">&quot;Default Value&quot;</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(paramThatCanBeUndefined);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SomeMethod</span>(<span class="literal">null</span>); <span class="comment">// will not Default Value, will null Instead</span></span><br><span class="line"><span class="title class_">SomeMethod</span>(<span class="string">&quot;SomeValue&quot;</span>); <span class="comment">// SomeValue</span></span><br></pre></td></tr></table></figure>

<h2 id="2、处理多个条件"><a href="#2、处理多个条件" class="headerlink" title="2、处理多个条件"></a>2、处理多个条件</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> conditions = [<span class="string">&quot;Condition 2&quot;</span>,<span class="string">&quot;Condition String2&quot;</span>];</span><br><span class="line"><span class="title function_">someFunction</span>(<span class="params">str</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(str.<span class="title function_">includes</span>(<span class="string">&quot;someValue1&quot;</span>) || str.<span class="title function_">includes</span>(<span class="string">&quot;someValue2&quot;</span>))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一种更简洁的方法是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">someFunction</span>(<span class="params">str</span>)&#123;</span><br><span class="line">   <span class="keyword">const</span> conditions = [<span class="string">&quot;someValue1&quot;</span>,<span class="string">&quot;someValue2&quot;</span>];</span><br><span class="line">   <span class="keyword">return</span> conditions.<span class="title function_">some</span>(<span class="function"><span class="params">condition</span>=&gt;</span>str.<span class="title function_">includes</span>(condition));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、用动态键值对替换开关（即对象文字）"><a href="#3、用动态键值对替换开关（即对象文字）" class="headerlink" title="3、用动态键值对替换开关（即对象文字）"></a>3、用动态键值对替换开关（即对象文字）</h2><p>开关版本（或将开关替换为 if &#x2F; else）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">UserRole</span> = &#123;</span><br><span class="line">  <span class="attr">ADMIN</span>: <span class="string">&quot;Admin&quot;</span>,</span><br><span class="line">  <span class="attr">GENERAL_USER</span>: <span class="string">&quot;GeneralUser&quot;</span>,</span><br><span class="line">  <span class="attr">SUPER_ADMIN</span>: <span class="string">&quot;SuperAdmin&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getRoute</span>(<span class="params">userRole = <span class="string">&quot;default role&quot;</span></span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (userRole) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">UserRole</span>.<span class="property">ADMIN</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;/admin&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">UserRole</span>.<span class="property">GENERAL_USER</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;/GENERAL_USER&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">UserRole</span>.<span class="property">SUPER_ADMIN</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;/superadmin&quot;</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;/&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getRoute</span>(<span class="title class_">UserRole</span>.<span class="property">ADMIN</span>)); <span class="comment">// return &quot;/admin&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getRoute</span>(<span class="string">&quot;Anything&quot;</span>)); <span class="comment">// return Default path</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getRoute</span>()); <span class="comment">// return Default path</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getRoute</span>(<span class="literal">null</span>)); <span class="comment">// return Default path</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// More cases if new arrive</span></span><br><span class="line"><span class="comment">// You can think if else instead of switch</span></span><br></pre></td></tr></table></figure>

<p>动态键值对版本：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">UserRole</span> = &#123;</span><br><span class="line">  <span class="attr">ADMIN</span>: <span class="string">&quot;Admin&quot;</span>,</span><br><span class="line">  <span class="attr">GENERAL_USER</span>: <span class="string">&quot;GeneralUser&quot;</span>,</span><br><span class="line">  <span class="attr">SUPER_ADMIN</span>: <span class="string">&quot;SuperAdmin&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getRoute</span>(<span class="params">userRole = <span class="string">&quot;default role&quot;</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> appRoute = &#123;</span><br><span class="line">    [<span class="title class_">UserRole</span>.<span class="property">ADMIN</span>]: <span class="string">&quot;/admin&quot;</span>,</span><br><span class="line">    [<span class="title class_">UserRole</span>.<span class="property">GENERAL_USER</span>]: <span class="string">&quot;/user&quot;</span>,</span><br><span class="line">    [<span class="title class_">UserRole</span>.<span class="property">SUPER_ADMIN</span>]: <span class="string">&quot;/superadmin&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> appRoute[userRole] || <span class="string">&quot;Default path&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getRoute</span>(<span class="title class_">UserRole</span>.<span class="property">ADMIN</span>)); <span class="comment">// return &quot;/admin&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getRoute</span>(<span class="string">&quot;Anything&quot;</span>)); <span class="comment">// return Default path</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getRoute</span>()); <span class="comment">// return Default path</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getRoute</span>(<span class="literal">null</span>)); <span class="comment">// return Default path</span></span><br><span class="line"><span class="comment">// No more switch/if-else here.</span></span><br><span class="line"><span class="comment">// Easy to Further expansion</span></span><br></pre></td></tr></table></figure>

<h2 id="4、避免过多的函数参数"><a href="#4、避免过多的函数参数" class="headerlink" title="4、避免过多的函数参数"></a>4、避免过多的函数参数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params">employeeName, jobTitle, yrExp, majorExp</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;employeeName&#125;</span> is working as <span class="subst">$&#123;jobTitle&#125;</span> with <span class="subst">$&#123;yrExp&#125;</span>    years of experience in <span class="subst">$&#123;majorExp&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output be like John is working as Project Manager with 12 year of experience in Project Management</span></span><br><span class="line"><span class="comment">// you can call it via</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myFunction</span>(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Project Manager&quot;</span>, <span class="number">12</span>, <span class="string">&quot;Project Management&quot;</span>));</span><br><span class="line"><span class="comment">//    ***** PROBLEMS ARE *****</span></span><br><span class="line"><span class="comment">// Violation of &#x27;clean code&#x27; principle</span></span><br><span class="line"><span class="comment">// Parameter sequencing is important</span></span><br><span class="line"><span class="comment">// Unused Params warning if not used</span></span><br><span class="line"><span class="comment">// Testing need to consider a lot of edge cases.</span></span><br></pre></td></tr></table></figure>

<p>这是一种更清洁的方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params">&#123; employeeName, jobTitle, yrExp, majorExp &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;employeeName&#125;</span> is working as <span class="subst">$&#123;jobTitle&#125;</span> with <span class="subst">$&#123;yrExp&#125;</span> years of experience in <span class="subst">$&#123;majorExp&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output be like John is working as Project Manager with 12 year of experience in Project Management</span></span><br><span class="line"><span class="comment">// you can call it via</span></span><br><span class="line"><span class="keyword">const</span> mockTechPeople = &#123;</span><br><span class="line">  <span class="attr">employeeName</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">jobTitle</span>: <span class="string">&quot;Project Manager&quot;</span>,</span><br><span class="line">  <span class="attr">yrExp</span>: <span class="number">12</span>,</span><br><span class="line">  <span class="attr">majorExp</span>: <span class="string">&quot;Project Management&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myFunction</span>(mockTechPeople));</span><br><span class="line"><span class="comment">// ES2015/ES6 destructuring syntax is in action</span></span><br><span class="line"><span class="comment">// map your desired value to variable you need.</span></span><br></pre></td></tr></table></figure>

<h2 id="5、使用-Object-assign-设置默认对象"><a href="#5、使用-Object-assign-设置默认对象" class="headerlink" title="5、使用 Object.assign 设置默认对象"></a>5、使用 Object.assign 设置默认对象</h2><p>这看起来很繁琐：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> someObject = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">subTitle</span>: <span class="string">&quot;Subtitle&quot;</span>,</span><br><span class="line">  <span class="attr">buttonColor</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">disabled</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createOption</span>(<span class="params">someObject</span>) &#123;</span><br><span class="line">  someObject.<span class="property">title</span> = someObject.<span class="property">title</span> || <span class="string">&quot;Default Title&quot;</span>;</span><br><span class="line">  someObject.<span class="property">subTitle</span> = someObject.<span class="property">subTitle</span> || <span class="string">&quot;Default Subtitle&quot;</span>;</span><br><span class="line">  someObject.<span class="property">buttonColor</span> = someObject.<span class="property">buttonColor</span> || <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">  someObject.<span class="property">disabled</span> =</span><br><span class="line">    someObject.<span class="property">disabled</span> !== <span class="literal">undefined</span> ? someObject.<span class="property">disabled</span> : <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> someObject;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">createOption</span>(someObject));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output be like</span></span><br><span class="line"><span class="comment">// &#123;title: &#x27;Default Title&#x27;, subTitle: &#x27;Subtitle&#x27;, buttonColor: &#x27;blue&#x27;, disabled: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>这种方法看起来更好：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> someObject = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">subTitle</span>: <span class="string">&quot;Subtitle&quot;</span>,</span><br><span class="line">  <span class="attr">buttonColor</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">disabled</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">creteOption</span>(<span class="params">someObject</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> newObject = <span class="title class_">Object</span>.<span class="title function_">assign</span>(</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&quot;Default Title&quot;</span>,</span><br><span class="line">      <span class="attr">subTitle</span>: <span class="string">&quot;Default Subtitle&quot;</span>,</span><br><span class="line">      <span class="attr">buttonColor</span>: <span class="string">&quot;blue&quot;</span>,</span><br><span class="line">      <span class="attr">disabled</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    someObject</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">creteOption</span>(someObject));</span><br></pre></td></tr></table></figure>

<h2 id="6-通过条件判断给变量赋值布尔值的正确姿势"><a href="#6-通过条件判断给变量赋值布尔值的正确姿势" class="headerlink" title="6.通过条件判断给变量赋值布尔值的正确姿势"></a>6.通过条件判断给变量赋值布尔值的正确姿势</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">if</span> (a === <span class="string">&quot;a&quot;</span>) &#123;</span><br><span class="line">  b = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  b = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">b = a === <span class="string">&quot;a&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="7-在-if-中判断数组长度不为零的正确姿势"><a href="#7-在-if-中判断数组长度不为零的正确姿势" class="headerlink" title="7.在 if 中判断数组长度不为零的正确姿势"></a>7.在 if 中判断数组长度不为零的正确姿势</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">if</span> (arr.<span class="property">length</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">if</span> (arr.<span class="property">length</span>) &#123;</span><br><span class="line">  <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-同理，在-if-中判断数组长度为零的正确姿势"><a href="#8-同理，在-if-中判断数组长度为零的正确姿势" class="headerlink" title="8.同理，在 if 中判断数组长度为零的正确姿势"></a>8.同理，在 if 中判断数组长度为零的正确姿势</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">if</span> (arr.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">if</span> (!arr.<span class="property">length</span>) &#123;</span><br><span class="line">  <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-简单的-if-判断使用三元表达式"><a href="#9-简单的-if-判断使用三元表达式" class="headerlink" title="9.简单的 if 判断使用三元表达式"></a>9.简单的 if 判断使用三元表达式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">if</span> (a === <span class="string">&quot;a&quot;</span>) &#123;</span><br><span class="line">  b = a;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  b = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">b = a === <span class="string">&quot;a&quot;</span> ? a : c;</span><br></pre></td></tr></table></figure>

<h2 id="10-使用-includes-简化-if-判断"><a href="#10-使用-includes-简化-if-判断" class="headerlink" title="10.使用 includes 简化 if 判断"></a>10.使用 includes 简化 if 判断</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">if</span> (a === <span class="number">1</span> || a === <span class="number">2</span> || a === <span class="number">3</span> || a === <span class="number">4</span>) &#123;</span><br><span class="line">  <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">if</span> (arr.<span class="title function_">includes</span>(a)) &#123;</span><br><span class="line">  <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>巧用数组方法，尽量避免用 for 循环</p>
<h2 id="11-使用-some-方法判断是否有满足条件的元素"><a href="#11-使用-some-方法判断是否有满足条件的元素" class="headerlink" title="11.使用 some 方法判断是否有满足条件的元素"></a>11.使用 some 方法判断是否有满足条件的元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isHasNum</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] === n) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">isHasNum</span> = (<span class="params">n</span>) =&gt; arr.<span class="title function_">some</span>(<span class="function">(<span class="params">num</span>) =&gt;</span> num === n);</span><br><span class="line"></span><br><span class="line"><span class="comment">// best</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">isHasNum</span> = (<span class="params">n, arr</span>) =&gt; arr.<span class="title function_">some</span>(<span class="function">(<span class="params">num</span>) =&gt;</span> num === n);</span><br></pre></td></tr></table></figure>

<h2 id="12-使用-forEach-方法遍历数组，不形成新数组"><a href="#12-使用-forEach-方法遍历数组，不形成新数组" class="headerlink" title="12.使用 forEach 方法遍历数组，不形成新数组"></a>12.使用 forEach 方法遍历数组，不形成新数组</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// todo</span></span><br><span class="line">  arr[i].<span class="property">key</span> = balabala;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// todo</span></span><br><span class="line">  item.<span class="property">key</span> = balabala;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="13-使用-filter-方法过滤原数组，形成新数组"><a href="#13-使用-filter-方法过滤原数组，形成新数组" class="headerlink" title="13.使用 filter 方法过滤原数组，形成新数组"></a>13.使用 filter 方法过滤原数组，形成新数组</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>],</span><br><span class="line">  newArr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr[i] &gt; <span class="number">4</span>) &#123;</span><br><span class="line">    newArr.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">n</span>) =&gt;</span> n &gt; <span class="number">4</span>); <span class="comment">// [5, 7]</span></span><br></pre></td></tr></table></figure>

<h2 id="14-使用-map-对数组中所有元素批量处理，形成新数组"><a href="#14-使用-map-对数组中所有元素批量处理，形成新数组" class="headerlink" title="14.使用 map 对数组中所有元素批量处理，形成新数组"></a>14.使用 map 对数组中所有元素批量处理，形成新数组</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>],</span><br><span class="line">  newArr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  newArr.<span class="title function_">push</span>(arr[i] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.<span class="title function_">map</span>(<span class="function">(<span class="params">n</span>) =&gt;</span> n + <span class="number">1</span>); <span class="comment">// [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure>

<p>巧用对象方法，避免使用 for…in</p>
<h2 id="15-使用-Object-values-快速获取对象键值"><a href="#15-使用-Object-values-快速获取对象键值" class="headerlink" title="15.使用 Object.values 快速获取对象键值"></a>15.使用 Object.values 快速获取对象键值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">let</span> values = [];</span><br><span class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  values.<span class="title function_">push</span>(obj[key]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">let</span> values = <span class="title class_">Object</span>.<span class="title function_">values</span>(obj); <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>

<h2 id="16-使用-Object-keys-快速获取对象键名"><a href="#16-使用-Object-keys-快速获取对象键名" class="headerlink" title="16.使用 Object.keys 快速获取对象键名"></a>16.使用 Object.keys 快速获取对象键名</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">let</span> keys = [];</span><br><span class="line"><span class="keyword">for</span> (value <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  keys.<span class="title function_">push</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">let</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>巧用解构简化代码</p>
<h2 id="17-解构数组进行变量值的替换"><a href="#17-解构数组进行变量值的替换" class="headerlink" title="17.解构数组进行变量值的替换"></a>17.解构数组进行变量值的替换</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>,</span><br><span class="line">  b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>,</span><br><span class="line">  b = ((<span class="number">2</span>)[(b, a)] = [a, b]);</span><br></pre></td></tr></table></figure>

<h2 id="18-解构对象"><a href="#18-解构对象" class="headerlink" title="18.解构对象"></a>18.解构对象</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">setForm (person) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = person.<span class="property">name</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = person.<span class="property">age</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">setForm (&#123;name, age&#125;) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="19-解构时重命名简化命名"><a href="#19-解构时重命名简化命名" class="headerlink" title="19.解构时重命名简化命名"></a>19.解构时重命名简化命名</h2><p>有的后端返回的键名特别长，你可以这样干</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">setForm (data) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">one</span> = data.<span class="property">aaa_bbb_ccc_ddd</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">two</span> = data.<span class="property">eee_fff_ggg</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">setForm (&#123;aaa_bbb_ccc_ddd, eee_fff_ggg&#125;) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">one</span> = aaa_bbb_ccc_ddd</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">two</span> = eee_fff_ggg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// best</span></span><br><span class="line">setForm (&#123;<span class="attr">aaa_bbb_ccc_ddd</span>: one, <span class="attr">eee_fff_ggg</span>: two&#125;) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">one</span> = one</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">two</span> = two</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="20-解构时设置默认值"><a href="#20-解构时设置默认值" class="headerlink" title="20.解构时设置默认值"></a>20.解构时设置默认值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">setForm (&#123;name, age&#125;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!age) age = <span class="number">16</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">setForm (&#123;name, age = <span class="number">16</span>&#125;) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="21-短路符设置默认值"><a href="#21-短路符设置默认值" class="headerlink" title="21.||短路符设置默认值"></a>21.||短路符设置默认值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">38</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name = person.<span class="property">name</span> || <span class="string">&quot;佚名&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="22-短路符判断依赖的键是否存在防止报错’xxx-of-undfined’"><a href="#22-短路符判断依赖的键是否存在防止报错’xxx-of-undfined’" class="headerlink" title="22.&amp;&amp;短路符判断依赖的键是否存在防止报错’xxx of undfined’"></a>22.&amp;&amp;短路符判断依赖的键是否存在防止报错’xxx of undfined’</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">38</span>,</span><br><span class="line">  <span class="attr">children</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;张小三&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> childrenName = person.<span class="property">children</span> &amp;&amp; person.<span class="property">childre</span>.<span class="property">name</span>;</span><br></pre></td></tr></table></figure>

<h2 id="23-字符串拼接使用"><a href="#23-字符串拼接使用" class="headerlink" title="23.字符串拼接使用${}"></a>23.字符串拼接使用<code>$&#123;&#125;</code></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;LiMing&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span> (obj) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;大家好，我叫&#x27;</span> + person.<span class="property">name</span> = <span class="string">&#x27;，我今年&#x27;</span> + person.<span class="property">age</span> + <span class="string">&#x27;了&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span> (person) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`大家好，我叫<span class="subst">$&#123;person.name&#125;</span>，我今年<span class="subst">$&#123;person.age&#125;</span>了`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// best</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span> (&#123;name, age&#125;) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`大家好，我叫<span class="subst">$&#123;name&#125;</span>，我今年<span class="subst">$&#123;age&#125;</span>了`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="24-函数使用箭头函数"><a href="#24-函数使用箭头函数" class="headerlink" title="24.函数使用箭头函数"></a>24.函数使用箭头函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr [<span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>]</span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findStudentByAge</span> (arr, age) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">num</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> num === age</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">findStudentByAge</span> = (<span class="params">arr, age</span>)=&gt; arr.<span class="title function_">filter</span>(<span class="function"><span class="params">num</span> =&gt;</span> num === age)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="25-函数参数校验"><a href="#25-函数参数校验" class="headerlink" title="25.函数参数校验"></a>25.函数参数校验</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">findStudentByAge</span> = (<span class="params">arr, age</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!age) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;参数不能为空&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">num</span>) =&gt;</span> num === age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">checkoutType</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;参数不能为空&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">findStudentByAge</span> = (<span class="params">arr, age = checkoutType()</span>) =&gt;</span><br><span class="line">  arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">num</span>) =&gt;</span> num === age);</span><br></pre></td></tr></table></figure>

<p>欢迎大佬们指正交流，感谢支持</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>20道大厂面试题</title>
    <url>/post/dd786a289f64/</url>
    <content><![CDATA[<h2 id="1-new的实现原理是什么？"><a href="#1-new的实现原理是什么？" class="headerlink" title="1. new的实现原理是什么？"></a>1. new的实现原理是什么？</h2><p>new 的实现原理:</p>
<ul>
<li>创建一个空对象，构造函数中的this指向这个空对象</li>
<li>这个新对象被执行 [[原型]] 连接</li>
<li>执行构造函数方法，属性和方法被添加到this引用的对象中</li>
<li>如果构造函数中没有返回其它对象，那么返回this，即创建的这个的新对象，否则，返回构造函数中返回的对象。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_new</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> target = &#123;&#125;; <span class="comment">//创建的新对象</span></span><br><span class="line">    <span class="comment">//第一个参数是构造函数</span></span><br><span class="line">    <span class="keyword">let</span> [constructor, ...args] = [...<span class="variable language_">arguments</span>];</span><br><span class="line">    <span class="comment">//执行[[原型]]连接;target 是 constructor 的实例</span></span><br><span class="line">    target.<span class="property">__proto__</span> = constructor.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">    <span class="comment">//执行构造函数，将属性或方法添加到创建的空对象上</span></span><br><span class="line">    <span class="keyword">let</span> result = constructor.<span class="title function_">apply</span>(target, args);</span><br><span class="line">    <span class="keyword">if</span> (result &amp;&amp; (<span class="keyword">typeof</span> (result) == <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> (result) == <span class="string">&quot;function&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">//如果构造函数执行的结构返回的是一个对象，那么返回这个对象</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果构造函数返回的不是一个对象，返回创建的新对象</span></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-如何正确判断this的指向？"><a href="#2-如何正确判断this的指向？" class="headerlink" title="2. 如何正确判断this的指向？"></a>2. 如何正确判断this的指向？</h2><p>如果用一句话说明 this 的指向，那么即是: 谁调用它，this 就指向谁。</p>
<p>但是仅通过这句话，我们很多时候并不能准确判断 this 的指向。因此我们需要借助一些规则去帮助自己：</p>
<p>this 的指向可以按照以下顺序判断:</p>
<p><strong>全局环境中的 this</strong></p>
<p>浏览器环境：无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象 window;</p>
<p>node 环境：无论是否在严格模式下，在全局执行环境中（在任何函数体外部），this 都是空对象 {};</p>
<p><strong>是否是 new 绑定</strong></p>
<p>如果是 new 绑定，并且构造函数中没有返回 function 或者是 object，那么 this 指向这个新对象。如下:</p>
<blockquote>
<p>构造函数返回值不是 function 或 object。new Super() 返回的是 this 对象。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Super</span>(<span class="params">age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="title class_">Super</span>(<span class="string">&#x27;26&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="property">age</span>); <span class="comment">//26</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>构造函数返回值是 function 或 object，new Super()是返回的是Super种返回的对象。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Super</span>(<span class="params">age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="string">&#x27;2&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="title class_">Super</span>(<span class="string">&#x27;hello&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance);<span class="comment">//&#123; a: &#x27;2&#x27; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="property">age</span>); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p><strong>函数是否通过 call,apply 调用，或者使用了 bind 绑定，如果是，那么this绑定的就是指定的对象【归结为显式绑定】。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">info</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    info</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">28</span>;</span><br><span class="line"><span class="keyword">var</span> info = person.<span class="property">info</span>;</span><br><span class="line">info.<span class="title function_">call</span>(person);   <span class="comment">//20</span></span><br><span class="line">info.<span class="title function_">apply</span>(person);  <span class="comment">//20</span></span><br><span class="line">info.<span class="title function_">bind</span>(person)(); <span class="comment">//20</span></span><br></pre></td></tr></table></figure>
<p>这里同样需要注意一种特殊情况，如果 call,apply 或者 bind 传入的第一个参数值是 undefined 或者 null，严格模式下 this 的值为传入的值 null &#x2F;undefined。非严格模式下，实际应用的默认绑定规则，this 指向全局对象(node环境为global，浏览器环境为window)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">info</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//node环境中:非严格模式 global，严格模式为null</span></span><br><span class="line">    <span class="comment">//浏览器环境中:非严格模式 window，严格模式为null</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    info</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">28</span>;</span><br><span class="line"><span class="keyword">var</span> info = person.<span class="property">info</span>;</span><br><span class="line"><span class="comment">//严格模式抛出错误；</span></span><br><span class="line"><span class="comment">//非严格模式，node下输出undefined（因为全局的age不会挂在 global 上）</span></span><br><span class="line"><span class="comment">//非严格模式。浏览器环境下输出 28（因为全局的age会挂在 window 上）</span></span><br><span class="line">info.<span class="title function_">call</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p><strong>隐式绑定，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的隐式调用为: xxx.fn()</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">info</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    info</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">28</span>;</span><br><span class="line">person.<span class="title function_">info</span>(); <span class="comment">//20;执行的是隐式绑定</span></span><br></pre></td></tr></table></figure>
<p><strong>默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用。</strong></p>
<p>非严格模式： node环境，执行全局对象 global，浏览器环境，执行全局对象 window。</p>
<p>严格模式：执行 undefined</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">info</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">28</span>;</span><br><span class="line"><span class="comment">//严格模式；抛错</span></span><br><span class="line"><span class="comment">//非严格模式，node下输出 undefined（因为全局的age不会挂在 global 上）</span></span><br><span class="line"><span class="comment">//非严格模式。浏览器环境下输出 28（因为全局的age会挂在 window 上）</span></span><br><span class="line"><span class="comment">//严格模式抛出，因为 this 此时是 undefined</span></span><br><span class="line"><span class="title function_">info</span>(); </span><br></pre></td></tr></table></figure>
<p><strong>箭头函数的情况：</strong></p>
<p>箭头函数没有自己的this，继承外层上下文绑定的this。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">info</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>); <span class="comment">//this继承的是外层上下文绑定的this</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">age</span>: <span class="number">28</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> info = obj.<span class="title function_">info</span>();</span><br><span class="line"><span class="title function_">info</span>(); <span class="comment">//20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> info2 = obj.<span class="property">info</span>.<span class="title function_">call</span>(person);</span><br><span class="line"><span class="title function_">info2</span>(); <span class="comment">//28</span></span><br></pre></td></tr></table></figure>

<h2 id="3-深拷贝和浅拷贝的区别是什么？实现一个深拷贝"><a href="#3-深拷贝和浅拷贝的区别是什么？实现一个深拷贝" class="headerlink" title="3. 深拷贝和浅拷贝的区别是什么？实现一个深拷贝"></a>3. 深拷贝和浅拷贝的区别是什么？实现一个深拷贝</h2><p>深拷贝和浅拷贝是针对复杂数据类型来说的，浅拷贝只拷贝一层，而深拷贝是层层拷贝。</p>
<p><strong>深拷贝</strong></p>
<blockquote>
<p>深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。 深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。</p>
</blockquote>
<p><strong>浅拷贝</strong></p>
<blockquote>
<p>浅拷贝是会将对象的每个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。</p>
</blockquote>
<p>可以使用 for in、 Object.assign、 扩展运算符 … 、Array.prototype.slice()、Array.prototype.concat() 等，例如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Yvette&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">hobbies</span>: [<span class="string">&#x27;reading&#x27;</span>, <span class="string">&#x27;photography&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line"><span class="keyword">let</span> obj3 = &#123;...obj&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">obj.<span class="property">hobbies</span>.<span class="title function_">push</span>(<span class="string">&#x27;coding&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj);<span class="comment">//&#123; name: &#x27;Jack&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2);<span class="comment">//&#123; name: &#x27;Yvette&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj3);<span class="comment">//&#123; name: &#x27;Yvette&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;</span></span><br></pre></td></tr></table></figure>
<p>可以看出浅拷贝只最第一层属性进行了拷贝，当第一层的属性值是基本数据类型时，新的对象和原对象互不影响，但是如果第一层的属性值是复杂数据类型，那么新对象和原对象的属性值其指向的是同一块内存地址。</p>
<p><strong>深拷贝实现</strong></p>
<blockquote>
<p>1.深拷贝最简单的实现是: JSON.parse(JSON.stringify(obj))</p>
</blockquote>
<p>JSON.parse(JSON.stringify(obj)) 是最简单的实现方式，但是有一些缺陷：</p>
<ol>
<li>对象的属性值是函数时，无法拷贝。</li>
<li>原型链上的属性无法拷贝</li>
<li>不能正确的处理 Date 类型的数据</li>
<li>不能处理 RegExp</li>
<li>会忽略 symbol</li>
<li>会忽略 undefined</li>
</ol>
<blockquote>
<p>2.实现一个 deepClone 函数</p>
</blockquote>
<ol>
<li>如果是基本数据类型，直接返回</li>
<li>如果是 RegExp 或者 Date 类型，返回对应类型</li>
<li>如果是复杂数据类型，递归。</li>
<li>考虑循环引用的问题</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) &#123; <span class="comment">//递归拷贝</span></span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(obj);</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(obj);</span><br><span class="line">    <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">//如果不是复杂数据类型，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hash.<span class="title function_">has</span>(obj)) &#123;</span><br><span class="line">        <span class="keyword">return</span> hash.<span class="title function_">get</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果obj是数组，那么 obj.constructor 是 [Function: Array]</span></span><br><span class="line"><span class="comment">     * 如果obj是对象，那么 obj.constructor 是 [Function: Object]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">let</span> t = <span class="keyword">new</span> obj.<span class="title function_">constructor</span>(<span class="params"></span>);</span><br><span class="line">    hash.<span class="title function_">set</span>(obj, t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;<span class="comment">//是否是自身的属性</span></span><br><span class="line">            t[key] = <span class="title function_">deepClone</span>(obj[key], hash);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-call-apply-的实现原理是什么？"><a href="#4-call-apply-的实现原理是什么？" class="headerlink" title="4. call&#x2F;apply 的实现原理是什么？"></a>4. call&#x2F;apply 的实现原理是什么？</h2><p>call 和 apply 的功能相同，都是改变 this 的执行，并立即执行函数。区别在于传参方式不同。</p>
<ul>
<li><p>func.call(thisArg, arg1, arg2, …)：第一个参数是 this 指向的对象，其它参数依次传入。</p>
</li>
<li><p>func.apply(thisArg, [argsArray])：第一个参数是 this 指向的对象，第二个参数是数组或类数组。</p>
</li>
</ul>
<p>一起思考一下，如何模拟实现 call ？</p>
<p>首先，我们知道，函数都可以调用 call，说明 call 是函数原型上的方法，所有的实例都可以调用。即: Function.prototype.call。</p>
<ul>
<li>在 call 方法中获取调用call()函数</li>
<li>如果第一个参数没有传入，那么默认指向 window &#x2F; global(非严格模式)</li>
<li>传入 call 的第一个参数是 this 指向的对象，根据隐式绑定的规则，我们知道 obj.foo(), foo() 中的 this 指向 obj;因此我们可以这样调用函数 thisArgs.func(…args)</li>
<li>返回执行结果<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">call</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> [thisArg, ...args] = [...<span class="variable language_">arguments</span>];</span><br><span class="line">    <span class="keyword">if</span> (!thisArg) &#123;</span><br><span class="line">        <span class="comment">//context为null或者是undefined</span></span><br><span class="line">        thisArg = <span class="keyword">typeof</span> <span class="variable language_">window</span> === <span class="string">&#x27;undefined&#x27;</span> ? <span class="variable language_">global</span> : <span class="variable language_">window</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//this的指向的是当前函数 func (func.call)</span></span><br><span class="line">    thisArg.<span class="property">func</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="comment">//执行函数</span></span><br><span class="line">    <span class="keyword">let</span> result = thisArg.<span class="title function_">func</span>(...args);</span><br><span class="line">    <span class="keyword">delete</span> thisArg.<span class="property">func</span>; <span class="comment">//thisArg上并没有 func 属性，因此需要移除</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
bind 的实现思路和 call 一致，仅参数处理略有差别。如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">apply</span> = <span class="keyword">function</span>(<span class="params">thisArg, rest</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result; <span class="comment">//函数返回结果</span></span><br><span class="line">    <span class="keyword">if</span> (!thisArg) &#123;</span><br><span class="line">        <span class="comment">//context为null或者是undefined</span></span><br><span class="line">        thisArg = <span class="keyword">typeof</span> <span class="variable language_">window</span> === <span class="string">&#x27;undefined&#x27;</span> ? <span class="variable language_">global</span> : <span class="variable language_">window</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//this的指向的是当前函数 func (func.call)</span></span><br><span class="line">    thisArg.<span class="property">func</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">if</span>(!rest) &#123;</span><br><span class="line">        <span class="comment">//第二个参数为 null / undefined </span></span><br><span class="line">        result = thisArg.<span class="title function_">func</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        result = thisArg.<span class="title function_">func</span>(...rest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> thisArg.<span class="property">func</span>; <span class="comment">//thisArg上并没有 func 属性，因此需要移除</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-柯里化函数实现"><a href="#5-柯里化函数实现" class="headerlink" title="5. 柯里化函数实现"></a>5. 柯里化函数实现</h2><p>在开始之前，我们首先需要搞清楚函数柯里化的概念。</p>
<p>函数柯里化是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">curry</span> = (<span class="params">fn, ...args</span>) =&gt;</span><br><span class="line">    args.<span class="property">length</span> &lt; fn.<span class="property">length</span></span><br><span class="line">        <span class="comment">//参数长度不足时，重新柯里化该函数，等待接受新参数</span></span><br><span class="line">        ? <span class="function">(<span class="params">...<span class="variable language_">arguments</span></span>) =&gt;</span> <span class="title function_">curry</span>(fn, ...args, ...<span class="variable language_">arguments</span>)</span><br><span class="line">        <span class="comment">//参数长度满足时，执行函数</span></span><br><span class="line">        : <span class="title function_">fn</span>(...args);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sumFn</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sum = <span class="title function_">curry</span>(sumFn);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">5</span>));<span class="comment">//10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>));<span class="comment">//10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">2</span>)(<span class="number">3</span>, <span class="number">5</span>));<span class="comment">//10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">2</span>, <span class="number">3</span>)(<span class="number">5</span>));<span class="comment">//10</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数柯里化的主要作用：</p>
</blockquote>
<ul>
<li>参数复用</li>
<li>提前返回 – 返回接受余下的参数且返回结果的新函数</li>
<li>延迟执行 – 返回新函数，等待执行</li>
</ul>
<h2 id="6-如何让-a-1-a-2-a-3-的值为true？"><a href="#6-如何让-a-1-a-2-a-3-的值为true？" class="headerlink" title="6. 如何让 (a &#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D; 3) 的值为true？"></a>6. 如何让 (a &#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D; 3) 的值为true？</h2><blockquote>
<p>利用隐式类型转换</p>
</blockquote>
<p>&#x3D;&#x3D; 操作符在左右数据类型不一致时，会先进行隐式转换。</p>
<p>a &#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D; 3 的值意味着其不可能是基本数据类型。因为如果 a 是 null 或者是 undefined bool类型，都不可能返回true。</p>
<p>因此可以推测 a 是复杂数据类型，JS 中复杂数据类型只有 object，回忆一下，Object 转换为原始类型会调用什么方法？</p>
<ul>
<li><p>如果部署了 [Symbol.toPrimitive] 接口，那么调用此接口，若返回的不是基本数据类型，抛出错误。</p>
</li>
<li><p>如果没有部署 [Symbol.toPrimitive] 接口，那么根据要转换的类型，先调用 valueOf &#x2F; toString</p>
</li>
</ul>
<p>i. 非Date类型对象，hint 是 default 时，调用顺序为：valueOf &gt;&gt;&gt; toString，即valueOf 返回的不是基本数据类型，才会继续调用 valueOf，如果toString 返回的还不是基本数据类型，那么抛出错误。</p>
<p>ii. 如果 hint 是 string(Date对象的hint默认是string) ，调用顺序为：toString &gt;&gt;&gt; valueOf，即toString 返回的不是基本数据类型，才会继续调用 valueOf，如果valueOf 返回的还不是基本数据类型，那么抛出错误。</p>
<p>iii. 如果 hint 是 number，调用顺序为： valueOf &gt;&gt;&gt; toString</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//部署 [Symbol.toPrimitive] / valueOf/ toString 皆可</span></span><br><span class="line"><span class="comment">//一次返回1，2，3 即可。</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>]: (<span class="keyword">function</span>(<span class="params">hint</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//闭包的特性之一：i 不会被回收</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i++;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;)()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>利用数据劫持(Proxy&#x2F;Object.definedProperty)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    <span class="attr">i</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="property">i</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>数组的 toString 接口默认调用数组的 join 方法，重新 join 方法</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.<span class="property">join</span> = a.<span class="property">shift</span>;</span><br></pre></td></tr></table></figure>
<h2 id="7-什么是BFC？BFC的布局规则是什么？如何创建BFC？"><a href="#7-什么是BFC？BFC的布局规则是什么？如何创建BFC？" class="headerlink" title="7. 什么是BFC？BFC的布局规则是什么？如何创建BFC？"></a>7. 什么是BFC？BFC的布局规则是什么？如何创建BFC？</h2><p>Box 是 CSS 布局的对象和基本单位，页面是由若干个Box组成的。</p>
<p>元素的类型 和 display 属性，决定了这个 Box 的类型。不同类型的 Box 会参与不同的 Formatting Context。</p>
<blockquote>
<p>Formatting Context</p>
</blockquote>
<p>Formatting Context 是页面的一块渲染区域，并且有一套渲染规则，决定了其子元素将如何定位，以及和其它元素的关系和相互作用。</p>
<p>Formatting Context 有 BFC (Block formatting context)，IFC (Inline formatting context)，FFC (Flex formatting context) 和 GFC (Grid formatting context)。FFC 和 GFC 为 CC3 中新增。</p>
<blockquote>
<p>BFC布局规则</p>
</blockquote>
<ul>
<li>BFC内，盒子依次垂直排列。</li>
<li>BFC内，两个盒子的垂直距离由 margin 属性决定。属于同一个BFC的两个相邻Box的margin会发生重叠【符合合并原则的margin合并后是使用大的margin】</li>
<li>BFC内，每个盒子的左外边缘接触内部盒子的左边缘（对于从右到左的格式，右边缘接触）。即使在存在浮动的情况下也是如此。除非创建新的BFC。</li>
<li>BFC的区域不会与float box重叠。</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li>
<li>计算BFC的高度时，浮动元素也参与计算。</li>
</ul>
<blockquote>
<p>如何创建BFC</p>
</blockquote>
<ul>
<li>根元素</li>
<li>浮动元素（float 属性不为 none）</li>
<li>position 为 absolute 或 fixed</li>
<li>overflow 不为 visible 的块元素</li>
<li>display 为 inline-block, table-cell, table-caption</li>
</ul>
<blockquote>
<p>BFC 的应用</p>
</blockquote>
<ul>
<li>防止 margin 重叠 (同一个BFC内的两个两个相邻Box的 margin 会发生重叠，触发生成两个BFC，即不会重叠)</li>
<li>清除内部浮动 (创建一个新的 BFC，因为根据 BFC 的规则，计算 BFC 的高度时，浮动元素也参与计算)</li>
<li>自适应多栏布局 (BFC的区域不会与float box重叠。因此，可以触发生成一个新的BFC)</li>
</ul>
<h2 id="8-异步加载JS脚本的方式有哪些？"><a href="#8-异步加载JS脚本的方式有哪些？" class="headerlink" title="8. 异步加载JS脚本的方式有哪些？"></a>8. 异步加载JS脚本的方式有哪些？</h2><blockquote>
<p>1.&lt;script&gt; 的 defer 属性，HTML4 中新增</p>
</blockquote>
<blockquote>
<p>2.&lt;script&gt; 的 async 属性，HTML5 中新增</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;../XXX.js&quot;</span> defer&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>defer 和 async 的区别在于：</p>
<ul>
<li>defer 要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），在window.onload 之前执行；</li>
<li>async 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。</li>
<li>如果有多个 defer 脚本，会按照它们在页面出现的顺序加载</li>
<li>多个 async 脚本不能保证加载顺序</li>
</ul>
<blockquote>
<p>动态创建 script 标签</p>
</blockquote>
<p>动态创建的 script ，设置 src 并不会开始下载，而是要添加到文档中，JS文件才会开始下载。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.<span class="property">src</span> = <span class="string">&#x27;XXX.js&#x27;</span>;</span><br><span class="line"><span class="comment">// 添加到html文件中才会开始下载</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">append</span>(script);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>XHR 异步加载JS</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;js/xxx.js&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> == <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="built_in">eval</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-ES5有几种方式可以实现继承？分别有哪些优缺点？"><a href="#9-ES5有几种方式可以实现继承？分别有哪些优缺点？" class="headerlink" title="9. ES5有几种方式可以实现继承？分别有哪些优缺点？"></a>9. ES5有几种方式可以实现继承？分别有哪些优缺点？</h2><p>ES5 有 6 种方式可以实现继承，分别为：</p>
<p><strong>1. 原型链继承</strong></p>
<p>原型链继承的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Yvette&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&#x27;pink&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">22</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>();</span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getAge</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">SubType</span>;</span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br><span class="line">instance1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&#x27;yellow&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1.<span class="title function_">getName</span>()); <span class="comment">//&#x27;Yvette&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1.<span class="property">colors</span>);<span class="comment">//[ &#x27;pink&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;yellow&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance2.<span class="property">colors</span>);<span class="comment">//[ &#x27;pink&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;yellow&#x27; ]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>缺点：</p>
</blockquote>
<ul>
<li>通过原型来实现继承时，原型会变成另一个类型的实例，原先的实例属性变成了现在的原型属性，该原型的引用类型属性会被所有的实例共享。</li>
<li>在创建子类型的实例时，没有办法在不影响所有对象实例的情况下给超类型的构造函数中传递参数。</li>
</ul>
<p><strong>2. 借用构造函数</strong><br>借用构造函数的技术，其基本思想为:</p>
<p>在子类型的构造函数中调用超类型构造函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&#x27;pink&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&#x27;Yvette&#x27;</span>);</span><br><span class="line">instance1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&#x27;yellow&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1.<span class="property">colors</span>);<span class="comment">//[&#x27;pink&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, yellow]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance2.<span class="property">colors</span>); <span class="comment">//[&#x27;pink&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>优点:</p>
</blockquote>
<ul>
<li>可以向超类传递参数</li>
<li>解决了原型中包含引用类型值被所有实例共享的问题</li>
</ul>
<blockquote>
<p>缺点:</p>
</blockquote>
<ul>
<li>方法都在构造函数中定义，函数复用无从谈起，另外超类型原型中定义的方法对于子类型而言都是不可见的。</li>
</ul>
<p><strong>3. 组合继承(原型链 + 借用构造函数)</strong></p>
<p>组合继承指的是将原型链和借用构造函数技术组合到一块，从而发挥二者之长的一种继承模式。基本思路：</p>
<p>使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承，既通过在原型上定义方法来实现了函数复用，又保证了每个实例都有自己的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&#x27;pink&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SuberType</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SuberType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>();</span><br><span class="line"><span class="title class_">SuberType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">SuberType</span>;</span><br><span class="line"><span class="title class_">SuberType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> <span class="title class_">SuberType</span>(<span class="string">&#x27;Yvette&#x27;</span>, <span class="number">20</span>);</span><br><span class="line">instance1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&#x27;yellow&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1.<span class="property">colors</span>); <span class="comment">//[ &#x27;pink&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;yellow&#x27; ]</span></span><br><span class="line">instance1.<span class="title function_">sayName</span>(); <span class="comment">//Yvette</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> <span class="title class_">SuberType</span>(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">22</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance2.<span class="property">colors</span>); <span class="comment">//[ &#x27;pink&#x27;, &#x27;blue&#x27;, &#x27;green&#x27; ]</span></span><br><span class="line">instance2.<span class="title function_">sayName</span>();<span class="comment">//Jack</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>缺点:</p>
</blockquote>
<p>无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。</p>
<blockquote>
<p>优点:</p>
</blockquote>
<ul>
<li>可以向超类传递参数</li>
<li>每个实例都有自己的属性</li>
<li>实现了函数复用</li>
</ul>
<p><strong>4. 原型式继承</strong></p>
<p>原型继承的基本思想：</p>
<p>借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 object() 函数内部，先穿甲一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例，从本质上讲，object() 对传入的对象执行了一次浅拷贝。</p>
<p>ECMAScript5通过新增 Object.create()方法规范了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象(可以覆盖原型对象上的同名属性)，在传入一个参数的情况下，Object.create() 和 object() 方法的行为相同。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Yvette&#x27;</span>,</span><br><span class="line">    <span class="attr">hobbies</span>: [<span class="string">&#x27;reading&#x27;</span>, <span class="string">&#x27;photography&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="title class_">Object</span>.<span class="title function_">create</span>(person);</span><br><span class="line">person1.<span class="property">name</span> = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">person1.<span class="property">hobbies</span>.<span class="title function_">push</span>(<span class="string">&#x27;coding&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(person);</span><br><span class="line">person2.<span class="property">name</span> = <span class="string">&#x27;Echo&#x27;</span>;</span><br><span class="line">person2.<span class="property">hobbies</span>.<span class="title function_">push</span>(<span class="string">&#x27;running&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">hobbies</span>);<span class="comment">//[ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27;, &#x27;running&#x27; ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">hobbies</span>);<span class="comment">//[ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27;, &#x27;running&#x27; ]</span></span><br></pre></td></tr></table></figure>
<p>在没有必要创建构造函数，仅让一个对象与另一个对象保持相似的情况下，原型式继承是可以胜任的。</p>
<blockquote>
<p>缺点:</p>
</blockquote>
<p>同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。</p>
<p><strong>5. 寄生式继承</strong></p>
<p>寄生式继承是与原型式继承紧密相关的一种思路。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部已某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createAnother</span>(<span class="params">original</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> clone = <span class="title function_">object</span>(original);<span class="comment">//通过调用函数创建一个新对象</span></span><br><span class="line">    clone.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="comment">//以某种方式增强这个对象</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> clone;<span class="comment">//返回这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Yvette&#x27;</span>,</span><br><span class="line">    <span class="attr">hobbies</span>: [<span class="string">&#x27;reading&#x27;</span>, <span class="string">&#x27;photography&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="title function_">createAnother</span>(person);</span><br><span class="line">person2.<span class="title function_">sayHi</span>(); <span class="comment">//hi</span></span><br></pre></td></tr></table></figure>

<p>基于 person 返回了一个新对象 -—— person2，新对象不仅具有 person 的所有属性和方法，而且还有自己的 sayHi() 方法。在考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。</p>
<blockquote>
<p>缺点：</p>
</blockquote>
<ul>
<li>使用寄生式继承来为对象添加函数，会由于不能做到函数复用而效率低下。</li>
<li>同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。</li>
</ul>
<p><strong>6. 寄生组合式继承</strong></p>
<p>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法，基本思路：</p>
<p>不必为了指定子类型的原型而调用超类型的构造函数，我们需要的仅是超类型原型的一个副本，本质上就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。寄生组合式继承的基本模式如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">subType, superType</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = <span class="title function_">object</span>(superType.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">//创建对象</span></span><br><span class="line">    prototype.<span class="property">constructor</span> = subType;<span class="comment">//增强对象</span></span><br><span class="line">    subType.<span class="property"><span class="keyword">prototype</span></span> = prototype;<span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第一步：创建超类型原型的一个副本</li>
<li>第二步：为创建的副本添加 constructor 属性</li>
<li>第三步：将新创建的对象赋值给子类型的原型</li>
</ul>
<p>至此，我们就可以通过调用 inheritPrototype 来替换为子类型原型赋值的语句：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&#x27;pink&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...code</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SuberType</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SuberType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>();</span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">SuberType</span>, <span class="title class_">SuperType</span>);</span><br><span class="line"><span class="comment">//...code</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>优点:</p>
</blockquote>
<p>只调用了一次超类构造函数，效率更高。避免在SuberType.prototype上面创建不必要的、多余的属性，与其同时，原型链还能保持不变。</p>
<p>因此寄生组合继承是引用类型最理性的继承范式。</p>
<h2 id="10-隐藏页面中的某个元素的方法有哪些？"><a href="#10-隐藏页面中的某个元素的方法有哪些？" class="headerlink" title="10. 隐藏页面中的某个元素的方法有哪些？"></a>10. 隐藏页面中的某个元素的方法有哪些？</h2><blockquote>
<p>隐藏类型</p>
</blockquote>
<p>屏幕并不是唯一的输出机制，比如说屏幕上看不见的元素（隐藏的元素），其中一些依然能够被读屏软件阅读出来（因为读屏软件依赖于可访问性树来阐述）。为了消除它们之间的歧义，我们将其归为三大类：</p>
<blockquote>
<p>完全隐藏：</p>
</blockquote>
<ul>
<li>元素从渲染树中消失，不占据空间。</li>
<li>视觉上的隐藏：屏幕中不可见，占据空间。</li>
<li>语义上的隐藏：读屏软件不可读，但正常占据空。<br>完全隐藏</li>
</ul>
<p><strong>1.display 属性</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">display: none;</span><br></pre></td></tr></table></figure>
<p><strong>2.hidden 属性</strong></p>
<p>HTML5 新增属性，相当于 display: none</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div hidden&gt; &lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>视觉上的隐藏</p>
</blockquote>
<p><strong>1.利用 position 和 盒模型 将元素移出可视区范围</strong></p>
<ul>
<li><p>设置 posoition 为 absolute 或 fixed，�通过设置 top、left 等值，将其移出可视区域。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>:absolute;</span><br><span class="line"><span class="attribute">left</span>: -<span class="number">99999px</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>设置 position 为 relative，通过设置 top、left 等值，将其移出可视区域。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>: relative;</span><br><span class="line"><span class="attribute">left</span>: -<span class="number">99999px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0</span></span><br></pre></td></tr></table></figure></li>
<li><p>设置 margin 值，将其移出可视区域范围（可视区域占位）。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">margin-left</span>: -<span class="number">99999px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><strong>2. 利用 transfrom</strong></p>
</li>
<li><p>缩放</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0</span>);</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>移动 translateX, translateY</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">99999px</span>);</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>3.设置其大小为0</strong></p>
</li>
<li><p>宽高为0，字体大小为0：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>宽高为0，超出隐藏:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">overflow</span>: hidden;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置透明度为0</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">opacity</span>: <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>visibility属性</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">visibility</span>: hidden;</span><br></pre></td></tr></table></figure>
</li>
<li><p>层级覆盖，z-index 属性</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>: relative;</span><br><span class="line"><span class="attribute">z-index</span>: -<span class="number">999</span>;</span><br></pre></td></tr></table></figure>
<p>再设置一个层级较高的元素覆盖在此元素上。</p>
</li>
<li><p>clip-path 裁剪</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(<span class="number">0</span> <span class="number">0</span>, <span class="number">0</span> <span class="number">0</span>, <span class="number">0</span> <span class="number">0</span>, <span class="number">0</span> <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>语义上的隐藏</p>
</blockquote>
</li>
<li><p>aria-hidden 属性</p>
</li>
</ul>
<p>读屏软件不可读，占据空间，可见。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div aria-hidden=&quot;true&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h2 id="11-let、const、var-的区别有哪些？"><a href="#11-let、const、var-的区别有哪些？" class="headerlink" title="11. let、const、var 的区别有哪些？"></a>11. let、const、var 的区别有哪些？</h2><table>
<thead>
<tr>
<th>声明方式</th>
<th>变量提升</th>
<th>暂时性死区</th>
<th>重复声明</th>
<th>块作用域有效</th>
<th>初始值</th>
<th>初始值</th>
</tr>
</thead>
<tbody><tr>
<td>var</td>
<td>会</td>
<td>不存在</td>
<td>允许</td>
<td>不是</td>
<td>非必须</td>
<td>允许</td>
</tr>
<tr>
<td>let</td>
<td>不会</td>
<td>存在</td>
<td>不允许</td>
<td>是</td>
<td>非必须</td>
<td>允许</td>
</tr>
<tr>
<td>const</td>
<td>不会</td>
<td>存在</td>
<td>不允许</td>
<td>是</td>
<td>非必须</td>
<td>不允许</td>
</tr>
</tbody></table>
<p>1.let&#x2F;const 定义的变量不会出现变量提升，而 var 定义的变量会提升。</p>
<p>2.相同作用域中，let 和 const 不允许重复声明，var 允许重复声明。</p>
<p>3.const 声明变量时必须设置初始值</p>
<p>4.const 声明一个只读的常量，这个常量不可改变。</p>
<p>这里有一个非常重要的点即是：在JS中，复杂数据类型，存储在栈中的是堆内存的地址，存在栈中的这个地址是不变的，但是存在堆中的值是可以变得。有没有相当常量指针&#x2F;指针常量~</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">star</span>: <span class="number">500</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-prototype-和-proto-区别是什么？"><a href="#12-prototype-和-proto-区别是什么？" class="headerlink" title="12. prototype 和 proto 区别是什么？"></a>12. prototype 和 <strong>proto</strong> 区别是什么？</h2><p>prototype是构造函数的属性。</p>
<p><strong>proto</strong> 是每个实例都有的属性，可以访问 [[prototype]] 属性。</p>
<p>实例的__proto__ 与其构造函数的prototype指向的是同一个对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setAge</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span>=<span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Jack</span> = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;jack&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Jack</span>.<span class="property">__proto__</span>);</span><br><span class="line"><span class="comment">//console.log(Object.getPrototypeOf(Jack));;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Jack</span>.<span class="property">__proto__</span> === <span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h2 id="13-防抖函数的作用是什么？请实现一个防抖函数"><a href="#13-防抖函数的作用是什么？请实现一个防抖函数" class="headerlink" title="13. 防抖函数的作用是什么？请实现一个防抖函数"></a>13. 防抖函数的作用是什么？请实现一个防抖函数</h2><blockquote>
<p>防抖函数的作用</p>
</blockquote>
<p>防抖函数的作用就是控制函数在一定时间内的执行次数。防抖意味着N秒内函数只会被执行一次，如果N秒内再次被触发，则重新计算延迟时间。</p>
<p>举例说明： 小思最近在减肥，但是她非常吃吃零食。为此，与其男朋友约定好，如果10天不吃零食，就可以购买一个包(不要问为什么是包，因为包治百病)。但是如果中间吃了一次零食，那么就要重新计算时间，直到小思坚持10天没有吃零食，才能购买一个包。所以，管不住嘴的小思，没有机会买包(悲伤的故事)… 这就是 防抖。</p>
<blockquote>
<p>防抖函数实现</p>
</blockquote>
<ul>
<li>事件第一次触发时，timer 是 null，调用 later()，若 immediate 为true，那么立即调用 func.apply(this, params)；如果 immediate 为 false，那么过 wait 之后，调用 func.apply(this, params)</li>
<li>事件第二次触发时，如果 timer 已经重置为 null(即 setTimeout 的倒计时结束)，那么流程与第一次触发时一样，若 timer 不为 null(即 setTimeout 的倒计时未结束)，那么清空定时器，重新开始计时。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait, immediate = <span class="literal">true</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timeout, result;</span><br><span class="line">    <span class="comment">// 延迟执行函数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">later</span> = (<span class="params">context, args</span>) =&gt; <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        timeout = <span class="literal">null</span>;<span class="comment">// 倒计时结束</span></span><br><span class="line">        <span class="keyword">if</span> (!immediate) &#123;</span><br><span class="line">            <span class="comment">//执行回调</span></span><br><span class="line">            result = func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">            context = args = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, wait);</span><br><span class="line">    <span class="keyword">let</span> debounced = <span class="keyword">function</span> (<span class="params">...params</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">            timeout = <span class="title function_">later</span>(<span class="variable language_">this</span>, params);</span><br><span class="line">            <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">                <span class="comment">//立即执行</span></span><br><span class="line">                result = func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, params);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">            <span class="comment">//函数在每个等待时延的结束被调用</span></span><br><span class="line">            timeout = <span class="title function_">later</span>(<span class="variable language_">this</span>, params);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供在外部清空定时器的方法</span></span><br><span class="line">    debounced.<span class="property">cancel</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> debounced;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>immediate 为 true 时，表示函数在每个等待时延的开始被调用。immediate 为 false 时，表示函数在每个等待时延的结束被调用。</p>
<blockquote>
<p>防抖的应用场景</p>
</blockquote>
<ul>
<li>搜索框输入查询，如果用户一直在输入中，没有必要不停地调用去请求服务端接口，等用户停止输入的时候，再调用，设置一个合适的时间间隔，有效减轻服务端压力。</li>
<li>表单验证</li>
<li>按钮提交事件。</li>
<li>浏览器窗口缩放，resize事件(如窗口停止改变大小之后重新计算布局)等。</li>
</ul>
<h2 id="14-节流函数的作用是什么？有哪些应用场景，请实现一个节流函数"><a href="#14-节流函数的作用是什么？有哪些应用场景，请实现一个节流函数" class="headerlink" title="14. 节流函数的作用是什么？有哪些应用场景，请实现一个节流函数"></a>14. 节流函数的作用是什么？有哪些应用场景，请实现一个节流函数</h2><blockquote>
<p>节流函数的作用</p>
</blockquote>
<p>节流函数的作用是规定一个单位时间，在这个单位时间内最多只能触发一次函数执行，如果这个单位时间内多次触发函数，只能有一次生效。</p>
<blockquote>
<p>节流函数实现</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, wait, options = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> timeout, context, args, result;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> later = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        previous = options.<span class="property">leading</span> === <span class="literal">false</span> ? <span class="number">0</span> : (<span class="title class_">Date</span>.<span class="title function_">now</span>() || <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>());</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        result = func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">        <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> throttled = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>() || <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">        <span class="keyword">if</span> (!previous &amp;&amp; options.<span class="property">leading</span> === <span class="literal">false</span>) previous = now;</span><br><span class="line">        <span class="comment">//remaining 为距离下次执行 func 的时间</span></span><br><span class="line">        <span class="comment">//remaining &gt; wait，表示客户端系统时间被调整过</span></span><br><span class="line">        <span class="keyword">var</span> remaining = wait - (now - previous);</span><br><span class="line">        context = <span class="variable language_">this</span>;</span><br><span class="line">        args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="comment">//remaining 小于等于0，表示事件触发的间隔时间大于设置的 wait</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">                <span class="comment">//清空定时器</span></span><br><span class="line">                <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//重置 previous</span></span><br><span class="line">            previous = now;</span><br><span class="line">            <span class="comment">//执行函数</span></span><br><span class="line">            result = func.<span class="title function_">apply</span>(context, args); </span><br><span class="line">            <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.<span class="property">trailing</span> !== <span class="literal">false</span>) &#123;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(later, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    throttled.<span class="property">cancel</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        previous = <span class="number">0</span>;</span><br><span class="line">        timeout = context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> throttled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>禁用第一次首先执行，传递 {leading: false} ；想禁用最后一次执行，传递 {trailing: false}</p>
<blockquote>
<p>节流的应用场景</p>
</blockquote>
<ul>
<li>按钮点击事件</li>
<li>拖拽事件</li>
<li>onScoll</li>
<li>计算鼠标移动的距离(mousemove)</li>
</ul>
<h2 id="15-什么是闭包？闭包的作用是什么？"><a href="#15-什么是闭包？闭包的作用是什么？" class="headerlink" title="15. 什么是闭包？闭包的作用是什么？"></a>15. 什么是闭包？闭包的作用是什么？</h2><p><strong>闭包的定义</strong></p>
<p>《JavaScript高级程序设计》:</p>
<blockquote>
<p>闭包是指有权访问另一个函数作用域中的变量的函数</p>
</blockquote>
<p>《JavaScript权威指南》：</p>
<blockquote>
<p>从技术的角度讲，所有的JavaScript函数都是闭包：它们都是对象，它们都关联到作用域链。</p>
</blockquote>
<p>《你不知道的JavaScript》</p>
<blockquote>
<p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。</p>
</blockquote>
<p><strong>创建一个闭包</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> func = <span class="title function_">foo</span>();</span><br><span class="line"><span class="title function_">func</span>(); <span class="comment">//输出2</span></span><br></pre></td></tr></table></figure>
<p>闭包使得函数可以继续访问定义时的词法作用域。拜 fn 所赐，在 foo() 执行后，foo 内部作用域不会被销毁。</p>
<p><strong>闭包的作用</strong></p>
<ul>
<li><p>能够访问函数定义时所在的词法作用域(阻止其被回收)。</p>
</li>
<li><p>私有化变量</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">base</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">10</span>; <span class="comment">//私有变量</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">getX</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="title function_">base</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">getX</span>()); <span class="comment">//10</span></span><br></pre></td></tr></table></figure>
<ul>
<li>模拟块级作用域</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    a[i] = (<span class="keyword">function</span>(<span class="params">j</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<ul>
<li>创建模块</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">coolModule</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">&#x27;Yvette&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> age = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">sayAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        sayName,</span><br><span class="line">        sayAge</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> info = <span class="title function_">coolModule</span>();</span><br><span class="line">info.<span class="title function_">sayName</span>(); <span class="comment">//&#x27;Yvette&#x27;</span></span><br></pre></td></tr></table></figure>

<p>模块模式具有两个必备的条件(来自《你不知道的JavaScript》)</p>
<ul>
<li>必须有外部的封闭函数，该函数必须至少被调用一次(每次调用都会创建一个新的模块实例)</li>
<li>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</li>
</ul>
<h2 id="16-实现-Promise-all-方法"><a href="#16-实现-Promise-all-方法" class="headerlink" title="16. 实现 Promise.all 方法"></a>16. 实现 Promise.all 方法</h2><p>在实现 Promise.all 方法之前，我们首先要知道 Promise.all 的功能和特点，因为在清楚了 Promise.all 功能和特点的情况下，我们才能进一步去写实现。</p>
<blockquote>
<p>Promise.all 功能</p>
</blockquote>
<p>Promise.all(iterable) 返回一个新的 Promise 实例。此实例在 iterable 参数内所有的 promise 都 fulfilled 或者参数中不包含 promise 时，状态变成 fulfilled；如果参数中 promise 有一个失败rejected，此实例回调失败，失败原因的是第一个失败 promise 的返回结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure>
<p>p的状态由 p1,p2,p3决定，分成以下；两种情况：</p>
<p>（1）只有p1、p2、p3的状态都变成 fulfilled，p的状态才会变成 fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</p>
<p>（2）只要p1、p2、p3之中有一个被 rejected，p的状态就变成 rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</p>
<blockquote>
<p>Promise.all 的特点</p>
</blockquote>
<p>Promise.all 的返回值是一个 promise 实例</p>
<ul>
<li>如果传入的参数为空的可迭代对象，Promise.all 会 同步 返回一个已完成状态的 promise</li>
<li>如果传入的参数中不包含任何 promise,Promise.all 会 异步 返回一个已完成状态的 promise</li>
<li>其它情况下，Promise.all 返回一个 处理中（pending） 状态的 promise.</li>
</ul>
<blockquote>
<p>Promise.all 返回的 promise 的状态</p>
</blockquote>
<ul>
<li>如果传入的参数中的 promise 都变成完成状态，Promise.all 返回的 promise 异步地变为完成。</li>
<li>如果传入的参数中，有一个 promise 失败，Promise.all 异步地将失败的那个结果给失败状态的回调函数，而不管其它 promise 是否完成</li>
<li>在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个数组<blockquote>
<p>Promise.all 实现</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">all</span> = <span class="keyword">function</span> (<span class="params">promises</span>) &#123;</span><br><span class="line">    <span class="comment">//promises 是可迭代对象，省略参数合法性检查</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//Array.from 将可迭代对象转换成数组</span></span><br><span class="line">        promises = <span class="title class_">Array</span>.<span class="title function_">from</span>(promises);</span><br><span class="line">        <span class="keyword">if</span> (promises.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="title function_">resolve</span>([]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> result = [];</span><br><span class="line">            <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;  i &lt; promises.<span class="property">length</span>; i++ ) &#123;</span><br><span class="line">                <span class="comment">//考虑到 i 可能是 thenable 对象也可能是普通值</span></span><br><span class="line">                <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(promises[i]).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">                    result[i] = data;</span><br><span class="line">                    <span class="keyword">if</span> (++index === promises.<span class="property">length</span>) &#123;</span><br><span class="line">                        <span class="comment">//所有的 promises 状态都是 fulfilled，promise.all返回的实例才变成 fulfilled 态</span></span><br><span class="line">                        <span class="title function_">resolve</span>(result);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="title function_">reject</span>(err);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="17-请实现一个-flattenDeep-函数，把嵌套的数组扁平化"><a href="#17-请实现一个-flattenDeep-函数，把嵌套的数组扁平化" class="headerlink" title="17. 请实现一个 flattenDeep 函数，把嵌套的数组扁平化"></a>17. 请实现一个 flattenDeep 函数，把嵌套的数组扁平化</h2><p>例如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">flattenDeep</span>([<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>]], <span class="number">5</span>]]); <span class="comment">//[1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>利用 Array.prototype.flat</p>
</blockquote>
<p>ES6 为数组实例新增了 flat 方法，用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数组没有影响。</p>
<p>flat 默认只会 “拉平” 一层，如果想要 “拉平” 多层的嵌套数组，需要给 flat 传递一个整数，表示想要拉平的层数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flattenDeep</span>(<span class="params">arr, deepLength</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">flat</span>(deepLength);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flattenDeep</span>([<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>]], <span class="number">5</span>]], <span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<p>当传递的整数大于数组嵌套的层数时，会将数组拉平为一维数组，JS能表示的最大数字为 Math.pow(2, 53) - 1，因此我们可以这样定义 flattenDeep 函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flattenDeep</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="comment">//当然，大多时候我们并不会有这么多层级的嵌套</span></span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">flat</span>(<span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>,<span class="number">53</span>) - <span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flattenDeep</span>([<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>]], <span class="number">5</span>]]));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>利用 reduce 和 concat</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flattenDeep</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, val</span>) =&gt;</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(val) ? acc.<span class="title function_">concat</span>(<span class="title function_">flattenDeep</span>(val)) : acc.<span class="title function_">concat</span>(val), []);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flattenDeep</span>([<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>]], <span class="number">5</span>]]));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用 stack 无限反嵌套多层嵌套数组</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flattenDeep</span>(<span class="params">input</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> stack = [...input];</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">while</span> (stack.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用 pop 从 stack 中取出并移除值</span></span><br><span class="line">        <span class="keyword">const</span> next = stack.<span class="title function_">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(next)) &#123;</span><br><span class="line">            <span class="comment">// 使用 push 送回内层数组中的元素，不会改动原始输入 original input</span></span><br><span class="line">            stack.<span class="title function_">push</span>(...next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用 reverse 恢复原数组的顺序</span></span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">reverse</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flattenDeep</span>([<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>]], <span class="number">5</span>]]));</span><br></pre></td></tr></table></figure>

<h2 id="18-请实现一个-uniq-函数，实现数组去重"><a href="#18-请实现一个-uniq-函数，实现数组去重" class="headerlink" title="18. 请实现一个 uniq 函数，实现数组去重"></a>18. 请实现一个 uniq 函数，实现数组去重</h2><p>例如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">uniq</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>]);<span class="comment">//[1, 2, 3, 5]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>1: 利用ES6新增数据类型 Set</p>
</blockquote>
<p>Set类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">uniq</span>(<span class="params">arry</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [...<span class="keyword">new</span> <span class="title class_">Set</span>(arry)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2: 利用 indexOf</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">uniq</span>(<span class="params">arry</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arry.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.<span class="title function_">indexOf</span>(arry[i]) === -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//如 result 中没有 arry[i],则添加到数组中</span></span><br><span class="line">            result.<span class="title function_">push</span>(arry[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>3: 利用 includes</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">uniq</span>(<span class="params">arry</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arry.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!result.<span class="title function_">includes</span>(arry[i])) &#123;</span><br><span class="line">            <span class="comment">//如 result 中没有 arry[i],则添加到数组中</span></span><br><span class="line">            result.<span class="title function_">push</span>(arry[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>4：利用 reduce</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">uniq</span>(<span class="params">arry</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arry.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> prev.<span class="title function_">includes</span>(cur) ? prev : [...prev, cur], []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>5.利用 Map</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">uniq</span>(<span class="params">arry</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arry.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.<span class="title function_">has</span>(arry[i])) &#123;</span><br><span class="line">            map.<span class="title function_">set</span>(arry[i], <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.<span class="title function_">set</span>(arry[i], <span class="literal">false</span>);</span><br><span class="line">            result.<span class="title function_">push</span>(arry[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-在JS中什么是变量提升？什么是暂时性死区？"><a href="#19-在JS中什么是变量提升？什么是暂时性死区？" class="headerlink" title="19. 在JS中什么是变量提升？什么是暂时性死区？"></a>19. 在JS中什么是变量提升？什么是暂时性死区？</h2><p>变量提升就是变量在声明之前就可以使用，值为undefined。</p>
<p>在代码块内，使用 let&#x2F;const 命令声明变量之前，该变量都是不可用的(会抛出错误)。这在语法上，称为“暂时性死区”。暂时性死区也意味着 typeof 不再是一个百分百安全的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typeof x; // ReferenceError(暂时性死区，抛错)</span><br><span class="line">let x;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typeof y; // 值是undefined,不会报错</span><br></pre></td></tr></table></figure>
<p>暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p>
<h2 id="20-JSONP-的原理是什么？"><a href="#20-JSONP-的原理是什么？" class="headerlink" title="20. JSONP 的原理是什么？"></a>20. JSONP 的原理是什么？</h2><p>尽管浏览器有同源策略，但是 &lt;script&gt; 标签的 src 属性不会被同源策略所约束，可以获取任意服务器上的脚本并执行。jsonp 通过插入 script 标签的方式来实现跨域，参数只能通过 url 传入，仅能支持 get 请求。</p>
<blockquote>
<p>实现原理:</p>
</blockquote>
<ul>
<li>Step1: 创建 callback 方法</li>
<li>Step2: 插入 script 标签</li>
<li>Step3: 后台接受到请求，解析前端传过去的 callback 方法，返回该方法的调用，并且数据作为参数传入该方法</li>
<li>Step4: 前端执行服务端返回的方法调用</li>
</ul>
<blockquote>
<p>jsonp源码实现</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonp</span>(<span class="params">&#123;url, params, callback&#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//创建script标签</span></span><br><span class="line">        <span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">        <span class="comment">//将回调函数挂在 window 上</span></span><br><span class="line">        <span class="variable language_">window</span>[callback] = <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(data);</span><br><span class="line">            <span class="comment">//代码执行后，删除插入的script标签</span></span><br><span class="line">            <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(script);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//回调函数加在请求地址上</span></span><br><span class="line">        params = &#123;...params, callback&#125; <span class="comment">//wb=b&amp;callback=show</span></span><br><span class="line">        <span class="keyword">let</span> arrs = [];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">            arrs.<span class="title function_">push</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        script.<span class="property">src</span> = <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;arrs.join(<span class="string">&#x27;&amp;&#x27;</span>)&#125;</span>`</span>;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">show</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">jsonp</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/show&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">        <span class="comment">//code</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">callback</span>: <span class="string">&#x27;show&#x27;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>服务端代码(node):</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//express启动一个后台服务</span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/show&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;callback&#125; = req.<span class="property">query</span>; <span class="comment">//获取传来的callback函数名，callback是key</span></span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">`<span class="subst">$&#123;callback&#125;</span>(&#x27;Hello!&#x27;)`</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>60个JS实用的代码小技巧</title>
    <url>/post/c127f8d6d358/</url>
    <content><![CDATA[<p>JavaScript 有很多很酷的特性，大多数初学者和中级开发人员都不知道。今天分享一些，我经常在项目中使用一些技巧。</p>
<h2 id="1-JS-为什么单线程"><a href="#1-JS-为什么单线程" class="headerlink" title="1. JS 为什么单线程"></a>1. JS 为什么单线程</h2><p>一个简单的原因就是，<code>js</code>在设计之初只是进行一些简单的表单校验，这完全不需要多线程，单线程完全可以胜任这项工作。即便后来前端发展迅速，承载的能力越来越多，也没有发展到非多线程不可的程度。</p>
<p>而且还有一个主要的原因，设想一下，如果<code>js</code>是多线程的，在运行时多个线程同时对<code>DOM</code>元素进行操作，那具体以哪个线程为主就是个问题了，线程的调度问题是一个比较复杂的问题。</p>
<p><code>HTML5</code>新的标准中允许使用<code>new Worker</code>的方式来开启一个新的线程，去运行一段单独的<code>js</code>文件脚本，但是在这个新线程中严格的要求了可以使用的功能，比如说他只能使用<code>ECMAScript</code>, 不能访问<code>DOM</code>和<code>BOM</code>。这也就限制死了多个线程同时操作<code>DOM</code>元素的可能。</p>
<h2 id="2-使用-css-写出一个三角形角标"><a href="#2-使用-css-写出一个三角形角标" class="headerlink" title="2.使用 css 写出一个三角形角标"></a>2.使用 css 写出一个三角形角标</h2><p>元素宽高设置为<code>0</code>，通过<code>border</code>属性来设置，让其它三个方向的<code>border</code>颜色为透明或者和背景色保持一致，剩余一条<code>border</code>的颜色设置为需要的颜色。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attr">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attr">border</span>: 5px solid #transparent;</span><br><span class="line">    border-top-<span class="attr">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-水平垂直居中"><a href="#3-水平垂直居中" class="headerlink" title="3.水平垂直居中"></a>3.水平垂直居中</h2><p>我一般只使用两种方式<code>定位</code>或者<code>flex</code>，我觉得够用了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">    <span class="attr">width</span>: 100px;</span><br><span class="line">    <span class="attr">height</span>: 100px;</span><br><span class="line">    <span class="attr">position</span>: absolute;</span><br><span class="line">    <span class="attr">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attr">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attr">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attr">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attr">margin</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>父级控制子集居中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.<span class="property">parent</span> &#123;</span><br><span class="line">    <span class="attr">display</span>: flex;</span><br><span class="line">    justify-<span class="attr">content</span>: center;</span><br><span class="line">    align-<span class="attr">items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-css-一行文本超出…"><a href="#4-css-一行文本超出…" class="headerlink" title="4. css 一行文本超出…"></a>4. css 一行文本超出…</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">overflow</span>: hidden;</span><br><span class="line">text-<span class="attr">overflow</span>:ellipsis;</span><br><span class="line">white-<span class="attr">space</span>: nowrap;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5-多行文本超出显示…"><a href="#5-多行文本超出显示…" class="headerlink" title="5.多行文本超出显示…"></a>5.多行文本超出显示…</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">display</span>: -webkit-box;</span><br><span class="line">-webkit-box-<span class="attr">orient</span>: vertical;</span><br><span class="line">-webkit-line-<span class="attr">clamp</span>: <span class="number">3</span>;</span><br><span class="line"><span class="attr">overflow</span>: hidden;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-IOS-手机容器滚动条滑动不流畅"><a href="#6-IOS-手机容器滚动条滑动不流畅" class="headerlink" title="6.IOS 手机容器滚动条滑动不流畅"></a>6.IOS 手机容器滚动条滑动不流畅</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">overflow</span>: auto;</span><br><span class="line">-webkit-overflow-<span class="attr">scrolling</span>: touch;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7-修改滚动条样式"><a href="#7-修改滚动条样式" class="headerlink" title="7.修改滚动条样式"></a>7.修改滚动条样式</h2><p>隐藏<code>div</code>元素的滚动条</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">div</span>::-webkit-scrollbar &#123;</span><br><span class="line">    <span class="attr">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>div::-webkit-scrollbar 滚动条整体部分</p>
<p>div::-webkit-scrollbar-thumb 滚动条里面的小方块，能向上向下移动（或往左往右移动，取决于是垂直滚动条还是水平滚动条）</p>
<p>div::-webkit-scrollbar-track 滚动条的轨道</p>
<p>div::-webkit-scrollbar-button 滚动条的轨道的两端按钮，允许通过点击微调小方块的位置。</p>
<p>div::-webkit-scrollbar-track-piece 内层轨道，滚动条中间部分</p>
<p>div::-webkit-scrollbar-corner 边角，即两个滚动条的交汇处</p>
<p>div::-webkit-resizer 两个滚动条的交汇处上用于通过拖动调整元素大小的小控件</p>
<p>注意此方案有兼容性问题，一般需要隐藏滚动条时我都是用一个色块通过定位盖上去，或者将子级元素调大，父级元素使用 overflow-hidden 截掉滚动条部分。暴力且直接。</p>
<h2 id="8-解决-ios-audio-无法自动播放、循环播放的问题"><a href="#8-解决-ios-audio-无法自动播放、循环播放的问题" class="headerlink" title="8.解决 ios audio 无法自动播放、循环播放的问题"></a>8.解决 ios audio 无法自动播放、循环播放的问题</h2><p><code>ios</code>手机在使用<code>audio</code>或者<code>video</code>播放的时候，个别机型无法实现自动播放，可使用下面的代码<code>hack</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解决ios audio无法自动播放、循环播放的问题</span></span><br><span class="line"><span class="keyword">var</span> music = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;video&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&quot;touchstart&quot;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (state == <span class="number">0</span>) &#123;</span><br><span class="line">      music.<span class="title function_">play</span>();</span><br><span class="line">      state = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&quot;WeixinJSBridgeReady&quot;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    music.<span class="title function_">play</span>();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环播放</span></span><br><span class="line">music.<span class="property">onended</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  music.<span class="title function_">load</span>();</span><br><span class="line">  music.<span class="title function_">play</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="9-隐藏页面元素"><a href="#9-隐藏页面元素" class="headerlink" title="9.隐藏页面元素"></a>9.隐藏页面元素</h2><p>display-none: 元素不会占用空间，在页面中不显示，子元素也不会显示。</p>
<p>opacity-0: 元素透明度将为<code>0</code>，但元素仍然存在，绑定的事件仍旧有效仍可触发执行。</p>
<p>visibility-hidden：元素隐藏，但元素仍旧存在，占用空间，页面中无法触发该元素的事件。</p>
<h2 id="10-前端工程化"><a href="#10-前端工程化" class="headerlink" title="10.前端工程化"></a>10.前端工程化</h2><p>一提到前端工程化很多人想到的都是<code>webpack</code>，这是不对的，<code>webpack</code>仅仅是前端工程化中的一环。在整个工程化过程中他帮我们解决了绝大多数的问题，但并没有解决所有问题。</p>
<p>前端工程化是通过工具提升效率，降低成本的一种手段。</p>
<p>近些年被广泛的关注和探讨，究其原因主要是因为现代化前端应用功能要求不断提高，业务逻辑日益复杂，作为当下互联网时代唯一不可或缺的技术，前端可以说是占据了整个开发行业的半壁江山。从传统的网站，到现在的<code>H5</code>,移动<code>App</code>,桌面应用，以及小程序。前端技术几乎是无所不能的全面覆盖。</p>
<p>在这些表象的背后呢，实际上是行业对开发人员的要求发生了天翻地覆的变化，以往前端写 demo，套模板，调页面这种刀耕火种的方式已经完全不符合当下对开发效率的要求，前端工程化就是在这样一个背景下被提上台面，成为前端工程师必备的手段之一。</p>
<p>一般来说前端工程包含，项目初始化，项目开发，提交，构建，部署，测试，监控等流程。工程化就是以工程的角度来解决这些问题。比如项目初始化我们一般使用<code>npm init</code>, 创建页面模板使用<code>plop</code>，我们喜欢使用<code>ES6+</code>开发，但是需要通过<code>babel</code>编码成<code>ES5</code>，持续集成的时候我们使用<code>git/ci cd</code>，但是为了保持开发规范我们引入了<code>ESLint</code>，部署一般使用<code>git/cd</code>或者<code>jenkins</code>等等。</p>
<h2 id="11-contenteditable"><a href="#11-contenteditable" class="headerlink" title="11.contenteditable"></a>11.contenteditable</h2><p><code>html</code>中大部分标签都是不可以编辑的，但是添加了<code>contenteditable</code>属性之后，标签会变成可编辑状态。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div contenteditable=<span class="string">&quot;true&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>不过通过这个属性把标签变为可编辑状态后只有<code>input</code>事件，没有<code>change</code>事件。也不能像表单一样通过<code>maxlength</code>控制最大长度。我也忘记我在什么情况下用到过了，后面想起来再补吧。</p>
<h2 id="12-calc"><a href="#12-calc" class="headerlink" title="12.calc"></a>12.calc</h2><p>这是一个<code>css</code>属性，我一般称之为<code>css</code>表达式。可以计算<code>css</code>的值。最有趣的是他可以计算不同单位的差值。很好用的一个功能，缺点是不容易阅读。接盘侠没办法一眼看出<code>20px</code>是啥。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="title function_">calc</span>(<span class="number">25</span>% - 20px);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="13-Date-对象"><a href="#13-Date-对象" class="headerlink" title="13.Date 对象"></a>13.Date 对象</h2><p>获取当前时间毫秒值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一</span></span><br><span class="line"><span class="title class_">Date</span>.<span class="title function_">now</span>(); <span class="comment">// 1606381881650</span></span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>() - <span class="number">0</span>; <span class="comment">// 1606381881650</span></span><br><span class="line"><span class="comment">// 方式三</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>(); <span class="comment">// 1606381881650</span></span><br></pre></td></tr></table></figure>

<p>创建<code>Date</code>对象的兼容性问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// window和安卓支持，ios和mac不支持</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2020-11-26&quot;</span>);</span><br><span class="line"><span class="comment">// window和安卓支持，ios和mac支持</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2020/11/26&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="14-Proxy-和-Object-defineProperty-区别"><a href="#14-Proxy-和-Object-defineProperty-区别" class="headerlink" title="14.Proxy 和 Object.defineProperty 区别"></a>14.Proxy 和 Object.defineProperty 区别</h2><p><code>Proxy</code>的意思是代理，我一般叫他拦截器，可以拦截对象上的一个操作。用法如下，通过<code>new</code>的方式创建对象，第一个参数是被拦截的对象，第二个参数是对象操作的描述。实例化后返回一个新的对象，当我们对这个新的对象进行操作时就会调用我们描述中对应的方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, property</span>) &#123;&#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, property</span>) &#123;&#125;,</span><br><span class="line">  <span class="title function_">deleteProperty</span>(<span class="params">target, property</span>) &#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>Proxy</code>区别于<code>Object.definedProperty</code>。</p>
<p><code>Object.defineProperty</code>只能监听到属性的读写，而<code>Proxy</code>除读写外还可以监听属性的删除，方法的调用等。</p>
<p>通常情况下我们想要监视数组的变化，基本要依靠重写数组方法的方式实现，这也是<code>Vue</code>的实现方式，而<code>Proxy</code>可以直接监视数组的变化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> listproxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(list, &#123;</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, property, value</span>) &#123;</span><br><span class="line">    target[property] = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 标识设置成功</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">list.<span class="title function_">push</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p><code>Proxy</code>是以非入侵的方式监管了对象的读写，而<code>defineProperty</code>需要按特定的方式定义对象的属性。</p>
<h2 id="15-Reflect"><a href="#15-Reflect" class="headerlink" title="15.Reflect"></a>15.Reflect</h2><p>他是<code>ES2015</code>新增的对象，纯静态对象也就是不能被实例画，只能通过静态方法的方式调用，和<code>Math</code>对象类似，只能类似<code>Math.random()</code>的方式调用。</p>
<p><code>Reflect</code>内部封装了一系列对对象的底层操作，一共<code>14</code>个，其中<code>1</code>个被废弃，还剩下<code>13</code>个。</p>
<p><code>Reflect</code>的静态方法和<code>Proxy</code>描述中的方法完全一致。也就是说<code>Reflect</code>成员方法就是<code>Proxy</code>处理对象的默认实现。</p>
<p><code>Proxy</code>对象默认的方法就是调用了<code>Reflect</code>内部的处理逻辑，也就是如果我们调用<code>get</code>方法，那么在内部，<code>Reflect</code>就是将<code>get</code>原封不动的交给了<code>Reflect</code>，如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, property);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>Reflect</code>和<code>Proxy</code>没有绝对的关系，我们一般将他们两个放在一起讲是为了方便对二者的理解。</p>
<p>那为什么会有<code>Reflect</code>对象呢，其实他最大的用处就是提供了一套统一操作<code>Object</code>的<code>API</code>。</p>
<p>判断对象是否存在某一个属性，可以使用<code>in</code>操作符，但是不够优雅，还可以使用<code>Reflect.has(obj, name)</code>; 删除一个属性可以使用<code>delete</code>，也可以使用<code>Reflect.deleteProperty(obj, name)</code>; 获取所有属性名可以使用<code>Object.keys</code>, 也可以使用<code>Reflect.ownKeys(obj)</code>; 我们更推荐使用<code>Reflect</code>的<code>API</code>来操作对象，因为他才是未来。</p>
<h2 id="16-解析-get-参数"><a href="#16-解析-get-参数" class="headerlink" title="16.解析 get 参数"></a>16.解析 get 参数</h2><p>通过<code>replace</code>方法获取<code>url</code>中的参数键值对，可以快速解析<code>get</code>参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> q = &#123;&#125;;</span><br><span class="line">location.<span class="property">search</span>.<span class="title function_">replace</span>(<span class="regexp">/([^?&amp;=]+)=([^&amp;]+)/g</span>, <span class="function">(<span class="params">_, k, v</span>) =&gt;</span> (q[k] = v));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(q);</span><br></pre></td></tr></table></figure>

<h2 id="17-解析连接-url"><a href="#17-解析连接-url" class="headerlink" title="17.解析连接 url"></a>17.解析连接 url</h2><p>可以通过创建<code>a</code>标签，给<code>a</code>标签赋值<code>href</code>属性的方式，获取<code>到协议</code>，<code>pathname</code>，<code>origin</code>等<code>location</code>对象上的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建a标签</span></span><br><span class="line"><span class="keyword">const</span> aEle = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="comment">// 给a标签赋值href路径</span></span><br><span class="line">aEle.<span class="property">href</span> = <span class="string">&#x27;/test.html&#x27;</span>;</span><br><span class="line"><span class="comment">// 访问aEle中的属性</span></span><br><span class="line">aEle.<span class="property">protocol</span>; <span class="comment">// 获取协议</span></span><br><span class="line">aEle.<span class="property">pathname</span>; <span class="comment">// 获取path</span></span><br><span class="line">aEle.<span class="property">origin</span>;</span><br><span class="line">aEle.<span class="property">host</span>;</span><br><span class="line">aEle.<span class="property">search</span>;</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="18-localStorage"><a href="#18-localStorage" class="headerlink" title="18.localStorage"></a>18.localStorage</h2><p><code>localStorage</code>是<code>H5</code>提供的永久存储空间，一般最大可存储<code>5M</code>数据，并且支持跨域隔离，他的出现极大提高了前端开发的可能性。<code>localStorage</code>的使用很多人都知道<code>setItem</code>，<code>getItem</code>,<code>removeItem</code>, 但他也可以直接以成员的方式操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="property">name</span> = <span class="string">&quot;yd&quot;</span>;</span><br><span class="line"><span class="comment">// 获取</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="property">name</span>; <span class="comment">// yd</span></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="keyword">delete</span> <span class="variable language_">localStorage</span>.<span class="property">name</span>;</span><br><span class="line"><span class="comment">// 清除全部</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">localStorage</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> key = <span class="variable language_">localStorage</span>.<span class="title function_">key</span>(i); <span class="comment">// 获取本地存储的Key</span></span><br><span class="line">  <span class="variable language_">localStorage</span>[key]; <span class="comment">// 获取本地存储的value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>localStorage</code>满了的情况下仍继续存储并不会覆盖其他的值，而是直接报错(<code>QuotaExceededError</code>)，并且当前存储的值也会被清空。浏览器支持每个域名下存储<code>5M</code>数据。</p>
<h2 id="19-sessionStorage"><a href="#19-sessionStorage" class="headerlink" title="19.sessionStorage"></a>19.sessionStorage</h2><p><code>sessionStorage</code>和<code>localStorage</code>的区别是，存在当前会话，很多人理解的是浏览器关闭，这是不对的，假设你在<code>A</code>页面存储了<code>sessionStorage</code>，新开选项卡将<code>A</code>页面的链接粘贴进去打开页面，<code>sessionStorage</code>也是不存在的。</p>
<p>所以<code>sessionStorage</code>存在的条件是页面间的跳转，<code>A</code>页面存储了<code>sessionStorage</code>，他要通过<code>超链接</code>或者<code>location.href</code>或者<code>window.open</code>来打开另一个同域页面才能访问<code>sessionStorage</code>。</p>
<p>这一点在混合开发嵌套<code>H5</code>的开发模式中尤为重要，如果以新开<code>webview</code>的方式打开页面，很可能<code>sessionStorage</code>就没有了。</p>
<h2 id="20-会话-cookie"><a href="#20-会话-cookie" class="headerlink" title="20.会话 cookie"></a>20.会话 cookie</h2><p><code>cookie</code>在设置的时候如果不设置过期时间，就表示是个会话<code>cookie</code>，以前我以为关闭浏览器会话<code>cookie</code>就消失了，然而…喜提<code>bug</code>一个。</p>
<p>在多数情况下<code>windows</code>系统或者安卓系统确实是这样的。但是在<code>macOS</code>系统或者<code>ios</code>系统中，关闭浏览器并不会清除掉会话<code>cookie</code>，结束浏览器进程才行。</p>
<h2 id="21-标签模板字符串"><a href="#21-标签模板字符串" class="headerlink" title="21.标签模板字符串"></a>21.标签模板字符串</h2><p>模板字符串支持在前面添加一个函数，第一个参数是一个有固定内容组成的数组，后面参数依次为传入的变量，函数返回值为模板字符串真正展示的值。不过这个功能个人感觉没啥用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">tag</span> = (<span class="params">params, ...args</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> params[<span class="number">0</span>] + args[<span class="number">0</span>]; <span class="comment">// 返回值为模板字符串的真实值。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str = tag<span class="string">`hello <span class="subst">$&#123;<span class="string">&quot;world&quot;</span>&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>

<h2 id="22-字符串常用的几个方法"><a href="#22-字符串常用的几个方法" class="headerlink" title="22.字符串常用的几个方法"></a>22.字符串常用的几个方法</h2><h3 id="1-includes"><a href="#1-includes" class="headerlink" title="1. includes();"></a>1. includes();</h3><p>字符串中是否包含某个字符串，这个不说了，其实就是<code>indexOf</code>的替代方案，用起来更优雅，</p>
<h3 id="2-startsWith"><a href="#2-startsWith" class="headerlink" title="2. startsWith();"></a>2. startsWith();</h3><p>字符串是否为某个字符串开始，我一般用它判断<code>url</code>是否有<code>http</code></p>
<h3 id="3-endsWith"><a href="#3-endsWith" class="headerlink" title="3. endsWith();"></a>3. endsWith();</h3><p>字符串是否为某个字符串结尾。判断后缀名的时候尤其有效。</p>
<h3 id="4-repeat-number"><a href="#4-repeat-number" class="headerlink" title="4. repeat(number);"></a>4. repeat(number);</h3><p>得到一个重复<code>number</code>次的字符串。额…我也不知道什么时候有用，一般我用它造测试数据。</p>
<h3 id="5-‘abc’-padEnd-5-‘1’-abc11"><a href="#5-‘abc’-padEnd-5-‘1’-abc11" class="headerlink" title="5. ‘abc’.padEnd(5, ‘1’); &#x2F;&#x2F; abc11;"></a>5. ‘abc’.padEnd(5, ‘1’); &#x2F;&#x2F; abc11;</h3><p>用给定的字符串在尾部拼接到指定长度，第一个参数为长度，第二个参数为用于拼接的值。</p>
<h3 id="6-‘abc’-padStart-5-‘1’-11abc"><a href="#6-‘abc’-padStart-5-‘1’-11abc" class="headerlink" title="6. ‘abc’.padStart(5, ‘1’); &#x2F;&#x2F; 11abc;"></a>6. ‘abc’.padStart(5, ‘1’); &#x2F;&#x2F; 11abc;</h3><p>用给定的字符串在首部拼接到指定长度第一个参数为长度，第二个参数为用于拼接的值。首部补 0？</p>
<h2 id="23-数组快速去重"><a href="#23-数组快速去重" class="headerlink" title="23.数组快速去重"></a>23.数组快速去重</h2><p>应该很多人都知道这个，数组转换成<code>Set</code>, 再转换为数组，不过这种去重方式只能去除基本数据类型组成的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr2 = <span class="keyword">new</span> <span class="title class_">Set</span>(arr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr3 = [...arr2];</span><br></pre></td></tr></table></figure>

<h2 id="24-Object-keys-values-entries"><a href="#24-Object-keys-values-entries" class="headerlink" title="24.Object.keys, values, entries"></a>24.Object.keys, values, entries</h2><p>一般我们常用<code>Object.keys</code>，返回一个对象的键组成的数组，其实还有<code>Object.values</code>，返回对象值组成的数组，<code>Object.entries</code>将对象转成数组，每个元素是键值对组成的数组，可以使用此功能快速将对象转为<code>Map</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;yd&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj); <span class="comment">// [&#x27;name&#x27;, &#x27;age&#x27;];</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(obj); <span class="comment">// [&#x27;yd&#x27;, 18];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> l = <span class="title class_">Object</span>.<span class="title function_">entries</span>(obj); <span class="comment">// [[&#x27;name&#x27;, &#x27;yd&#x27;], [&#x27;age&#x27;: 18]];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>(l);</span><br></pre></td></tr></table></figure>

<h2 id="25-Object-getOwnPropertyDescriptors"><a href="#25-Object-getOwnPropertyDescriptors" class="headerlink" title="25.Object.getOwnPropertyDescriptors"></a>25.Object.getOwnPropertyDescriptors</h2><p>获取对象的描述信息</p>
<p><code>Object.assign</code>复制时，将对象的属性和方法当做普通属性来复制，并不会复制完整的描述信息，比如<code>this</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="string">&quot;y&quot;</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="string">&quot;d&quot;</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.a&#125;</span> <span class="subst">$&#123;<span class="variable language_">this</span>.b&#125;</span>`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, p1);</span><br><span class="line"></span><br><span class="line">p2.<span class="property">a</span> = <span class="string">&quot;z&quot;</span>;</span><br><span class="line"></span><br><span class="line">p2.<span class="property">name</span>; <span class="comment">// y d; 发现并没有修改p2.a的值，是因为this仍旧指向p1</span></span><br></pre></td></tr></table></figure>

<p>使用<code>Object.getOwnPropertyDescriptors</code>获取完整描述信息</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> description = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(p1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(&#123;&#125;, description);</span><br><span class="line"></span><br><span class="line">p2.<span class="property">a</span> = <span class="string">&quot;z&quot;</span>;</span><br><span class="line"></span><br><span class="line">p2.<span class="property">name</span>; <span class="comment">// z d</span></span><br></pre></td></tr></table></figure>

<h2 id="26-BigInt"><a href="#26-BigInt" class="headerlink" title="26.BigInt"></a>26.BigInt</h2><p><code>JavaScript</code>可以处理的最大数字是<code>2</code>的<code>53</code>次方 <code>- 1</code>，这一点我们可以在<code>Number.MAX_SAFE_INTEGER</code>中看到。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">consoel.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span>); <span class="comment">//9007199254740991</span></span><br></pre></td></tr></table></figure>

<p>更大的数字则无法处理，<code>ECMAScript2020</code>引入<code>BigInt</code>数据类型来解决这个问题。通过把字母<code>n</code>放在末尾, 可以运算大数据。</p>
<p><code>BigInt</code>可以使用算数运算符进行加、减、乘、除、余数及幂等运算。它可以由数字和十六进制或二进制字符串构造。此外它还支持<code>AND</code>、<code>OR</code>、<code>NOT</code>和<code>XOR</code>之类的按位运算。唯一无效的位运算是零填充右移运算符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bigNum = <span class="number">100000000000000000000000000000n</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bigNum * <span class="number">2n</span>); <span class="comment">// 200000000000000000000000000000n</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bigInt = <span class="title class_">BigInt</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bigInt); <span class="comment">// 1n;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bigInt2 = <span class="title class_">BigInt</span>(<span class="string">&quot;2222222222222222222&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bigInt2); <span class="comment">// 2222222222222222222n;</span></span><br></pre></td></tr></table></figure>

<p>BigInt 是一个大整数，所以他不能用来存储小数。</p>
<h2 id="27-合并空运算符"><a href="#27-合并空运算符" class="headerlink" title="27.??合并空运算符"></a>27.??合并空运算符</h2><p>假设变量<code>a</code>不存在，我们希望给系统一个默认值，一般我们会使用<code>||</code>运算符。但是在<code>javascript</code>中空字符串，<code>0</code>，<code>false</code>都会执行<code>||</code>运算符，所以<code>ECMAScript2020</code>引入合并空运算符解决该问题，只允许在值为<code>null</code>或未定义时使用默认值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name || <span class="string">&quot;yd&quot;</span>); <span class="comment">// yd;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name ?? <span class="string">&quot;yd&quot;</span>); <span class="comment">// &#x27;&#x27;;</span></span><br></pre></td></tr></table></figure>

<h2 id="28-可选链运算符"><a href="#28-可选链运算符" class="headerlink" title="28.?可选链运算符"></a>28.?可选链运算符</h2><p>业务代码中经常会遇到这样的情况，<code>a</code>对象有个属性<code>b</code>,<code>b</code>也是一个对象有个属性<code>c</code>,</p>
<p>我们需要访问<code>c</code>，经常会写成<code>a.b.c</code>，但是如果<code>f</code>不存在时，就会出错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  <span class="attr">b</span>: &#123;</span><br><span class="line">    <span class="attr">c</span>: <span class="number">123</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">b</span>.<span class="property">c</span>); <span class="comment">// 123;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">f</span>.<span class="property">c</span>); <span class="comment">// f不存在所以会报错</span></span><br></pre></td></tr></table></figure>

<p><code>ECMAScript2020</code>定义可选链运算符解决该问题，通过在<code>.</code>之前添加一个<code>?</code>将键名变成可选</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person?.<span class="property">profile</span>?.<span class="property">age</span> ?? <span class="number">18</span>); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>

<h2 id="29-import"><a href="#29-import" class="headerlink" title="29.import"></a>29.import</h2><p><code>import</code>是<code>ECMAScript2015</code>当中定义的一套<code>ES Module</code>模块系统，语法特性绝大多数浏览器已经支持了，通过给<code>script</code>标签添加<code>type=module</code>的属性就可以使用<code>ES Module</code>的标准去执行<code>javascript</code>代码了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is es module&#x27;</span>);&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在<code>ES Module</code>规范下，会采用严格模式(<code>use strict</code>)运行<code>javascript</code>代码。每个<code>ES Module</code>都运行在单独的作用域中，也就意味着变量间不会互相干扰。外部<code>js</code>文件是通过<code>CORS</code>的方式请求的，所以要求我们外部的<code>js</code>文件地址要支持跨域请求，也就是文件服务器要支持<code>CORS</code>。我们可以在任意网站控制台输入下面代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line"></span><br><span class="line">script.<span class="property">type</span> = <span class="string">&quot;module&quot;</span>;</span><br><span class="line"></span><br><span class="line">script.<span class="property">innerHTML</span> = <span class="string">`import React from &#x27;https://cdn.bootcdn.net/ajax/libs/react/17.0.1/cjs/react-jsx-dev-runtime.development.js&#x27;;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">append</span>(script);</span><br></pre></td></tr></table></figure>

<p>可以发现在<code>network</code>中请求了<code>https://cdn.bootcdn.net/ajax/libs/react/17.0.1/cjs/react-jsx-dev-runtime.development.js</code>资源。</p>
<p><code>ES Module</code>的<code>script</code>标签会延迟脚本加载，等待网页请求完资源之后才执行，和使用<code>deffer</code>的方式加载资源相同。</p>
<p>需要注意的是，<code>import &#123;&#125; from &#39;xx&#39;</code>导入模块的时候，并不是对象的解构，而是<code>import</code>的固定语法，这一点很多人容易弄错。</p>
<p>并且<code>ECMAScript2020</code>中<code>import</code>开始支持动态导入功能，在此之前<code>import</code>只能写在模块代码的顶部，一开始就要声明模块依赖的其它模块。支持动态引入后就可以按需引入对应的模块，这个功能我们早在<code>SPA</code>中就已经用到了。动态导入返回的是一个<code>Promise</code>。</p>
<p>a.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; a &#125;;</span><br></pre></td></tr></table></figure>

<p>b.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&quot;./a.js&quot;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="property">a</span>); <span class="comment">// 123;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="30-0-1-0-2-0-3-false"><a href="#30-0-1-0-2-0-3-false" class="headerlink" title="30. 0.1 + 0.2 &#x3D;&#x3D;&#x3D; 0.3 &#x2F;&#x2F; false"></a>30. 0.1 + 0.2 &#x3D;&#x3D;&#x3D; 0.3 &#x2F;&#x2F; false</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0.1</span> + <span class="number">0.2</span>); <span class="comment">// 0.30000000000000004</span></span><br></pre></td></tr></table></figure>

<p>在<code>JS</code>当中，<code>Number</code>类型实际上是<code>double</code>类型，运算小数时存在精度问题。因为计算机只认识二进制，在进行运算时，需要将其他进制的数值转换成二进制，然后再进行计算</p>
<p>小数用二进制表达时是无穷的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将0.1转换成二进制</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="number">0.1</span>).<span class="title function_">toString</span>(<span class="number">2</span>)); <span class="comment">// 0.0001100110011001100110011001100110011001100110011001101</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将0.2转换成二进制</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="number">0.2</span>).<span class="title function_">toString</span>(<span class="number">2</span>)); <span class="comment">// 0.001100110011001100110011001100110011001100110011001101</span></span><br></pre></td></tr></table></figure>

<p>双精度浮点数的小数部分最多支持<code>53</code>位二进制位，所以两者相加后，因浮点数小数位的限制而截断的二进制数字，再转换为十进制，就成了<code>0.30000000000000004</code>，这样在进行算术计算时会产生误差。</p>
<p><code>ES6 在Number</code>对象上面，新增一个极小的常量<code>Number.EPSILON</code>。根据规格，它表示<code>1</code>与大于<code>1</code>的最小浮点数之间的差。对于<code>64</code>位浮点数来说，大于<code>1</code>的最小浮点数相当于二进制的<code>1.00..001</code>，小数点后面有连续<code>51</code>个零。这个值减去<code>1</code>之后，就等于<code>2的-52次方</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="property">EPSILON</span> === <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, -<span class="number">52</span>);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">EPSILON</span>;</span><br><span class="line"><span class="comment">// 2.220446049250313e-16</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">EPSILON</span>.<span class="title function_">toFixed</span>(<span class="number">20</span>);</span><br><span class="line"><span class="comment">// &quot;0.00000000000000022204&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>Number.EPSILON</code>实际上是<code>JavaScript</code>能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。</p>
<p>引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。</p>
<p><code>Number.EPSILON</code>可以用来设置<code>能够接受的误差范围</code>。比如，误差范围设为<code>2</code>的<code>-50</code>次方（即<code>Number.EPSILON * Math.pow(2, 2)</code>），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> - <span class="number">0.3</span> &lt; <span class="title class_">Number</span>.<span class="property">EPSILON</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="31-有条件地向对象添加属性"><a href="#31-有条件地向对象添加属性" class="headerlink" title="31. 有条件地向对象添加属性"></a>31. 有条件地向对象添加属性</h2><p>我们可以使用展开运算符号(<code>...</code>)来有条件地向 JS 对象快速添加属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> condition = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">  ...(condition &amp;&amp; &#123; <span class="attr">age</span>: <span class="number">16</span> &#125;),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果每个操作数的值都为 <code>true</code>，则 <code>&amp;&amp;</code> 操作符返回最后一个求值表达式。因此返回一个对象<code>&#123;age: 16&#125;</code>，然后将其扩展为<code>person</code>对象的一部分。</p>
<p>如果 <code>condition</code> 为 <code>false</code>，JavaScript 会做这样的事情:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;前端小智&quot;</span>,</span><br><span class="line">  ...<span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 展开 `false` 对对象没有影响</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// &#123; id: 1, name: &#x27;John Doe&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="32-检查属性是否存在对象中"><a href="#32-检查属性是否存在对象中" class="headerlink" title="32.检查属性是否存在对象中"></a>32.检查属性是否存在对象中</h2><p>可以使用 <code>in</code> 关键字来检查 JavaScript 对象中是否存在某个属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;前端小智&quot;</span>, <span class="attr">salary</span>: <span class="number">1000</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;salary&quot;</span> <span class="keyword">in</span> person); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;age&quot;</span> <span class="keyword">in</span> person); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="33-对象中的动态属性名称"><a href="#33-对象中的动态属性名称" class="headerlink" title="33.对象中的动态属性名称"></a>33.对象中的动态属性名称</h2><p>使用动态键设置对象属性很简单。只需使用<code>[&#39;key name&#39;]</code>来添加属性:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dynamic = <span class="string">&quot;flavour&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> item = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;前端小智&quot;</span>,</span><br><span class="line">  [dynamic]: <span class="string">&quot;巧克力&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(item); <span class="comment">// &#123; name: &#x27;前端小智&#x27;, flavour: &#x27;巧克力&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

<p>同样的技巧也可用于使用动态键引用对象属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> keyName = <span class="string">&quot;name&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(item[keyName]); <span class="comment">// returns &#x27;前端小智&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="34-使用动态键进行对象解构"><a href="#34-使用动态键进行对象解构" class="headerlink" title="34. 使用动态键进行对象解构"></a>34. 使用动态键进行对象解构</h2><p>我们知道在对象解构时，可以使用 <code>:</code> 来对解构的属性进行重命名。但，你是否知道键名是动态的时，也可以解构对象的属性？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;前端小智&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">name</span>: personName &#125; = person;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(personName); <span class="comment">// &#x27;前端小智&#x27;</span></span><br></pre></td></tr></table></figure>

<p>现在，我们用动态键来解构属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> templates = &#123;</span><br><span class="line">  <span class="attr">hello</span>: <span class="string">&quot;Hello there&quot;</span>,</span><br><span class="line">  <span class="attr">bye</span>: <span class="string">&quot;Good bye&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> templateName = <span class="string">&quot;bye&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; [templateName]: template &#125; = templates;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(template); <span class="comment">// Good bye</span></span><br></pre></td></tr></table></figure>

<h2 id="35-空值合并-操作符"><a href="#35-空值合并-操作符" class="headerlink" title="35. 空值合并 ?? 操作符"></a>35. 空值合并 <code>??</code> 操作符</h2><p>当我们想检查一个变量是否为 <code>null</code> 或 <code>undefined</code> 时，<code>??</code>操作符很有用。当它的左侧操作数为<code>null</code> 或 <code>undefined</code>时，它返回右侧的操作数，否则返回其左侧的操作数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="literal">null</span> ?? <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// &#x27;Hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = <span class="string">&quot;Not null&quot;</span> ?? <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// &#x27;Not null&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baz = <span class="number">0</span> ?? <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>在第三个示例中，返回 <code>0</code>，因为即使 <code>0</code> 在 JS 中被认为是假的，但它不是<code>null</code>的或<code>undefined</code>的。你可能认为我们可以用||算子但这两者之间是有区别的</p>
<p>你可能认为我们可以在这里使用 <code>||</code> 操作符，但这两者之间是有区别的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cannotBeZero = <span class="number">0</span> || <span class="number">5</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cannotBeZero); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> canBeZero = <span class="number">0</span> ?? <span class="number">5</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(canBeZero); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h2 id="36-可选链"><a href="#36-可选链" class="headerlink" title="36.可选链 ?."></a>36.可选链 <code>?.</code></h2><p>我们是不是经常遇到这样的错误：<code>TypeError: Cannot read property ‘foo’ of null</code>。这对每一个毅开发人员来说都是一个烦人的问题。引入可选链就是为了解决这个问题。一起来看看：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> book = &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">title</span>: <span class="string">&quot;Title&quot;</span>, <span class="attr">author</span>: <span class="literal">null</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通常情况下，你会这样做</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(book.<span class="property">author</span>.<span class="property">age</span>); <span class="comment">// throws error</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(book.<span class="property">author</span> &amp;&amp; book.<span class="property">author</span>.<span class="property">age</span>); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用可选链</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(book.<span class="property">author</span>?.<span class="property">age</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 或深度可选链</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(book.<span class="property">author</span>?.<span class="property">address</span>?.<span class="property">city</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>还可以使用如下函数可选链：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&quot;前端&quot;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&quot;小智&quot;</span>,</span><br><span class="line">  <span class="attr">printName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="variable language_">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">printName</span>()); <span class="comment">// &#x27;前端 小智&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(persone.<span class="property">doesNotExist</span>?.()); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="37-使用-操作符"><a href="#37-使用-操作符" class="headerlink" title="37. 使用 !! 操作符"></a>37. 使用 <code>!!</code> 操作符</h2><p><code>!!</code> 运算符可用于将表达式的结果快速转换为布尔值(<code>true</code>或<code>false</code>):</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> greeting = <span class="string">&quot;Hello there!&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!!greeting); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> noGreeting = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!!noGreeting); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="38-字符串和整数转换"><a href="#38-字符串和整数转换" class="headerlink" title="38. 字符串和整数转换"></a>38. 字符串和整数转换</h2><p>使用 <code>+</code> 操作符将字符串快速转换为数字:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> stringNumer = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+stringNumer); <span class="comment">//123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> +stringNumer); <span class="comment">//&#x27;number&#x27;</span></span><br></pre></td></tr></table></figure>

<p>要将数字快速转换为字符串，也可以使用 <code>+</code> 操作符，后面跟着一个空字符串:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myString = <span class="number">25</span> + <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myString); <span class="comment">//&#x27;25&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> myString); <span class="comment">//&#x27;string&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这些类型转换非常方便，但它们的清晰度和代码可读性较差。<strong>所以实际开发，需要慎重的选择使用。</strong></p>
<h2 id="39-检查数组中的假值"><a href="#39-检查数组中的假值" class="headerlink" title="39. 检查数组中的假值"></a>39. 检查数组中的假值</h2><p>大家应该都用过数组方法：<code>filter</code>、<code>some</code>、<code>every</code>，这些方法可以配合 <code>Boolean</code> 方法来测试真假值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myArray = [<span class="literal">null</span>, <span class="literal">false</span>, <span class="string">&quot;Hello&quot;</span>, <span class="literal">undefined</span>, <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤虚值</span></span><br><span class="line"><span class="keyword">const</span> filtered = myArray.<span class="title function_">filter</span>(<span class="title class_">Boolean</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(filtered); <span class="comment">// [&#x27;Hello&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查至少一个值是否为真</span></span><br><span class="line"><span class="keyword">const</span> anyTruthy = myArray.<span class="title function_">some</span>(<span class="title class_">Boolean</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(anyTruthy); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查所有的值是否为真</span></span><br><span class="line"><span class="keyword">const</span> allTruthy = myArray.<span class="title function_">every</span>(<span class="title class_">Boolean</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(allTruthy); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>下面是它的工作原理。我们知道这些数组方法接受一个回调函数，所以我们传递 <code>Boolean</code> 作为回调函数。<code>Boolean</code> 函数本身接受一个参数，并根据参数的真实性返回 <code>true</code> 或 <code>false</code>。所以：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myArray.<span class="title function_">filter</span>(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="title class_">Boolean</span>(val));</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myArray.<span class="title function_">filter</span>(<span class="title class_">Boolean</span>);</span><br></pre></td></tr></table></figure>

<h2 id="40-扁平化数组"><a href="#40-扁平化数组" class="headerlink" title="40. 扁平化数组"></a>40. 扁平化数组</h2><p>在原型 Array 上有一个方法 <code>flat</code>，可以从一个数组的数组中制作一个单一的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myArray = [&#123; <span class="attr">id</span>: <span class="number">1</span> &#125;, [&#123; <span class="attr">id</span>: <span class="number">2</span> &#125;], [&#123; <span class="attr">id</span>: <span class="number">3</span> &#125;]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> flattedArray = myArray.<span class="title function_">flat</span>();</span><br><span class="line"><span class="comment">//[ &#123; id: 1 &#125;, &#123; id: 2 &#125;, &#123; id: 3 &#125; ]</span></span><br></pre></td></tr></table></figure>

<p>你也可以定义一个深度级别，指定一个嵌套的数组结构应该被扁平化的深度。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, [[[<span class="number">3</span>, <span class="number">4</span>]]]];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">flat</span>(<span class="number">2</span>)); <span class="comment">// returns [0, 1, 2, [3,4]]</span></span><br></pre></td></tr></table></figure>

<h2 id="41-Object-entries"><a href="#41-Object-entries" class="headerlink" title="41.Object.entries"></a>41.Object.entries</h2><p>大多数开发人员使用 <code>Object.keys</code> 方法来迭代对象。此方法仅返回对象键的数组，而不返回值。我们可以使用 <code>Object.entries</code> 来获取键和值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;前端小智&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(person); <span class="comment">// [&#x27;name&#x27;, &#x27;age&#x27;]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">entries</span>(data); <span class="comment">// [[&#x27;name&#x27;, &#x27;前端小智&#x27;], [&#x27;age&#x27;, 20]]</span></span><br></pre></td></tr></table></figure>

<p>为了迭代一个对象，我们可以执行以下操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(person).<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> is <span class="subst">$&#123;person[key]&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 entries 获取键和值</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">entries</span>(person).<span class="title function_">forEach</span>(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> is <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// name is 前端小智</span></span><br><span class="line"><span class="comment">// age is 20</span></span><br></pre></td></tr></table></figure>

<p>上述两种方法都返回相同的结果，但 <code>Object.entries</code> 获取键值对更容易。</p>
<h2 id="42-replaceAll-方法"><a href="#42-replaceAll-方法" class="headerlink" title="42.replaceAll 方法"></a>42.replaceAll 方法</h2><p>在 JS 中，要将所有出现的字符串替换为另一个字符串，我们需要使用如下所示的正则表达式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;Red-Green-Blue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只规制第一次出现的</span></span><br><span class="line">str.<span class="title function_">replace</span>(<span class="string">&quot;-&quot;</span>, <span class="string">&quot; &quot;</span>); <span class="comment">// Red Green-Blue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 RegEx 替换所有匹配项</span></span><br><span class="line">str.<span class="title function_">replace</span>(<span class="regexp">/\-/g</span>, <span class="string">&quot; &quot;</span>); <span class="comment">// Red Green Blue</span></span><br></pre></td></tr></table></figure>

<p>但是在 ES12 中，一个名为 <code>replaceAll</code> 的新方法被添加到 <code>String.prototype</code> 中，它用另一个字符串值替换所有出现的字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">str.<span class="title function_">replaceAll</span>(<span class="string">&quot;-&quot;</span>, <span class="string">&quot; &quot;</span>); <span class="comment">// Red Green Blue</span></span><br></pre></td></tr></table></figure>

<h2 id="43-数字分隔符"><a href="#43-数字分隔符" class="headerlink" title="43.数字分隔符"></a>43.数字分隔符</h2><p>可以使用下划线作为数字分隔符，这样可以方便地计算数字中 0 的个数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 难以阅读</span></span><br><span class="line"><span class="keyword">const</span> billion = <span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 易于阅读</span></span><br><span class="line"><span class="keyword">const</span> readableBillion = <span class="number">1000_000_000</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(readableBillion); <span class="comment">//1000000000</span></span><br></pre></td></tr></table></figure>

<p>下划线分隔符也可以用于 BigInt 数字，如下例所示</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> trillion = <span class="number">1000_000_000_000n</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(trillion); <span class="comment">// 1000000000000</span></span><br></pre></td></tr></table></figure>

<h2 id="44-document-designMode"><a href="#44-document-designMode" class="headerlink" title="44.document.designMode"></a>44.document.designMode</h2><p>与前端的 JavaScript 有关，设计模式让你可以编辑页面上的任何内容。只要打开浏览器控制台，输入以下内容即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">designMode</span> = <span class="string">&quot;on&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://alianck.oss-cn-beijing.aliyuncs.com/60js1.gif" alt="图片"></p>
<h2 id="45-逻辑赋值运算符"><a href="#45-逻辑赋值运算符" class="headerlink" title="45.逻辑赋值运算符"></a>45.逻辑赋值运算符</h2><p>逻辑赋值运算符是由逻辑运算符<code>&amp;&amp;</code>、<code>||</code>、<code>??</code>和赋值运算符<code>=</code>组合而成。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">a &amp;&amp;= b;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面等价于</span></span><br><span class="line">a &amp;&amp; (a = b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line">  a = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查<code>a</code>的值是否为真，如果为真，那么更新<code>a</code>的值。使用逻辑或 <code>||</code>操作符也可以做同样的事情。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">a ||= b;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面等价于</span></span><br><span class="line">a || (a = b);</span><br></pre></td></tr></table></figure>

<p>使用空值合并操作符 <code>??</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">a ??= b;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面等价于</span></span><br><span class="line"><span class="keyword">if</span> (a === <span class="literal">null</span> || a === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  a = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：<code>??</code>操作符只检查 <code>null</code> 或 <code>undefined</code> 的值。</p>
<h2 id="46-同步阻塞法实现-sleep-函数"><a href="#46-同步阻塞法实现-sleep-函数" class="headerlink" title="46.同步阻塞法实现 sleep 函数"></a>46.同步阻塞法实现 sleep 函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sleep</span> = (<span class="params">delay</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>() &lt; start + delay) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_">sleep</span>(<span class="number">3000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h2 id="47-利用-new-URL-解析-URL"><a href="#47-利用-new-URL-解析-URL" class="headerlink" title="47.利用 new URL 解析 URL"></a>47.利用 new URL 解析 URL</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">parseURL</span> = (<span class="params">url = <span class="string">&quot;&quot;</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">new</span> <span class="title function_">URL</span>(url);</span><br><span class="line">  res.<span class="property">queryParams</span> = <span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key) &#123;</span><br><span class="line">      <span class="keyword">return</span> res.<span class="property">searchParams</span>.<span class="title function_">get</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> params = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> paramGroup = res.<span class="property">search</span>.<span class="title function_">replace</span>(<span class="regexp">/^\?/</span>, <span class="string">&quot;&quot;</span>).<span class="title function_">split</span>(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">    paramGroup.<span class="title function_">forEach</span>(<span class="function">(<span class="params">param</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> [key, val] = param.<span class="title function_">split</span>(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">      params[key] = val;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> params;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">parseURL</span>(<span class="string">&quot;https://www.example.com/a/b?c=1&amp;d=2&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="48-一行代码实现星级评分"><a href="#48-一行代码实现星级评分" class="headerlink" title="48.一行代码实现星级评分"></a>48.一行代码实现星级评分</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getRate</span> = (<span class="params">rate = <span class="number">0</span></span>) =&gt; <span class="string">&quot;★★★★★☆☆☆☆☆&quot;</span>.<span class="title function_">slice</span>(<span class="number">5</span> - rate, <span class="number">10</span> - rate);</span><br><span class="line"><span class="title function_">getRate</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h2 id="49-用位运算提升效率"><a href="#49-用位运算提升效率" class="headerlink" title="49.用位运算提升效率"></a>49.用位运算提升效率</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ｜ 取整</span></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">1.7</span>;</span><br><span class="line">num1 = num1 | <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &gt;&gt; 取半</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">6</span>;</span><br><span class="line">num2 = num2 &gt;&gt; <span class="number">1</span>; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;&lt; 加倍</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="number">6</span>;</span><br><span class="line">num3 = num3 &lt;&lt; <span class="number">1</span>; <span class="regexp">/ /</span> <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ^ 交换值</span></span><br><span class="line"><span class="keyword">let</span> num4 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> num5 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">num4 ^= num5;</span><br><span class="line">num5 ^= num4;</span><br><span class="line">num4 ^= num5; <span class="comment">// num4 === 2, num5 === 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &amp; 判断奇数</span></span><br><span class="line"><span class="keyword">let</span> num6 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> num7 = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">num6 &amp; <span class="number">1</span> === <span class="number">1</span>; <span class="comment">// true</span></span><br><span class="line">num7 &amp; <span class="number">1</span> === <span class="number">1</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ~ 判断是否存在</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> key = <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> keyIsExist = !!~data.<span class="title function_">indexOf</span>(key); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否 2 的整数幂</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isPowerOf2</span> = num =&gt; (num &amp; (num - <span class="number">1</span>)) === <span class="number">0</span>;</span><br><span class="line"><span class="title function_">isPowerOf2</span>(<span class="number">8</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title function_">isPowerOf2</span>(<span class="number">7</span>) <span class="comment">// false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="50-判断是否是千分符字符"><a href="#50-判断是否是千分符字符" class="headerlink" title="50.判断是否是千分符字符"></a>50.判断是否是千分符字符</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">numberIsThousand</span> = (<span class="params">str</span>) =&gt; <span class="regexp">/^-?\d&#123;1,3&#125;(,\d&#123;3&#125;)*(\.\d+)?$/</span>.<span class="title function_">test</span>(str);</span><br><span class="line"><span class="title function_">numberIsThousand</span>(<span class="string">&quot;100,000,000,000&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="title function_">numberIsThousand</span>(<span class="string">&quot;100,000,000,00&quot;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="51-复制文本到剪切板"><a href="#51-复制文本到剪切板" class="headerlink" title="51.复制文本到剪切板"></a>51.复制文本到剪切板</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">copyToClipboard</span> = (<span class="params">content</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> clipboardData = <span class="variable language_">window</span>.<span class="property">clipboardData</span>;</span><br><span class="line">  <span class="keyword">if</span> (clipboardData) &#123;</span><br><span class="line">    clipboardData.<span class="title function_">clearData</span>();</span><br><span class="line">    clipboardData.<span class="title function_">setData</span>(<span class="string">&quot;Text&quot;</span>, content);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">execCommand</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> el = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;textarea&quot;</span>);</span><br><span class="line">    el.<span class="property">value</span> = content;</span><br><span class="line">    el.<span class="title function_">setAttribute</span>(<span class="string">&quot;readonly&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    el.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&quot;absolute&quot;</span>;</span><br><span class="line">    el.<span class="property">style</span>.<span class="property">left</span> = <span class="string">&quot;-9999px&quot;</span>;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(el);</span><br><span class="line">    el.<span class="title function_">select</span>();</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">execCommand</span>(<span class="string">&quot;copy&quot;</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(el);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">copyToClipboard</span>(<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="52-一行代码生成指定长度的数组"><a href="#52-一行代码生成指定长度的数组" class="headerlink" title="52.一行代码生成指定长度的数组"></a>52.一行代码生成指定长度的数组</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">List</span> = (<span class="params">len</span>) =&gt; [...<span class="keyword">new</span> <span class="title class_">Array</span>(len).<span class="title function_">keys</span>()];</span><br><span class="line"><span class="keyword">const</span> list = <span class="title class_">List</span>(<span class="number">10</span>); <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>

<h2 id="53-判断数据类型"><a href="#53-判断数据类型" class="headerlink" title="53.判断数据类型"></a>53.判断数据类型</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">type</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> toString = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>;</span><br><span class="line">  <span class="keyword">const</span> dataType =</span><br><span class="line">    data <span class="keyword">instanceof</span> <span class="title class_">Element</span></span><br><span class="line">      ? <span class="string">&quot;element&quot;</span> <span class="comment">// 为了统一DOM节点类型输出</span></span><br><span class="line">      : toString</span><br><span class="line">          .<span class="title function_">call</span>(data)</span><br><span class="line">          .<span class="title function_">replace</span>(<span class="regexp">/\[object\s(.+)\]/</span>, <span class="string">&quot;$1&quot;</span>)</span><br><span class="line">          .<span class="title function_">toLowerCase</span>();</span><br><span class="line">  <span class="keyword">return</span> dataType;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">type</span>(&#123;&#125;); <span class="comment">// object</span></span><br></pre></td></tr></table></figure>

<h2 id="54-正则判断字符重复次数不超过两次"><a href="#54-正则判断字符重复次数不超过两次" class="headerlink" title="54.正则判断字符重复次数不超过两次"></a>54.正则判断字符重复次数不超过两次</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">strIsRepeatThan2</span> = (<span class="params">str = <span class="string">&quot;&quot;</span></span>) =&gt;</span><br><span class="line">  <span class="regexp">/^(?!.*(.).*\1&#123;2&#125;)[\da-zA-Z].+$/</span>.<span class="title function_">test</span>(str);</span><br><span class="line"><span class="title function_">strIsRepeatThan2</span>(<span class="string">&quot;123456&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="title function_">strIsRepeatThan2</span>(<span class="string">&quot;1234566&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="title function_">strIsRepeatThan2</span>(<span class="string">&quot;12345666&quot;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="55-正则匹配可以只有-0-但开头不能是-0-的数字"><a href="#55-正则匹配可以只有-0-但开头不能是-0-的数字" class="headerlink" title="55.正则匹配可以只有 0 但开头不能是 0 的数字"></a>55.正则匹配可以只有 0 但开头不能是 0 的数字</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getCorrectNumber</span> = (<span class="params">str = <span class="string">&quot;&quot;</span></span>) =&gt; <span class="regexp">/^(\d|[1-9]\d*)$/</span>.<span class="title function_">test</span>(str);</span><br><span class="line"><span class="title function_">getCorrectNumber</span>(<span class="string">&quot;0&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="title function_">getCorrectNumber</span>(<span class="string">&quot;011&quot;</span>); <span class="comment">// false</span></span><br><span class="line"><span class="title function_">getCorrectNumber</span>(<span class="string">&quot;101&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="56-使用-history-back-可以创建一个浏览器“返回”按钮。"><a href="#56-使用-history-back-可以创建一个浏览器“返回”按钮。" class="headerlink" title="56.使用 history.back() 可以创建一个浏览器“返回”按钮。"></a>56.使用 history.back() 可以创建一个浏览器“返回”按钮。</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">&quot;history.back()&quot;</span>&gt;返回&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<h2 id="57-事件监听器只运行一次"><a href="#57-事件监听器只运行一次" class="headerlink" title="57.事件监听器只运行一次"></a>57.事件监听器只运行一次</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;I run only once&quot;</span>), &#123;</span><br><span class="line">  <span class="attr">once</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="58-从数组中过滤所有虚值"><a href="#58-从数组中过滤所有虚值" class="headerlink" title="58.从数组中过滤所有虚值"></a>58.从数组中过滤所有虚值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myArray = [<span class="number">1</span>, <span class="literal">undefined</span>, <span class="title class_">NaN</span>, <span class="number">2</span>, <span class="literal">null</span>, <span class="string">&quot;@denicmarko&quot;</span>, <span class="literal">true</span>, <span class="number">3</span>, <span class="literal">false</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myArray.<span class="title function_">filter</span>(<span class="title class_">Boolean</span>)); <span class="comment">// [1, 2, &quot;@denicmarko&quot;, true, 3]</span></span><br></pre></td></tr></table></figure>

<h2 id="59-妙用-reduce-对数组求和"><a href="#59-妙用-reduce-对数组求和" class="headerlink" title="59.妙用 reduce 对数组求和"></a>59.妙用 reduce 对数组求和</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myArray = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reducer</span> = (<span class="params">total, currentValue</span>) =&gt; total + currentValue;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myArray.<span class="title function_">reduce</span>(reducer)); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<h2 id="60-从数组中获取最小值-最大值"><a href="#60-从数组中获取最小值-最大值" class="headerlink" title="60.从数组中获取最小值&#x2F;最大值"></a>60.从数组中获取最小值&#x2F;最大值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">6</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">max</span>(...numbers)); <span class="comment">// 9</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">min</span>(...numbers)); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>::: tip 提示<br>有部分重复内容，欢迎指正！:stuck_out_tongue_winking_eye:<br>:::</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>H5 调用支付宝小程序 Alipay JSAPI</title>
    <url>/post/0b5b0be39ebf/</url>
    <content><![CDATA[<h2 id="H5-调用支付宝小程序-Alipay-JSAPI"><a href="#H5-调用支付宝小程序-Alipay-JSAPI" class="headerlink" title="H5 调用支付宝小程序 Alipay JSAPI"></a>H5 调用支付宝小程序 Alipay JSAPI</h2><p>参考链接 <a href="https://opendocs.alipay.com/open/02502i">官方文档：</a>。<br>demo：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://gw.alipayobjects.com/as/g/h5-lib/alipayjsapi/3.1.1/alipayjsapi.inc.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/vConsole/3.2.0/vconsole.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Alipay-demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      hello</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span> <span class="attr">contenteditable</span>=<span class="string">&quot;true&quot;</span>&gt;</span>world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn1&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;fn()&quot;</span>&gt;</span>点击1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn2&quot;</span>&gt;</span>点击2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">var</span> vConsole = <span class="keyword">new</span> <span class="title class_">VConsole</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">function</span> <span class="title function_">ready</span>(<span class="params">callback</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">AlipayJSBridge</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          callback &amp;&amp; <span class="title function_">callback</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;请在支付宝打开&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;AlipayJSBridgeReady&quot;</span>, callback, <span class="literal">false</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="variable language_">window</span>.<span class="property">AlipayJSBridge</span> = &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">call</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">              <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;mock AlipayJSBridge call&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title function_">ready</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.btn2&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="title class_">AlipayJSBridge</span>.<span class="title function_">call</span>(</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="string">&quot;beehiveOptionsPicker&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">              <span class="attr">title</span>: <span class="string">&quot;还款日选择&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">              <span class="attr">optionsOne</span>: [</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="string">&quot;每周一&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="string">&quot;每周二&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="string">&quot;每周三&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="string">&quot;每周四&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="string">&quot;每周五&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="string">&quot;每周六&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="string">&quot;每周日&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">              ],</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">              <span class="attr">selectedOneIndex</span>: <span class="number">2</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">function</span> (<span class="params">result</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">              <span class="title function_">alert</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(result));</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          );</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="comment">// AlipayJSBridge.call(</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="comment">//   &quot;chooseContact&quot;,</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="comment">//   &#123;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="comment">//     title: &quot;choose contacts&quot;, // title show on the title bar</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="comment">//     multiMax: 2, // max contact items size, default 50</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="comment">//     multiMaxText: &quot;max!&quot;, // message if selected more than max</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="comment">//   &#125;,</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="comment">//   function (result) &#123;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="comment">//     alert(JSON.stringify(result));</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="comment">//   &#125;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="comment">// );</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title class_">AlipayJSBridge</span>.<span class="title function_">call</span>(<span class="string">&quot;toast&quot;</span>, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="attr">content</span>: <span class="string">&quot;请填写正确的姓名&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="attr">type</span>: <span class="string">&quot;none&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="attr">duration</span>: <span class="number">2000</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>用 open with live server 方式打开生成二维码，然后用支付宝扫码预览</p>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS教程和技巧收藏</title>
    <url>/post/d358c5c77f42/</url>
    <content><![CDATA[<h2 id="CSS教程和技巧收藏"><a href="#CSS教程和技巧收藏" class="headerlink" title="CSS教程和技巧收藏"></a>CSS教程和技巧收藏</h2><ul>
<li><a href="http://www.ruanyifeng.com/blog/2020/08/five-css-layouts-in-one-line.html">只要一行代码，实现五种 CSS 经典布局</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局教程：语法篇</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html">Flex 布局教程：实例篇</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">CSS Grid 网格布局教程</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2019/11/css-position.html">CSS 定位详解</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2018/07/white-space.html">CSS 的空格处理</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2017/05/css-variables.html">CSS 变量教程</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2017/04/css_in_js.html">CSS in JS 简介</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/06/css_modules.html">CSS Modules 用法教程</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/02/css_transition_and_animation.html">CSS动画简介</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2010/03/css_cookbook.html">CSS使用技巧</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2010/03/cross-browser_css3_features.html">CSS3常用功能的写法</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2009/03/css_selectors.html">CSS选择器笔记</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2008/05/css_background_image_positioning.html">CSS中背景图片定位方法</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>9个你不知道的 CSS 伪元素</title>
    <url>/post/6ce935d403d7/</url>
    <content><![CDATA[<h2 id="9个你不知道的-CSS-伪元素"><a href="#9个你不知道的-CSS-伪元素" class="headerlink" title="9个你不知道的 CSS 伪元素"></a>9个你不知道的 CSS 伪元素</h2><p>CSS 伪元素是一项强大的功能，它允许您为所选元素的特定部分设置样式，而无需额外的 JavaScript 代码。<br>虽然许多开发人员都熟悉常用的伪元素，如 ::before 和 ::after，但还有一些其他元素经常被忽视或未得到充分利用。 </p>
<h3 id="1-selection-伪元素"><a href="#1-selection-伪元素" class="headerlink" title="1. ::selection 伪元素"></a>1. ::selection 伪元素</h3><p>::selection 伪元素以用户选择的文本部分为目标。它提供了一种将样式应用于所选文本并自定义其外观的方法。 </p>
<p>例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">::selection</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，当用户在页面上选择文本时，它将以黄色背景和红色文本颜色突出显示。</p>
<h3 id="2-first-letter伪元素"><a href="#2-first-letter伪元素" class="headerlink" title="2.::first-letter伪元素"></a>2.::first-letter伪元素</h3><p>::first-letter 伪元素允许您设置块级元素的第一个字母的样式。当您想将特殊格式应用于段落或标题的初始字符时，它会派上用场。 </p>
<p>例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-letter</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码片段中，每个段落的第一个字母将以更大的字体显示并显示为红色。</p>
<h3 id="3-first-line-伪元素"><a href="#3-first-line-伪元素" class="headerlink" title="3. ::first-line 伪元素"></a>3. ::first-line 伪元素</h3><p>类似于 ::first-letter，::first-line 伪元素以文本或块级元素的第一行为目标。您可以使用此伪元素将特定样式应用于段落或标题的起始行。 </p>
<p>例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-line</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，每个段落的第一行将以粗体显示并带有下划线。</p>
<h3 id="4-marker-伪元素"><a href="#4-marker-伪元素" class="headerlink" title="4. ::marker 伪元素"></a>4. ::marker 伪元素</h3><p>::marker 伪元素以列表项的标记为目标，例如无序列表中的项目符号点或有序列表中的数字。使用此伪元素，您可以自定义标记的外观。 </p>
<p>例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">::marker</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-placeholder-伪元素"><a href="#5-placeholder-伪元素" class="headerlink" title="5. ::placeholder 伪元素"></a>5. ::placeholder 伪元素</h3><p>::placeholder 伪元素允许您在输入字段和文本区域中设置占位符文本的样式。通过将自定义样式应用到占位符，您可以增强用户体验并使其与您的整体设计保持一致。 </p>
<p>例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">::placeholder</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#999</span>;</span><br><span class="line">  <span class="attribute">font-style</span>: italic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，输入字段中的占位符文本将以浅灰色和斜体字体样式显示。</p>
<h3 id="6-cue-伪元素"><a href="#6-cue-伪元素" class="headerlink" title="6. ::cue 伪元素"></a>6. ::cue 伪元素</h3><p>::cue 伪元素以 <audio> 或 <video> 元素的提示文本为目标。提示文本通常用于多媒体内容中的字幕或副标题。使用此伪元素，您可以将样式专门应用于提示文本。 </p>
<p>例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">video</span><span class="selector-pseudo">::cue</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，视频元素中的提示文本将具有白色文本颜色和黑色背景。</p>
<h3 id="7-grammar-error-和-spelling-error-伪元素"><a href="#7-grammar-error-和-spelling-error-伪元素" class="headerlink" title="7. ::grammar-error 和::spelling-error 伪元素"></a>7. ::grammar-error 和::spelling-error 伪元素</h3><p>::grammar-error 和 ::spelling-error 伪元素允许您分别对标记为语法或拼写错误的文本部分设置样式。当内容中存在错误时，这些伪元素可用于向用户提供视觉提示。 </p>
<p>例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::grammar-error</span> &#123;</span><br><span class="line">  <span class="attribute">text-decoration</span>: line-through;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::spelling-error</span> &#123;</span><br><span class="line">  <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，段落中的语法错误将以划线文本修饰和红色显示，而拼写错误将以下划线和蓝色显示。</p>
<h3 id="8-backdrop-伪元素"><a href="#8-backdrop-伪元素" class="headerlink" title="8. ::backdrop 伪元素"></a>8. ::backdrop 伪元素</h3><p>::backdrop 伪元素与全屏 API 结合使用，以在全屏模式下自定义元素背后的背景。它允许您将默认的黑色背景更改为自定义颜色或样式。 </p>
<p>例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">video</span><span class="selector-pseudo">::backdrop</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: gray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，当一个视频元素处于全屏模式时，它后面的背景将有一个灰色的背景色。</p>
<h3 id="9-target-text-伪元素"><a href="#9-target-text-伪元素" class="headerlink" title="9. ::target-text 伪元素"></a>9. ::target-text 伪元素</h3><p>::target-text CSS 伪元素代表滚动到的文本（如果浏览器支持文本片段）。它允许作者选择如何突出显示该部分文本。 </p>
<p>例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">::target-text &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: rebeccapurple;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是 MDN 提供的在线示例。请注意，此 API 目前处于试验阶段。</p>
<p><strong>结论</strong></p>
<p>CSS 伪元素为元素的特定部分设置样式和增强网页的视觉吸引力提供了广泛的可能性。您无需使用过多的 JavaScript 代码即可实现令人印象深刻的样式效果。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6来简化代码,你都用过哪些</title>
    <url>/post/2711ab091b13/</url>
    <content><![CDATA[<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>为什么需要块级作用域?</p>
<p>ES5 只有全局作用域和函数作用域，没有块级作用域，这导致很多场景不合理。</p>
<ul>
<li>第一种场景，内层变量可能会覆盖外层变量。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(tmp);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(); <span class="comment">// undefined</span></span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<p>以上代码的原意是， if 代码块的外部使用外层的 tmp 变量，内部使用内层的 tmp 变量。但是，函数 <code>fn</code> 执行后，输出结果为 <code>undefined</code> ，原因在于变量提升导致内层的 tmp 变量覆盖了外层的 tmp 变量。</p>
<ul>
<li>第二种场景，用来计数的循环变量泄露为全局变量。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = O; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 5</span></span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，变量 <code>i</code> 只用来控制循环，但是循环结束后，它并没有消失，而是泄露成了全局变量。</p>
<p><code>let</code> 实际上为 <code>JavaScript</code> 新增了块级作用域。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fl</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<p>上面的函数有两个代码块，都声明了变量 <code>n</code>，运行后输出 <code>5</code> 。这表示外层代码块不受内层代码块的影响。如果使用 <code>var</code> 定义变量 ，最后输出的值就是 <code>10</code></p>
<p>那么我们能利用<code>块级作用域</code>做什么呢？</p>
<p>我们先来做道面试题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5 5 5 5 5</span></span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<p>改成 <code>ES6</code> 中的 let</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 1 2 3 4</span></span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<p>看到这，相信聪明的你已经理解块级作用域的好处了 O(∩_∩)O</p>
<p>那么 <code>ES5</code> 能不能实现 <code>块级作用域</code> 的效果呢? 可以的，我们可以利用闭包</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="keyword">function</span> (<span class="params">index</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(index);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 1 2 3 4</span></span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><blockquote>
<p>解构 ：是将一个数据结构分解为更小的部分的过程。ES6 中，从数组和对象中提取值，对变量进行赋值。</p>
</blockquote>
<p>那么解构有什么用处呢？</p>
<ol>
<li>可以大大的简化变量声明操作。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> baz = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar, baz] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<ol>
<li>变量交换：看起来如同镜像。赋值语句的左侧的解构模式，右侧是临时创建的数组字面量。x 被赋值为数组中的 y，y 被赋值为数组中的 x。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line">[x, y] = [y, x];</span><br><span class="line"><span class="comment">// x = 2, y = 1</span></span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<ol>
<li>对象解构</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; x, y &#125; = obj;</span><br><span class="line"><span class="comment">// x = 1</span></span><br><span class="line"><span class="comment">// y = 2</span></span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<ol>
<li>字符串解构</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">// a =&gt; h</span></span><br><span class="line"><span class="comment">// b =&gt; e</span></span><br><span class="line"><span class="comment">// c =&gt; l</span></span><br><span class="line"><span class="comment">// d =&gt; l</span></span><br><span class="line"><span class="comment">// e =&gt; o</span></span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<ol>
<li>函数参数解构</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xueyue = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;雪月&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getAge</span>(<span class="params">&#123; name, age &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span>今年<span class="subst">$&#123;age&#125;</span>岁`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getAge</span>(xueyue); <span class="comment">// 雪月今年18岁</span></span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p><code>ES6</code> 允许使用箭头 <code>=&gt;</code> 定义函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">f</span> = (<span class="params">v</span>) =&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 ES5 的</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params">v</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<p>如果箭头函数不需要参数或需要多个参数，就使用圆括号代表参数部分。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 等同于 ES5 的</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">sum</span> = (<span class="params">numl, num2</span>) =&gt; numl + num2;</span><br><span class="line"><span class="comment">// 等同于 ES5 的</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="keyword">function</span> (<span class="params">numl, num2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> numl + num2;</span><br><span class="line">&#125;;</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<p>箭头函数可以与解构结合使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">full</span> = (<span class="params">&#123; first, last &#125;</span>) =&gt; first + <span class="string">&quot; &quot;</span> + last;</span><br><span class="line"><span class="comment">// 等同于 ES5 的</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">full</span>(<span class="params">person</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> person.<span class="property">first</span> + <span class="string">&quot; &quot;</span> + person.<span class="property">last</span>;</span><br><span class="line">&#125;</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<p>箭头函数使得表达更加简洁</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">isEven</span> = (<span class="params">n</span>) =&gt; n % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">square</span> = (<span class="params">n</span>) =&gt; n * n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = values.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"><span class="comment">// 等同于 ES5 的</span></span><br><span class="line"><span class="keyword">var</span> result = values.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<p>上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。</p>
<p><strong>箭头函数使用注意点</strong></p>
<ol>
<li>函数体内的 <code>this</code> 对象，就是定义时所在的对象，而不是使用时所在的对象。</li>
<li>不可以当作构造函数，也就是说，不可以使用 <code>new</code> 命令，否则会抛出一个错误。</li>
<li>不可以使用 <code>arguments</code> 对象，该对象在函数体内不存在。如果要用，可以用 <code>rest</code> 参数代替。</li>
<li>不可以使用 <code>yield</code> 命令，因此箭头函数不能用作 <code>Generator</code> 函数。</li>
</ol>
<p>上面四点中，第一点尤其值得注意。<code>this</code> 对象的指向是可变的，但是在箭头函数中，它是固定的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;id:&quot;</span>, <span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换成ES5</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;id:&quot;</span>, _this.<span class="property">id</span>);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<p>上面代码中，转换后的 <code>ES5</code> 版本清楚地说明了，箭头函数里面根本没有自己的 <code>this</code>，而是引用外层的 <code>this</code>。</p>
<h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><blockquote>
<p>模板字符串（ template string ）是增强版的字符串 ，用反引号 <code>(``)</code> 标识 。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; log &#125; = <span class="variable language_">console</span>;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;雪月&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通字符串拼接</span></span><br><span class="line"><span class="keyword">const</span> result = name + <span class="string">&quot;今年&quot;</span> + age + <span class="string">&quot;岁&quot;</span>;</span><br><span class="line"><span class="comment">// 使用模板字符串</span></span><br><span class="line"><span class="keyword">const</span> result2 = <span class="string">`<span class="subst">$&#123;name&#125;</span>今年<span class="subst">$&#123;age&#125;</span>岁`</span>;</span><br><span class="line"><span class="title function_">log</span>(result); <span class="comment">// 雪月今年18岁</span></span><br><span class="line"><span class="title function_">log</span>(result2); <span class="comment">// 雪月今年18岁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $&#123;&#125; 大括号可以放入任意的 JavaScript 表达式，可以进行运算</span></span><br><span class="line"><span class="keyword">const</span> result3 = <span class="string">`<span class="subst">$&#123;name&#125;</span>今年<span class="subst">$&#123;age * <span class="number">2</span>&#125;</span>岁`</span>;</span><br><span class="line"><span class="title function_">log</span>(result3); <span class="comment">// 雪月今年36岁</span></span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h3 id="剩余参数-展开语法"><a href="#剩余参数-展开语法" class="headerlink" title="剩余参数 &#x2F; 展开语法"></a>剩余参数 &#x2F; 展开语法</h3><p>ES6 引入了 rest 参数（形式为<code>...变量名</code>），用于获取函数的多余参数，这样就不需要使用 <code>arguments</code> 对象了。<code>rest</code> 参数搭配的变量是一个数组，该变量将多余的参数放入其中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sortNumbers</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>).<span class="title function_">sort</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 rest</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sortNumbers</span> = (<span class="params">...numbers</span>) =&gt; numbers.<span class="title function_">sort</span>();</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<p>比较上面的两种写法可以发现， <code>rest</code> 参数的写法更自然也更简洁。</p>
<p>扩展运算符（ <code>spread</code> ）是三个点（…） 如同 <code>rest</code> 参数的逆运算 将一个数组转为用逗号分隔的参数序列</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<p>下面是扩展运算符取代 <code>apply</code> 方法的一个实际例子 应用 <code>Math.max</code> 方法简化求出数组中的最大元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ESS 的写法</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>]);</span><br><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">max</span>(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>]);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>);</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<p>扩展运算符提供了数组合并的新写法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  ESS</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].<span class="title function_">concat</span>(more);</span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, ...more];</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<p>对象的扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> z = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="string">&quot;bb&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> n = &#123; ...z &#125;;</span><br><span class="line">n; <span class="comment">// &#123; a: 3, b: &#x27;bb&#x27; &#125;</span></span><br><span class="line">n === z; <span class="comment">// false</span></span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<p><strong>特别注意：</strong> <code>...</code>扩展对象，只能做到当对象属性是 <code>基本数据类型</code> 才是 <code>深拷贝</code>，如果是 <code>引用数据类型</code>，那就是<code>浅拷贝</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> z = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="string">&quot;bb&quot;</span>, <span class="attr">c</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;ccc&quot;</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> n = &#123; ...z &#125;;</span><br><span class="line"></span><br><span class="line">n; <span class="comment">// &#123; a: 3, b: &#x27;bb&#x27;, c: &#123; name: &#x27;ccc&#x27; &#125; &#125;</span></span><br><span class="line">n === z; <span class="comment">// false</span></span><br><span class="line">n.<span class="property">c</span> === z.<span class="property">c</span>; <span class="comment">// true</span></span><br><span class="line"><span class="comment">// n.c 跟 z.c 是同一个引用地址</span></span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h3 id="对象字面量简写语法"><a href="#对象字面量简写语法" class="headerlink" title="对象字面量简写语法"></a>对象字面量简写语法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;雪月&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5写法</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: name,</span><br><span class="line">  <span class="attr">f</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6简写</span></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  name,</span><br><span class="line">  <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">f</span>(); <span class="comment">// 雪月</span></span><br><span class="line">obj2.<span class="title function_">f</span>(); <span class="comment">// 雪月</span></span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<p>使用 <code>vue</code> 的同学是不是感到很熟悉</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">list</span>: [],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h3 id="数组实例的-includes"><a href="#数组实例的-includes" class="headerlink" title="数组实例的 includes()"></a>数组实例的 includes()</h3><p>Array.prototype.includes 方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的 includes 方法类似。ES2016 引入了该方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">2</span>); <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">4</span>); <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="title class_">NaN</span>].<span class="title function_">includes</span>(<span class="title class_">NaN</span>); <span class="comment">// true</span></span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<p>没有该方法之前，我们通常使用数组的 indexOf 方法，检查是否包含某个值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">if</span> (arr.<span class="title function_">indexOf</span>(el) !== -<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">if</span> (arr.<span class="title function_">includes</span>(el)) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 那么 indexOf 能不能做到类似于 includes 的写法呢？ 我们可以利用 ~ 位运算符</span></span><br><span class="line"><span class="keyword">if</span> (~arr.<span class="title function_">indexOf</span>(el)) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<p><code>indexOf</code> 方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（&#x3D;&#x3D;&#x3D;）进行判断，这会导致对 <code>NaN</code> 的误判。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="title class_">NaN</span>].<span class="title function_">indexOf</span>(<span class="title class_">NaN</span>);</span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<p><code>includes</code> 使用的是不一样的判断算法，就没有这个问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="title class_">NaN</span>].<span class="title function_">includes</span>(<span class="title class_">NaN</span>);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h3 id="Async-await-异步语法"><a href="#Async-await-异步语法" class="headerlink" title="Async&#x2F;await 异步语法"></a>Async&#x2F;await 异步语法</h3><p><code>ES2017</code> 标准引入了 <code>async</code> 函数，使得异步操作变得更加方便。</p>
<p><code>async</code> 函数是什么？一句话，它就是 <code>Generator</code> 函数的语法糖。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getTitle</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">  <span class="keyword">let</span> html = <span class="keyword">await</span> response.<span class="title function_">text</span>();</span><br><span class="line">  <span class="keyword">return</span> html.<span class="title function_">match</span>(<span class="regexp">/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i</span>)[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getTitle</span>(<span class="string">&quot;https://tc39.github.io/ecma262/&quot;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res));</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数 <code>getTitle</code> 内部有三个操作：<code>抓取网页</code>、<code>取出文本</code>、<code>匹配页面标题</code>。只有这三个操作全部完成，才会执行 <code>then</code> 方法里面的 <code>console.log</code></p>
<h3 id="结束（意犹未尽）"><a href="#结束（意犹未尽）" class="headerlink" title="结束（意犹未尽）"></a>结束（意犹未尽）</h3><p>文章介绍了 <code>ES6</code> 常用的一些语法以及使用场景; 但是 <code>ES6</code> 内容远不止于此，感兴趣的同学可以去 <code>阮一峰老师的</code> ES6 入门教程[1] 一书中查看详细内容。如果您认可这本书，也可以去正版渠道购买书籍。这样可以使出版社不因出版开源书籍而亏钱，进而鼓励更多的作者开源自己的书籍。</p>
<h3 id="后记（列举-API）"><a href="#后记（列举-API）" class="headerlink" title="后记（列举 API）"></a>后记（列举 API）</h3><p>还有很多 <code>ES6</code> 实用的 <code>API</code> 我就简单提及一下，朋友们看看平时是否有用到</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>].<span class="title function_">find</span>(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>);</span><br><span class="line"><span class="comment">// -5</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].<span class="title function_">findIndex</span>(<span class="function">(<span class="params">value, index, arr</span>) =&gt;</span> value &gt; <span class="number">9</span>);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].<span class="title function_">flat</span>();</span><br><span class="line"><span class="comment">// [1, 2, 3, [4, 5]]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].<span class="title function_">flat</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">8</span>, <span class="number">54</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="title class_">NaN</span>, <span class="title class_">NaN</span>, <span class="string">&quot;NaN&quot;</span>, <span class="string">&quot;NaN&quot;</span>].<span class="title function_">filter</span>(</span><br><span class="line">  <span class="function">(<span class="params">number, index, arr</span>) =&gt;</span> arr.<span class="title function_">indexOf</span>(number) === index</span><br><span class="line">);</span><br><span class="line"><span class="comment">// [3, 8, 54, &quot;NaN&quot;] 利用filter过滤去重，注意会漏掉NaN</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item * <span class="number">2</span>);</span><br><span class="line"><span class="comment">// [2, 4, 6, 8] 利用map返回一个新数组，不改变原数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 reduce 求和; reduce功能极其强大 ! yyds</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">  accumulator,</span></span><br><span class="line"><span class="params">  currentValue,</span></span><br><span class="line"><span class="params">  currentIndex,</span></span><br><span class="line"><span class="params">  array</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> accumulator + currentValue;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES2017 引入了跟 Object.keys 配套的 Object.values 和 Object.entries，作为遍历一个对象的补充手段，</span></span><br><span class="line"><span class="comment">// 供 for...of 循环使用。</span></span><br><span class="line"><span class="keyword">let</span> &#123; keys, values, entries &#125; = <span class="title class_">Object</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> <span class="title function_">values</span>(obj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title function_">entries</span>(obj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>([key, value]); <span class="comment">// [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2], [&#x27;c&#x27;, 3]</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<blockquote>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>面试</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub Actions 定时运行代码</title>
    <url>/post/413a7e2da9de/</url>
    <content><![CDATA[<h1 id="GitHub-Actions-定时运行代码：每天定时百度链接推送"><a href="#GitHub-Actions-定时运行代码：每天定时百度链接推送" class="headerlink" title="GitHub Actions 定时运行代码：每天定时百度链接推送"></a>GitHub Actions 定时运行代码：每天定时百度链接推送</h1><p>GitHub Actions 是一个 CI&#x2F;CD（持续集成&#x2F;持续部署）工具，但也可用作代码运行环境。<strong>功能非常强大，能够玩出许多花样。</strong></p>
<span id="more"></span>

<h2 id="百度主动链接推送"><a href="#百度主动链接推送" class="headerlink" title="百度主动链接推送"></a>百度主动链接推送</h2><p>链接主动推送在百度站长中有介绍</p>
<p>具体使用方法就是创建一个文件<code>urls.txt</code>，文件内每行一条链接的格式写入提交的多个链接</p>
<p>运行命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl -H <span class="string">&#x27;Content-Type:text/plain&#x27;</span> --data-binary @urls.txt <span class="string">&quot;http://data.zz.baidu.com/urls?site=xxx.com&amp;token=T5PEAzhG*****&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面命令的地址和参数由百度站长提供。运行完命令会返回推送结果，不出意外的话就会把<code>urls.txt</code>内的所有链接一次性推送给百度。</p>
<p>这个方法虽然比嵌入网站头部的自动推送更高效，但是也有它的麻烦之处，就是得自己填入链接到<code>urls.txt</code>文件，然后手动运行命令。</p>
<h2 id="自动生成urls-txt"><a href="#自动生成urls-txt" class="headerlink" title="自动生成urls.txt"></a>自动生成urls.txt</h2><p>没关系，技术的本质就是让人”偷懒”的。于是，我写了一个nodejs工具，用于把所有的博客页面链接生成到<code>urls.txt</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// baiduPush.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成百度链接推送文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> logger = <span class="built_in">require</span>(<span class="string">&#x27;tracer&#x27;</span>).<span class="title function_">colorConsole</span>();</span><br><span class="line"><span class="keyword">const</span> matter = <span class="built_in">require</span>(<span class="string">&#x27;gray-matter&#x27;</span>); <span class="comment">// FrontMatter解析器 https://github.com/jonschlinkert/gray-matter</span></span><br><span class="line"><span class="keyword">const</span> readFileList = <span class="built_in">require</span>(<span class="string">&#x27;./modules/readFileList&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> urlsRoot = path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;urls.txt&#x27;</span>); <span class="comment">// 百度链接推送文件</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">DOMAIN</span> = process.<span class="property">argv</span>.<span class="title function_">splice</span>(<span class="number">2</span>)[<span class="number">0</span>]; <span class="comment">// 获取命令行传入的参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="variable constant_">DOMAIN</span>) &#123;</span><br><span class="line">  logger.<span class="title function_">error</span>(<span class="string">&#x27;请在运行此文件时指定一个你要进行百度推送的域名参数，例：node utils/baiduPush.js https://xxx.com&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">main</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  fs.<span class="title function_">writeFileSync</span>(urlsRoot, <span class="variable constant_">DOMAIN</span>)</span><br><span class="line">  <span class="keyword">const</span> files = <span class="title function_">readFileList</span>(); <span class="comment">// 读取所有md文件数据</span></span><br><span class="line"></span><br><span class="line">  files.<span class="title function_">forEach</span>( <span class="function"><span class="params">file</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; data &#125; = <span class="title function_">matter</span>(fs.<span class="title function_">readFileSync</span>(file.<span class="property">filePath</span>, <span class="string">&#x27;utf8&#x27;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data.<span class="property">permalink</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> link = <span class="string">`\r\n<span class="subst">$&#123;DOMAIN&#125;</span><span class="subst">$&#123;data.permalink&#125;</span>/`</span>;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(link)</span><br><span class="line">      fs.<span class="title function_">appendFileSync</span>(urlsRoot, link);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码仅是针对我个人的博客生成链接到<code>urls.txt</code>文件。</p>
<p>运行如下命令就可以生产一个包含博客所有链接的<code>urls.txt</code>文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">node utils/baiduPush.js https://xxx.com</span><br></pre></td></tr></table></figure>
<p>哈哈，第一个麻烦解决了:smirk:，接下来是解决第二个需要手动运行推送命令的问题。</p>
<blockquote>
<p><strong>如果你没办法自动生成，你也可以自己手动创建一个<code>urls.txt</code>文件，放到github仓库。</strong></p>
</blockquote>
<h2 id="GitHub-Actions-定时运行代码"><a href="#GitHub-Actions-定时运行代码" class="headerlink" title="GitHub Actions 定时运行代码"></a>GitHub Actions 定时运行代码</h2><p>今天的主角GitHub Actions 要登场了。（相关：<a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html?20191227113947#comment-last">GitHub Actions 入门教程</a></p>
<p>GitHub Actions 是一个 CI&#x2F;CD（持续集成&#x2F;持续部署）工具，但也可用作代码运行环境。<strong>功能非常强大，能够玩出许多花样。</strong></p>
<h3 id="配置-GitHub-Actions"><a href="#配置-GitHub-Actions" class="headerlink" title="配置 GitHub Actions"></a>配置 GitHub Actions</h3><p>触发 GitHub Actions 需要在项目仓库新建一个<code>.github/workflows</code>子目录，里面是 YAML 格式配置文件，文件名可以随便取。GitHub 只要发现配置文件，就会运行 Actions。</p>
<p>配置文件的第一部分是触发条件。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">## baiduPush.yml</span></span><br><span class="line">name: <span class="string">&#x27;baiduPush&#x27;</span></span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">  schedule:</span><br><span class="line">    - cron: <span class="string">&#x27;0 23 * * *&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>name</code>字段是配置文件的描述，<code>on</code>字段是触发条件。我们指定两种情况下触发，第一种是代码 Push 进仓库，第二种是<a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows#scheduled-events-schedule">定时任务</a>，每天在国际标准时间23点（北京时间+8，即早上7点）运行。</p>
<blockquote>
<p>定时设置看<a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows#scheduled-events-schedule">这里</a></p>
</blockquote>
<p>接着，就是运行流程。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">jobs</span>:</span><br><span class="line">  bot:</span><br><span class="line">    runs-on: ubuntu-latest <span class="comment"># 运行环境为最新版的Ubuntu</span></span><br><span class="line">    steps:</span><br><span class="line">      - name: <span class="string">&#x27;Checkout codes&#x27;</span> <span class="comment"># 步骤一，获取仓库代码</span></span><br><span class="line">        uses: actions/checkout@v1</span><br><span class="line">      - name: <span class="string">&#x27;Run baiduPush.sh&#x27;</span> <span class="comment"># 步骤二，执行sh命令文件</span></span><br><span class="line">        run: npm install &amp;&amp; npm run baiduPush <span class="comment"># 运行命令。（注意，运行目录是仓库根目录）</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，指定运行环境是最新的ubuntu，流程的第一步是从代码仓库获取代码，第二步运行两个命令，先安装项目依赖，再运行写在<code>package.json</code>的<code>baiduPush</code>命令。</p>
<h3 id="baiduPush命令在package-json配置"><a href="#baiduPush命令在package-json配置" class="headerlink" title="baiduPush命令在package.json配置"></a><code>baiduPush</code>命令在<code>package.json</code>配置</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">	<span class="string">&quot;baiduPush&quot;</span>: <span class="string">&quot;node utils/baiduPush.js https://xxx.com &amp;&amp; bash baiduPush.sh&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面脚本中在<code>node utils/baiduPush.js</code>的后面加入你的域名参数。运行此命令生成<code>urls.txt</code>文件，然后执行<code>baiduPush.sh</code>文件。</p>
<p>注意，在使用window系统时，请使用git bash命令窗运行上面的脚本。</p>
<blockquote>
<p><code>baiduPush</code>命令之所以没有放在<code>baiduPush.yml</code>的 run 里面是因为我想在本地也可以执行<code>npm run baiduPush</code>命令。</p>
</blockquote>
<h3 id="baiduPush-sh执行百度推送命令"><a href="#baiduPush-sh执行百度推送命令" class="headerlink" title="baiduPush.sh执行百度推送命令"></a><code>baiduPush.sh</code>执行百度推送命令</h3><p><code>baiduPush.sh</code>文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 百度链接推送</span></span><br><span class="line">curl -H <span class="string">&#x27;Content-Type:text/plain&#x27;</span> --data-binary @urls.txt <span class="string">&quot;http://data.zz.baidu.com/urls?site=https://xxx.com&amp;token=T5PEAzhGa*****&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf urls.txt <span class="comment"># 灭迹</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，把<code>urls.txt</code>文件中的所有链接一次性推送。</p>
<blockquote>
<p>baiduPush.sh内的命令之所以没有写在<code>package.json</code>是因为我觉得命令太长了，不方便阅读。</p>
</blockquote>
<p>写好配置，推送到仓库，就会在每天的早上7点钟，自动运行命令生成一个包含博客所有页面链接的<code>urls.txt</code>文件，并把所有链接一次性推送到百度。麻麻再也不用担心我的网站不被收录~~:kissing_heart: :kissing_heart: :kissing_heart:</p>
<p>在这个基础上可以扩展，使用GitHub Actions满足你自己的各种定时需求。</p>
<p>栗子：<a href="https://github.com/ytking/blog_admin/blob/master/.github/workflows/WeatherBot.yml">每天早上7点定时向邮箱推送天气预报</a></p>
]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
  </entry>
  <entry>
    <title>ES6面试理论知识点汇总</title>
    <url>/post/b7a64886691a/</url>
    <content><![CDATA[<h3 id="一、问：ES6-是什么，为什么要学习它，不学习-ES6-会怎么样"><a href="#一、问：ES6-是什么，为什么要学习它，不学习-ES6-会怎么样" class="headerlink" title="一、问：ES6 是什么，为什么要学习它，不学习 ES6 会怎么样?"></a>一、问：ES6 是什么，为什么要学习它，不学习 ES6 会怎么样?</h3><p>答：ES6 是新一代的 JS 语言标准，对分 JS 语言核心内容做了升级优化，规范了 JS 使用标准，新增了 JS 原生方法，使得 JS 使用更加规范，更加优雅，更适合大型应用的开发。学习 ES6 是成为专业前端正规军的必经之路。不学习 ES6 也可以写代码打鬼子，但是最多只能当个游击队长。</p>
<h3 id="二、问：ES5、ES6-和-ES2015-有什么区别"><a href="#二、问：ES5、ES6-和-ES2015-有什么区别" class="headerlink" title="二、问：ES5、ES6 和 ES2015 有什么区别?"></a>二、问：ES5、ES6 和 ES2015 有什么区别?</h3><p>答：ES2015 特指在 2015 年发布的新一代 JS 语言标准，ES6 泛指下一代 JS 语言标准，包含 ES2015、ES2016、ES2017、ES2018 等。现阶段在绝大部分场景下，ES2015 默认等同 ES6。ES5 泛指上一代语言标准。ES2015 可以理解为 ES5 和 ES6 的时间分界线。</p>
<h3 id="三、问：babel-是什么，有什么作用"><a href="#三、问：babel-是什么，有什么作用" class="headerlink" title="三、问：babel 是什么，有什么作用?"></a>三、问：babel 是什么，有什么作用?</h3><p>答：babel 是一个 ES6 转码器，可以将 ES6 代码转为 ES5 代码，以便兼容那些还没支持 ES6 的平台。</p>
<h3 id="四、问：let-有什么用，有了-var-为什么还要用-let？"><a href="#四、问：let-有什么用，有了-var-为什么还要用-let？" class="headerlink" title="四、问：let 有什么用，有了 var 为什么还要用 let？"></a>四、问：let 有什么用，有了 var 为什么还要用 let？</h3><p>答：在 ES6 之前，声明变量只能用 var，var 方式声明变量其实是很不合理的，准确的说，是因为 ES5 里面没有块级作用域是很不合理的，甚至可以说是一个语言层面的 bug(这也是很多 c++、java 开发人员看不懂，也瞧不起 JS 语言的劣势之一)。没有块级作用域会带来很多难以理解的问题，比如 for 循环 var 变量泄露，变量覆盖等问题。let 声明的变量<strong>拥有自己的块级作用域</strong>，且修复了 var 声明变量带来的<strong>变量提升问题</strong>。</p>
<h3 id="五、问：举一些-ES6-对-String-字符串类型做的常用升级优化"><a href="#五、问：举一些-ES6-对-String-字符串类型做的常用升级优化" class="headerlink" title="五、问：举一些 ES6 对 String 字符串类型做的常用升级优化?"></a>五、问：举一些 ES6 对 String 字符串类型做的常用升级优化?</h3><p>答：</p>
<h4 id="1、优化部分："><a href="#1、优化部分：" class="headerlink" title="1、优化部分："></a>1、优化部分：</h4><p>ES6 新增了字符串模板，在拼接大段字符串时，用反斜杠(&#96;)取代以往的字符串相加的形式，能保留所有空格和换行，使得字符串拼接看起来更加直观，更加优雅。</p>
<h4 id="2、升级部分"><a href="#2、升级部分" class="headerlink" title="2、升级部分:"></a>2、升级部分:</h4><p>ES6 在 String 原型上新增了 includes()方法，用于取代传统的只能用 indexOf 查找包含字符的方法(indexOf 返回-1 表示没查到不如 includes 方法返回 false 更明确，语义更清晰), 此外还新增了 startsWith(), endsWith(), padStart(),padEnd(),repeat()等方法，可方便的用于查找，补全字符串。</p>
<h3 id="六、问：举一些-ES6-对-Array-数组类型做的常用升级优化"><a href="#六、问：举一些-ES6-对-Array-数组类型做的常用升级优化" class="headerlink" title="六、问：举一些 ES6 对 Array 数组类型做的常用升级优化?"></a>六、问：举一些 ES6 对 Array 数组类型做的常用升级优化?</h3><p>答：</p>
<h4 id="1、优化部分：-1"><a href="#1、优化部分：-1" class="headerlink" title="1、优化部分："></a>1、优化部分：</h4><p><strong>a.</strong> 数组解构赋值。ES6 可以直接以<code>let [a,b,c] = [1,2,3]</code>形式进行变量赋值，在声明较多变量时，不用再写很多 let(var),且映射关系清晰，且支持赋默认值。</p>
<p><strong>b.</strong> 扩展运算符。ES6 新增的扩展运算符(…)(重要),可以轻松的实现数组和松散序列的相互转化，可以取代 arguments 对象和 apply 方法，轻松获取未知参数个数情况下的参数集合。（尤其是在 ES5 中，arguments 并不是一个真正的数组，而是一个类数组的对象，但是扩展运算符的逆运算却可以返回一个真正的数组）。扩展运算符还可以轻松方便的实现数组的复制和解构赋值（<code>let a = [2,3,4]; let b = [...a]</code>）。</p>
<h4 id="2、升级部分-1"><a href="#2、升级部分-1" class="headerlink" title="2、升级部分:"></a>2、升级部分:</h4><p>ES6 在 Array 原型上新增了 find()方法，用于取代传统的只能用 indexOf 查找包含数组项目的方法,且修复了 indexOf 查找不到 NaN 的 bug(<code>[NaN].indexOf(NaN) === -1</code>).此外还新增了 copyWithin(), includes(), fill(),flat()等方法，可方便的用于字符串的查找，补全,转换等。</p>
<h3 id="七、问：举一些-ES6-对-Number-数字类型做的常用升级优化"><a href="#七、问：举一些-ES6-对-Number-数字类型做的常用升级优化" class="headerlink" title="七、问：举一些 ES6 对 Number 数字类型做的常用升级优化?"></a>七、问：举一些 ES6 对 Number 数字类型做的常用升级优化?</h3><p>答：</p>
<h4 id="1、优化部分：-2"><a href="#1、优化部分：-2" class="headerlink" title="1、优化部分："></a>1、优化部分：</h4><p>ES6 在 Number 原型上新增了 isFinite(), isNaN()方法，用来取代传统的全局 isFinite(), isNaN()方法检测数值是否有限、是否是 NaN。ES5 的 isFinite(), isNaN()方法都会先将非数值类型的参数转化为 Number 类型再做判断，这其实是不合理的，最造成<code>isNaN(&#39;NaN&#39;) === true</code>的奇怪行为–’NaN’是一个字符串，但是 isNaN 却说这就是 NaN。而 Number.isFinite()和 Number.isNaN()则不会有此类问题(<code>Number.isNaN(&#39;NaN&#39;) === false</code>)。（isFinite()同上）</p>
<h4 id="2、升级部分-2"><a href="#2、升级部分-2" class="headerlink" title="2、升级部分:"></a>2、升级部分:</h4><p>ES6 在 Math 对象上新增了 Math.cbrt()，trunc()，hypot()等等较多的科学计数法运算方法，可以更加全面的进行立方根、求和立方根等等科学计算。</p>
<h3 id="八、问：举一些-ES6-对-Object-类型做的常用升级优化-重要"><a href="#八、问：举一些-ES6-对-Object-类型做的常用升级优化-重要" class="headerlink" title="八、问：举一些 ES6 对 Object 类型做的常用升级优化?(重要)"></a>八、问：举一些 ES6 对 Object 类型做的常用升级优化?(重要)</h3><p>答：</p>
<h4 id="1、优化部分：-3"><a href="#1、优化部分：-3" class="headerlink" title="1、优化部分："></a>1、优化部分：</h4><p><strong>a.</strong> 对象属性变量式声明。ES6 可以直接以变量形式声明对象属性或者方法，。比传统的键值对形式声明更加简洁，更加方便，语义更加清晰。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [apple, orange] = [<span class="string">&quot;red appe&quot;</span>, <span class="string">&quot;yellow orange&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> myFruits = &#123; apple, orange &#125;; <span class="comment">// let myFruits = &#123;apple: &#x27;red appe&#x27;, orange: &#x27;yellow orange&#x27;&#125;;</span></span><br></pre></td></tr></table></figure>

<p>尤其在对象解构赋值(见优化部分 b.)或者模块输出变量时，这种写法的好处体现的最为明显:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; keys, values, entries &#125; = <span class="title class_">Object</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">MyOwnMethods</span> = &#123; keys, values, entries &#125;; <span class="comment">// let MyOwnMethods = &#123;keys: keys, values: values, entries: entries&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看到属性变量式声明属性看起来更加简洁明了。方法也可以采用简洁写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> es5Fun = &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> es6Fun = &#123;</span><br><span class="line">  <span class="title function_">method</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>b.</strong> 对象的解构赋值。ES6 对象也可以像数组解构赋值那样，进行变量的解构赋值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; apple, orange &#125; = &#123; <span class="attr">apple</span>: <span class="string">&quot;red appe&quot;</span>, <span class="attr">orange</span>: <span class="string">&quot;yellow orange&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>c.</strong> 对象的扩展运算符(…)。ES6 对象的扩展运算符和数组扩展运算符用法本质上差别不大，毕竟数组也就是特殊的对象。对象的扩展运算符一个最常用也最好用的用处就在于可以轻松的取出一个目标对象内部全部或者部分的可遍历属性，从而进行对象的合并和分解。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; apple, orange, ...otherFruits &#125; = &#123;</span><br><span class="line">  <span class="attr">apple</span>: <span class="string">&quot;red apple&quot;</span>,</span><br><span class="line">  <span class="attr">orange</span>: <span class="string">&quot;yellow orange&quot;</span>,</span><br><span class="line">  <span class="attr">grape</span>: <span class="string">&quot;purple grape&quot;</span>,</span><br><span class="line">  <span class="attr">peach</span>: <span class="string">&quot;sweet peach&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// otherFruits  &#123;grape: &#x27;purple grape&#x27;, peach: &#x27;sweet peach&#x27;&#125;</span></span><br><span class="line"><span class="comment">// 注意: 对象的扩展运算符用在解构赋值时，扩展运算符只能用在最后一个参数(otherFruits后面不能再跟其他参数)</span></span><br><span class="line"><span class="keyword">let</span> moreFruits = &#123; <span class="attr">watermelon</span>: <span class="string">&quot;nice watermelon&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> allFruits = &#123; apple, orange, ...otherFruits, ...moreFruits &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>d.</strong> super 关键字。ES6 在 Class 类里新增了类似 this 的关键字 super。同 this 总是指向当前函数所在的对象不同，super 关键字总是指向当前函数所在对象的原型对象。</p>
<h4 id="2、升级部分-3"><a href="#2、升级部分-3" class="headerlink" title="2、升级部分:"></a>2、升级部分:</h4><p><strong>a.</strong> ES6 在 Object 原型上新增了 is()方法，做两个目标对象的相等比较，用来完善’&#x3D;&#x3D;&#x3D;’方法。’&#x3D;&#x3D;&#x3D;’方法中<code>NaN === NaN //false</code>其实是不合理的，Object.is 修复了这个小 bug。(<code>Object.is(NaN, NaN) // true</code>)</p>
<p><strong>b.</strong> ES6 在 Object 原型上新增了 assign()方法，用于对象新增属性或者多个对象合并。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source1, source2);</span><br><span class="line">target; <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意: assign 合并的对象 target 只能合并 source1、source2 中的自身属性，并不会合并 source1、source2 中的继承属性，也不会合并不可枚举的属性，且无法正确复制 get 和 set 属性（会直接执行 get&#x2F;set 函数，取 return 的值）。</p>
<p><strong>c.</strong> ES6 在 Object 原型上新增了 getOwnPropertyDescriptors()方法，此方法增强了 ES5 中 getOwnPropertyDescriptor()方法，可以获取指定对象所有自身属性的描述对象。结合 defineProperties()方法，可以完美复制对象，包括复制 get 和 set 属性。</p>
<p><strong>d.</strong> ES6 在 Object 原型上新增了 getPrototypeOf()和 setPrototypeOf()方法，用来获取或设置当前对象的 prototype 对象。这个方法存在的意义在于，ES5 中获取设置 prototype 对像是通过<strong>proto</strong>属性来实现的，然而<strong>proto</strong>属性并不是 ES 规范中的明文规定的属性，只是浏览器各大产商“私自”加上去的属性，只不过因为适用范围广而被默认使用了，再非浏览器环境中并不一定就可以使用，所以为了稳妥起见，获取或设置当前对象的 prototype 对象时，都应该采用 ES6 新增的标准用法。</p>
<p><strong>e.</strong> ES6 在 Object 原型上还新增了 Object.keys()，Object.values()，Object.entries()方法，用来获取对象的所有键、所有值和所有键值对数组。</p>
<h3 id="九、问：举一些-ES6-对-Function-函数类型做的常用升级优化-重要"><a href="#九、问：举一些-ES6-对-Function-函数类型做的常用升级优化-重要" class="headerlink" title="九、问：举一些 ES6 对 Function 函数类型做的常用升级优化?(重要)"></a>九、问：举一些 ES6 对 Function 函数类型做的常用升级优化?(重要)</h3><p>答：</p>
<h4 id="1、优化部分：-4"><a href="#1、优化部分：-4" class="headerlink" title="1、优化部分："></a>1、优化部分：</h4><p><strong>a.</strong> 箭头函数**(核心)**。箭头函数是 ES6 核心的升级项之一，箭头函数里没有自己的 this,这改变了以往 JS 函数中最让人难以理解的 this 运行机制。主要优化点:</p>
<p>Ⅰ. <strong>箭头函数内的 this 指向的是函数定义时所在的对象，而不是函数执行时所在的对象</strong>。ES5 函数里的 this 总是指向函数执行时所在的对象，这使得在很多情况下 this 的指向变得很难理解，尤其是非严格模式情况下，this 有时候会指向全局对象，这甚至也可以归结为语言层面的 bug 之一。ES6 的箭头函数优化了这一点，它的内部没有自己的 this,这也就导致了 this 总是指向上一层的 this，如果上一层还是箭头函数，则继续向上指，直到指向到有自己 this 的函数为止，并作为自己的 this。</p>
<p>Ⅱ. 箭头函数不能用作构造函数，因为它没有自己的 this，无法实例化。</p>
<p>Ⅲ. 也是因为箭头函数没有自己的 this,所以箭头函数 内也不存在 arguments 对象。（可以用扩展运算符代替）</p>
<p><strong>b.</strong> 函数默认赋值。ES6 之前，函数的形参是无法给默认值得，只能在函数内部通过变通方法实现。ES6 以更简洁更明确的方式进行函数默认赋值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">es6Fuc</span>(<span class="params">x, y = <span class="string">&quot;default&quot;</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">es6Fuc</span>(<span class="number">4</span>); <span class="comment">// 4, default</span></span><br></pre></td></tr></table></figure>

<h4 id="2、升级部分-4"><a href="#2、升级部分-4" class="headerlink" title="2、升级部分:"></a>2、升级部分:</h4><p>ES6 新增了双冒号运算符，用来取代以往的 bind，call,和 apply。(浏览器暂不支持，Babel 已经支持转码)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">foo</span>::bar;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">bar.<span class="title function_">bind</span>(foo);</span><br><span class="line"></span><br><span class="line"><span class="attr">foo</span>::<span class="title function_">bar</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">bar.<span class="title function_">apply</span>(foo, <span class="variable language_">arguments</span>);</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h3 id="十、问：Symbol-是什么，有什么作用？"><a href="#十、问：Symbol-是什么，有什么作用？" class="headerlink" title="十、问：Symbol 是什么，有什么作用？"></a>十、问：Symbol 是什么，有什么作用？</h3><p>答：Symbol 是 ES6 引入的第七种原始数据类型（说法不准确，应该是第七种数据类型，Object 不是原始数据类型之一，已更正），所有 Symbol()生成的值都是独一无二的，可以从根本上解决对象属性太多导致属性名冲突覆盖的问题。对象中 Symbol()属性不能被 for…in 遍历，但是也不是私有属性。</p>
<h3 id="十一、问：Set-是什么，有什么作用？"><a href="#十一、问：Set-是什么，有什么作用？" class="headerlink" title="十一、问：Set 是什么，有什么作用？"></a>十一、问：Set 是什么，有什么作用？</h3><p>答：Set 是 ES6 引入的一种类似 Array 的新的数据结构，Set 实例的成员类似于数组 item 成员，区别是 Set 实例的成员都是唯一，不重复的。这个特性可以轻松地实现数组去重。</p>
<h3 id="十二、问：Map-是什么，有什么作用？"><a href="#十二、问：Map-是什么，有什么作用？" class="headerlink" title="十二、问：Map 是什么，有什么作用？"></a>十二、问：Map 是什么，有什么作用？</h3><p>答：Map 是 ES6 引入的一种类似 Object 的新的数据结构，Map 可以理解为是 Object 的超集，打破了以传统键值对形式定义对象，对象的 key 不再局限于字符串，也可以是 Object。可以更加全面的描述对象的属性。</p>
<h3 id="十三、问：Proxy-是什么，有什么作用？"><a href="#十三、问：Proxy-是什么，有什么作用？" class="headerlink" title="十三、问：Proxy 是什么，有什么作用？"></a>十三、问：Proxy 是什么，有什么作用？</h3><p>答：Proxy 是 ES6 新增的一个构造函数，可以理解为 JS 语言的一个代理，用来改变 JS 默认的一些语言行为，包括拦截默认的 get&#x2F;set 等底层方法，使得 JS 的使用自由度更高，可以最大限度的满足开发者的需求。比如通过拦截对象的 get&#x2F;set 方法，可以轻松地定制自己想要的 key 或者 value。下面的例子可以看到，随便定义一个 myOwnObj 的 key,都可以变成自己想要的函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createMyOwnObj</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//想把所有的key都变成函数，或者Promise,或者anything</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="title function_">get</span>(<span class="params">target, propKey, receiver</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> randomBoolean = <span class="title class_">Math</span>.<span class="title function_">random</span>() &gt; <span class="number">0.5</span>;</span><br><span class="line">            <span class="keyword">let</span> <span class="title class_">Message</span>;</span><br><span class="line">            <span class="keyword">if</span> (randomBoolean) &#123;</span><br><span class="line">              <span class="title class_">Message</span> = <span class="string">`你的<span class="subst">$&#123;propKey&#125;</span>运气不错，成功了`</span>;</span><br><span class="line">              <span class="title function_">resolve</span>(<span class="title class_">Message</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="title class_">Message</span> = <span class="string">`你的<span class="subst">$&#123;propKey&#125;</span>运气不行，失败了`</span>;</span><br><span class="line">              <span class="title function_">reject</span>(<span class="title class_">Message</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">1000</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myOwnObj = <span class="title function_">createMyOwnObj</span>();</span><br><span class="line"></span><br><span class="line">myOwnObj.<span class="property">hahaha</span></span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">//你的hahaha运气不错，成功了</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error); <span class="comment">//你的hahaha运气不行，失败了</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">myOwnObj.<span class="property">wuwuwu</span></span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">//你的wuwuwu运气不错，成功了</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error); <span class="comment">//你的wuwuwu运气不行，失败了</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="十四、问：Reflect-是什么，有什么作用？"><a href="#十四、问：Reflect-是什么，有什么作用？" class="headerlink" title="十四、问：Reflect 是什么，有什么作用？"></a>十四、问：Reflect 是什么，有什么作用？</h3><p>答：Reflect 是 ES6 引入的一个新的对象，他的主要作用有两点，一是将原生的一些零散分布在 Object、Function 或者全局函数里的方法(如 apply、delete、get、set 等等)，统一整合到 Reflect 上，这样可以更加方便更加统一的管理一些原生 API。其次就是因为 Proxy 可以改写默认的原生 API，如果一旦原生 API 别改写可能就找不到了，所以 Reflect 也可以起到备份原生 API 的作用，使得即使原生 API 被改写了之后，也可以在被改写之后的 API 用上默认的 API。</p>
<h3 id="十五、问：Promise-是什么，有什么作用？"><a href="#十五、问：Promise-是什么，有什么作用？" class="headerlink" title="十五、问：Promise 是什么，有什么作用？"></a>十五、问：Promise 是什么，有什么作用？</h3><p>答：Promise 是 ES6 引入的一个新的对象，他的主要作用是用来解决 JS 异步机制里，回调机制产生的“回调地狱”。它并不是什么突破性的 API，只是封装了异步回调形式，使得异步回调可以写的更加优雅，可读性更高，而且可以链式调用。</p>
<p>附录：<a href="http://mp.weixin.qq.com/s?__biz=MzAxODE4MTEzMA==&mid=2650084846&idx=2&sn=df481aa2f00e749f8223782c069bb86a&chksm=83db888bb4ac019d839c04bf0751f013adeef8dd426c9882b5a0583abb276e52783367910125&scene=21#wechat_redirect">15 道 ES6 Promise 实战练习题</a></p>
<h3 id="十六、问：Iterator-是什么，有什么作用？-重要"><a href="#十六、问：Iterator-是什么，有什么作用？-重要" class="headerlink" title="十六、问：Iterator 是什么，有什么作用？(重要)"></a>十六、问：Iterator 是什么，有什么作用？(重要)</h3><p>答：Iterator 是 ES6 中一个很重要概念，它并不是对象，也不是任何一种数据类型。因为 ES6 新增了 Set、Map 类型，他们和 Array、Object 类型很像，Array、Object 都是可以遍历的，但是 Set、Map 都不能用 for 循环遍历，解决这个问题有两种方案，一种是为 Set、Map 单独新增一个用来遍历的 API，另一种是为 Set、Map、Array、Object 新增一个统一的遍历 API，显然，第二种更好，ES6 也就顺其自然的需要一种设计标准，来统一所有可遍历类型的遍历方式。Iterator 正是这样一种标准。或者说是一种规范理念。</p>
<p>就好像 JavaScript 是 ECMAScript 标准的一种具体实现一样，Iterator 标准的具体实现是 Iterator 遍历器。Iterator 标准规定，所有部署了 key 值为[Symbol.iterator]，且[Symbol.iterator]的 value 是标准的 Iterator 接口函数(标准的 Iterator 接口函数: 该函数必须返回一个对象，且对象中包含 next 方法，且执行 next()能返回包含 value&#x2F;done 属性的 Iterator 对象)的对象，都称之为可遍历对象，next()后返回的 Iterator 对象也就是 Iterator 遍历器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//obj就是可遍历的，因为它遵循了Iterator标准，且包含[Symbol.iterator]方法，方法函数也符合标准的Iterator接口规范。</span></span><br><span class="line"><span class="comment">//obj.[Symbol.iterator]() 就是Iterator遍历器</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">data</span>: [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>],</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; self.<span class="property">data</span>.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">value</span>: self.<span class="property">data</span>[index++],</span><br><span class="line">            <span class="attr">done</span>: <span class="literal">false</span>,</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ES6 给 Set、Map、Array、String 都加上了[Symbol.iterator]方法，且[Symbol.iterator]方法函数也符合标准的 Iterator 接口规范，所以 Set、Map、Array、String 默认都是可以遍历的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Array</span></span><br><span class="line"><span class="keyword">let</span> array = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>];</span><br><span class="line">array[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() <span class="comment">//Iterator遍历器</span></span><br><span class="line">array[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]().<span class="title function_">next</span>() <span class="comment">//&#123;value: &quot;red&quot;, done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//String</span></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">&#x27;1122334455&#x27;</span>;</span><br><span class="line">string[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() <span class="comment">//Iterator遍历器</span></span><br><span class="line">string[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]().<span class="title function_">next</span>() <span class="comment">//&#123;value: &quot;1&quot;, done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line">set[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() <span class="comment">//Iterator遍历器</span></span><br><span class="line">set[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]().<span class="title function_">next</span>() <span class="comment">//&#123;value: &quot;red&quot;, done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Map</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="keyword">let</span> obj= &#123;<span class="attr">map</span>: <span class="string">&#x27;map&#x27;</span>&#125;;</span><br><span class="line">map.<span class="title function_">set</span>(obj, <span class="string">&#x27;mapValue&#x27;</span>);</span><br><span class="line">map[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]().<span class="title function_">next</span>(<span class="params"></span>)  &#123;<span class="attr">value</span>: <span class="title class_">Array</span>(<span class="number">2</span>), <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="十七、问：for…in-和-for…of-有什么区别？"><a href="#十七、问：for…in-和-for…of-有什么区别？" class="headerlink" title="十七、问：for…in 和 for…of 有什么区别？"></a>十七、问：for…in 和 for…of 有什么区别？</h3><p>答：如果看到问题十六，那么就很好回答。问题十六提到了 ES6 统一了遍历标准，制定了可遍历对象，那么用什么方法去遍历呢？答案就是用 for…of。ES6 规定，有所部署了载了 Iterator 接口的对象(可遍历对象)都可以通过 for…of 去遍历，而 for..in 仅仅可以遍历对象。</p>
<p>这也就意味着，数组也可以用 for…of 遍历，这极大地方便了数组的取值，且避免了很多程序用 for..in 去遍历数组的恶习。</p>
<p>上面提到的扩展运算符本质上也就是 for..of 循环的一种实现。</p>
<h3 id="十八、Generator-函数是什么，有什么作用？"><a href="#十八、Generator-函数是什么，有什么作用？" class="headerlink" title="十八、Generator 函数是什么，有什么作用？"></a>十八、Generator 函数是什么，有什么作用？</h3><p>答：如果说 JavaScript 是 ECMAScript 标准的一种具体实现、Iterator 遍历器是 Iterator 的具体实现，那么 Generator 函数可以说是 Iterator 接口的具体实现方式。</p>
<p>执行 Generator 函数会返回一个遍历器对象，每一次 Generator 函数里面的 yield 都相当一次遍历器对象的 next()方法，并且可以通过 next(value)方法传入自定义的 value,来改变 Generator 函数的行为。</p>
<p>Generator 函数可以通过配合 Thunk 函数更轻松更优雅的实现异步编程和控制流管理。</p>
<h3 id="十九、async-函数是什么，有什么作用？"><a href="#十九、async-函数是什么，有什么作用？" class="headerlink" title="十九、async 函数是什么，有什么作用？"></a>十九、async 函数是什么，有什么作用？</h3><p>答：async 函数可以理解为内置自动执行器的 Generator 函数语法糖，它配合 ES6 的 Promise 近乎完美的实现了异步编程解决方案。</p>
<p>附录：<a href="http://mp.weixin.qq.com/s?__biz=MzAxODE4MTEzMA==&mid=2650079079&idx=2&sn=9eede14eaa71459e0854de70a44585d4&chksm=83da6202b4adeb1408232a8db0b3e6d470564fce73b63c4618d9e2303fec7ef34d8f33eb38cf&scene=21#wechat_redirect">手写 async await 的最简实现（20 行搞定）！阿里字节面试必考</a></p>
<h3 id="二十、Class、extends-是什么，有什么作用？"><a href="#二十、Class、extends-是什么，有什么作用？" class="headerlink" title="二十、Class、extends 是什么，有什么作用？"></a>二十、Class、extends 是什么，有什么作用？</h3><p>答：ES6 的 class 可以看作只是一个 ES5 生成实例对象的构造函数的语法糖。它参考了 java 语言，定义了一个类的概念，让对象原型写法更加清晰，对象实例化更像是一种面向对象编程。Class 类可以通过 extends 实现继承。它和 ES5 构造函数的不同点：</p>
<p><strong>a</strong>. 类的内部定义的所有方法，都是不可枚举的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">///ES5</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ES5Fun</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ES5Fun</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + <span class="variable language_">this</span>.<span class="property">x</span> + <span class="string">&quot;, &quot;</span> + <span class="variable language_">this</span>.<span class="property">y</span> + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">ES5Fun</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">p.<span class="title function_">toString</span>();</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">ES5Fun</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">//[&#x27;toString&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ES6Fun</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + <span class="variable language_">this</span>.<span class="property">x</span> + <span class="string">&quot;, &quot;</span> + <span class="variable language_">this</span>.<span class="property">y</span> + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">ES6Fun</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">//[]</span></span><br></pre></td></tr></table></figure>

<p><strong>b</strong>.ES6 的 class 类必须用 new 命令操作，而 ES5 的构造函数不用 new 也可以执行。</p>
<p><strong>c</strong>.ES6 的 class 类不存在变量提升，必须先定义 class 之后才能实例化，不像 ES5 中可以将构造函数写在实例化之后。</p>
<p><strong>d</strong>.ES5 的继承，实质是先创造子类的实例对象 this，然后再将父类的方法添加到 this 上面。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到 this 上面（所以必须先调用 super 方法），然后再用子类的构造函数修改 this。</p>
<h3 id="二十一、module、export、import-是什么，有什么作用？"><a href="#二十一、module、export、import-是什么，有什么作用？" class="headerlink" title="二十一、module、export、import 是什么，有什么作用？"></a>二十一、module、export、import 是什么，有什么作用？</h3><p>答：module、export、import 是 ES6 用来统一前端模块化方案的设计思路和实现方案。export、import 的出现统一了前端模块化的实现方案，整合规范了浏览器&#x2F;服务端的模块化方法，用来取代传统的 AMD&#x2F;CMD、requireJS、seaJS、commondJS 等等一系列前端模块不同的实现方案，使前端模块化更加统一规范，JS 也能更加能实现大型的应用程序开发。</p>
<p>import 引入的模块是静态加载（编译阶段加载）而不是动态加载（运行时加载）。</p>
<p>import 引入 export 导出的接口值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</p>
<h3 id="二十二、日常前端代码开发中，有哪些值得用-ES6-去改进的编程优化或者规范？"><a href="#二十二、日常前端代码开发中，有哪些值得用-ES6-去改进的编程优化或者规范？" class="headerlink" title="二十二、日常前端代码开发中，有哪些值得用 ES6 去改进的编程优化或者规范？"></a>二十二、日常前端代码开发中，有哪些值得用 ES6 去改进的编程优化或者规范？</h3><p>答：</p>
<ol>
<li>常用箭头函数来取代<code>var self = this;</code>的做法。</li>
<li>常用 let 取代 var 命令。</li>
<li>常用数组&#x2F;对象的结构赋值来命名变量，结构更清晰，语义更明确，可读性更好。</li>
<li>在长字符串多变量组合场合，用模板字符串来取代字符串累加，能取得更好地效果和阅读体验。</li>
<li>用 Class 类取代传统的构造函数，来生成实例化对象。</li>
<li>在大型应用开发中，要保持 module 模块化开发思维，分清模块之间的关系，常用 import、export 方法。</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>面试</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub Actions 实现自动部署静态博客</title>
    <url>/post/2a5926c022be/</url>
    <content><![CDATA[<h1 id="GitHub-Actions-实现自动部署静态博客"><a href="#GitHub-Actions-实现自动部署静态博客" class="headerlink" title="GitHub Actions 实现自动部署静态博客"></a>GitHub Actions 实现自动部署静态博客</h1><p>在了解GitHub Actions之后，尝试使用它发现能够满足我的需求。<a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html?20191227113947#comment-last">GitHub Actions 入门教程</a></p>
<h2 id="GitHub-Actions"><a href="#GitHub-Actions" class="headerlink" title="GitHub-Actions"></a>GitHub-Actions</h2><p>actions顾名思义就是一堆动作，是一个持续集成服务，持续集成包含了拉代码、运行测试、编译代码、登录远程服务器，发布到第三方服务等等的操作，GitHub将这些操作称为actions。</p>
<p><strong>概念：Workflows, Events, Jobs, Actions, Runners</strong></p>
<ul>
<li>Workflows 工作流</li>
</ul>
<p>一个 Workflow 由多个 Jobs 组成</p>
<ul>
<li>Events</li>
</ul>
<p>定义哪些事件可以触发 Workflow</p>
<ul>
<li>Jobs</li>
</ul>
<p>一条 Job 由多个 step 组成，每个步骤可以是一条可执行的 shell 脚本或者是一个 action</p>
<ul>
<li>Actions</li>
</ul>
<p>一个 Action 是一个复杂且重复的任务，可以看成是多个job的组合</p>
<ul>
<li>Runners</li>
</ul>
<p>跑工作流的 server，由 Github 提供<br>一个工作流可以由一个或者多个 Job 组成，每个 Job 可以由一个或者多个 Step 和 Action 组成。工作流需要被一个或多个 Event 触发，并由 Runner 执行，执行成功后，最终实现工作目标。</p>
<h3 id="一、建立仓库"><a href="#一、建立仓库" class="headerlink" title="一、建立仓库"></a>一、建立仓库</h3><p>首先在github上创建仓库，如果建立的仓库名称是username.github.io，则最后访问的地址username.github.io&#x2F;。 如果不是这个名称，则最后访问的地址是username.github.io&#x2F;repo&#x2F; ,repo就是仓库名字。</p>
<h3 id="二、添加-github相关配置文件"><a href="#二、添加-github相关配置文件" class="headerlink" title="二、添加.github相关配置文件"></a>二、添加.github相关配置文件</h3><p>在项目的根目录下新建.github&#x2F;workflows目录，workflow就是GitHub Actions 的配置文件。随便新建.yml文件就是一个flow，github会自动运行workflows目录下所有的yml文件。介绍下workflow最重要的几个配置和概念。</p>
<ul>
<li>name</li>
</ul>
<p>name字段是 workflow 的名称。如果省略该字段，默认为当前 workflow 的文件名</p>
<ul>
<li>on</li>
</ul>
<p>on字段指定触发 workflow 的条件，通常是某些事件。在本文实例里用的是push，指的就是当git  push事件发生时触发该workflow。</p>
<ul>
<li>jobs</li>
</ul>
<p>jobs是workflow最重要的部分，表示workflow要执行的任务，可以是一个或者多个。</p>
<p>接下里开始就是本文示例的部署内容。我们希望的流程是，本地改完代码，上传到github后能自动打包部署到gh-pages分支。<br>在项目根目录新建<code>.github/workflows/page.yml</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// workflows/pages.yml</span></span><br><span class="line"><span class="attr">name</span>: <span class="title class_">Deploy</span> <span class="title class_">Pages</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on</span>:</span><br><span class="line">  <span class="attr">push</span>:</span><br><span class="line">    <span class="attr">branches</span>:</span><br><span class="line">      - master # 这里只配置了master分支，所以只有推送master分支才会触发以下任务</span><br><span class="line"></span><br><span class="line"><span class="attr">jobs</span>:</span><br><span class="line">  <span class="attr">pages</span>:</span><br><span class="line">    runs-<span class="attr">on</span>: ubuntu-latest</span><br><span class="line">    <span class="attr">permissions</span>:</span><br><span class="line">      <span class="attr">contents</span>: write</span><br><span class="line">    <span class="attr">steps</span>:</span><br><span class="line">      - <span class="attr">uses</span>: actions/checkout@v2</span><br><span class="line">      - <span class="attr">name</span>: <span class="title class_">Use</span> <span class="title class_">Node</span>.<span class="property">js</span> <span class="number">16.15</span><span class="number">.0</span></span><br><span class="line">        <span class="attr">uses</span>: actions/setup-node@v2</span><br><span class="line">        <span class="attr">with</span>:</span><br><span class="line">          node-<span class="attr">version</span>: <span class="string">&quot;16.x&quot;</span></span><br><span class="line">      - <span class="attr">name</span>: <span class="title class_">Cache</span> <span class="variable constant_">NPM</span> dependencies</span><br><span class="line">        <span class="attr">uses</span>: actions/cache@v2</span><br><span class="line">        <span class="attr">with</span>:</span><br><span class="line">          <span class="attr">path</span>: node_modules</span><br><span class="line">          <span class="attr">key</span>: $&#123;&#123; runner.<span class="property">OS</span> &#125;&#125;-npm-cache</span><br><span class="line">          restore-<span class="attr">keys</span>: |</span><br><span class="line">            $&#123;&#123; runner.<span class="property">OS</span> &#125;&#125;-npm-cache</span><br><span class="line">      - <span class="attr">name</span>: <span class="title class_">Install</span> <span class="title class_">Dependencies</span></span><br><span class="line">        <span class="attr">run</span>: npm install</span><br><span class="line">      - <span class="attr">name</span>: <span class="title class_">Build</span></span><br><span class="line">        <span class="attr">run</span>: npm run build</span><br><span class="line">      - <span class="attr">name</span>: <span class="title class_">Deploy</span></span><br><span class="line">        <span class="attr">uses</span>: peaceiris/actions-gh-pages@v3</span><br><span class="line">        <span class="attr">with</span>:</span><br><span class="line">          <span class="attr">github_token</span>: $&#123;&#123; secrets.<span class="property">GITEE_TOKEN</span> &#125;&#125;</span><br><span class="line">          <span class="attr">publish_dir</span>: ./dist</span><br></pre></td></tr></table></figure>
<p>首先job里配置运行这个脚本需要的虚拟机环境，这个虚拟机环境由github提供，可用的包括windows、linux、macos等环境，具体看官方文档。在此示例中其实不论哪个系统都是可以的，因为我们需要的是node环境，而node本身就是跨平台的。<br>接下里设置获取源码、需要的node版本、增加缓存依赖，这里使用官方提供的actions&#x2F;setup-node@v1、setup-node@v1、cache@v2。这里的@表示版本，使用别人的action时最好都加上版本，以防后面更新的action不兼容当前的脚本。最后会自动部署到gh-pages分支，因为要更新github代码，所以还需要配置<code>github_token</code>。github获取token<a href="https://help.github.com/zh/articles/creating-a-personal-access-token-for-the-command-line">官方文档</a><br><img src="https://img-blog.csdnimg.cn/75e3f0c43b8f4e5892c23144295f5656.png" alt="在这里插入图片描述"><br>我这里写的是<code>GITEE_TOKEN</code>,名字随便写都行，手动配置不能以GITHUB_xxx开头。变量和yml里的<code>github_token</code>保持一致。<br>&#x3D;&#x3D;GITEE_TOKEN：复制下面的token配置在仓库<code>GITEE_TOKEN</code>变量里面&#x3D;&#x3D;</p>
<p><img src="https://img-blog.csdnimg.cn/1e3d8beda6d24c109c3bd1967b9eb846.png" alt="在这里插入图片描述"><br>配置也可以这样写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">github_token</span>: $&#123;&#123; secrets.<span class="property">GITHUB_TOKEN</span> &#125;&#125; </span><br><span class="line"><span class="comment">//请注意这里的，GITHUB_TOKEN令牌不是个人访问令牌。github操作运行时会自动创建一个GITHUB_TOKEN 令牌秘密,以在您的工作流中进行身份验证。</span></span><br><span class="line"><span class="comment">//因此，您可以立即开始部署，而无需进行任何配置。 </span></span><br></pre></td></tr></table></figure>
<h3 id="三、推送代码，"><a href="#三、推送代码，" class="headerlink" title="三、推送代码，"></a>三、推送代码，</h3><p>打开 Github 仓库 Actions 标签页，可以看到workflow 已经开始执行。<br><img src="https://img-blog.csdnimg.cn/82e6a71e184c4839b858e3b4e17b21cd.png" alt="在这里插入图片描述"></p>
<p>执行完成后，发现多了一个 gh-pages 分支。</p>
<p>设置 Settings&#x2F;Pages， 将 Source 设置为 gh-pages 分支并保存。等待两三分钟后，打开 Settings&#x2F;Pages 中提示的url，即可看到项目页面。</p>
<p>运行完后访问 username.github.io&#x2F;repo 就能看到部署后的效果了。<br>因为设置了on: push所以以后每当由代码 push 到 master 分支上，都会触发此工作流执行。</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>gitHub: <a href="https://github.com/ytking/ytking">https://github.com/ytking/ytking</a><br>github pages: <a href="https://ytking.github.io/ytking/">ytking.github.io&#x2F;ytking&#x2F;</a></p>
<p>有什么说的不对或者有疑问的，欢迎在下面留言交流~~</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html"><strong>GitHub Actions 入门教程-阮一峰</strong></a><br><a href="https://docs.github.com/zh/pages/getting-started-with-github-pages/using-custom-workflows-with-github-pages"><strong>Github Actions 官方文档</strong></a></p>
<p>Github Actions 是 Github 的持续集成服务，和 Gitlab 的 CI&#x2F;CD 如出一辙。</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="https://github.com/ytking/ytking.github.io/blob/master/.github/workflows/baiduPush.yml">《GitHub Actions 定时运行代码：每天定时百度链接推送》</a></p>
]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
  </entry>
  <entry>
    <title>GitHub高级搜索技巧</title>
    <url>/post/1aee7dab272b/</url>
    <content><![CDATA[<h1 id="GitHub高级搜索技巧"><a href="#GitHub高级搜索技巧" class="headerlink" title="GitHub高级搜索技巧"></a>GitHub高级搜索技巧</h1><p><code>in:name &lt;关键字&gt;</code><br> 仓库名称带关键字查询</p>
<p><code>in:description &lt;关键字&gt;</code><br> 仓库描述带关键字查询</p>
<p><code>in:readme &lt;关键字&gt;</code><br> README文件带关键字查询</p>
<span id="more"></span>


<p><code>stars(fork): &gt;(=) &lt;数字&gt; &lt;关键字&gt;</code><br> star或fork数大于(或等于)指定数字的带关键字查询</p>
<p><code>stars(fork): 10..20 &lt;关键词&gt;</code><br> star或fork数在10到20之间的带关键字查询</p>
<p><code>size:&gt;=5000 &lt;关键词&gt;</code><br> 限定仓库大于等于5000K的带关键字查询</p>
<p><code>pushed(created):&gt;2019-11-15 &lt;关键字&gt;</code><br> 更新 或 创建 日期在2019年11月16日之后的带关键字查询</p>
<p><code>license:apache-2.0 &lt;关键字&gt;</code><br> LICENSE为apache-2.0的带关键字查询</p>
<p><code>language:java &lt;关键词&gt;</code><br> 仓库语言为Java的带关键字查询</p>
<p><code>user:&lt;用户名&gt;</code><br> 查询某个用户的项目</p>
<p><code>org:&lt;组织名&gt;</code><br> 查询某个组织的项目</p>
<p>*<strong>以上查询条件可组合使用，空格隔开</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例1：搜索仓库名包含javascript，并且stars数大于1000的项目</span></span><br><span class="line"><span class="keyword">in</span>:name javascript stars:&gt;1000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2：搜索描述中包含&quot;小程序&quot;，并且fork大于100，并且最近更新时间在2019-11-15之后的，并且使用开发语言为vue的项目</span></span><br><span class="line"><span class="keyword">in</span>:description 小程序 fork:&gt;100 pushed:&gt;2019-11-15 language:vue</span><br></pre></td></tr></table></figure>



<p>*<strong>或使用高级搜索页搜索：</strong></p>
<p><a href="https://github.com/search/advanced">https://github.com/search/advanced</a></p>
]]></content>
  </entry>
  <entry>
    <title>使用Intersection Observer API 检测元素是否出现在可视窗口</title>
    <url>/post/fc343de6adc7/</url>
    <content><![CDATA[<h1 id="使用Intersection-Observer-API-检测元素是否出现在可视窗口"><a href="#使用Intersection-Observer-API-检测元素是否出现在可视窗口" class="headerlink" title="使用Intersection Observer API 检测元素是否出现在可视窗口"></a>使用Intersection Observer API 检测元素是否出现在可视窗口</h1><h2 id="API解读："><a href="#API解读：" class="headerlink" title="API解读："></a>API解读：</h2><p>Intersection Observer API提供了一种<strong>异步</strong>检测目标元素与祖先元素或视口(可统称为根元素)相交情况变化的方法。</p>
<p>注意点：因为该 API 是<strong>异步</strong>的，它不会随着目标元素的滚动同步触发，而IntersectionObserver API是通过requestIdleCallback()实现，即只有浏览器空闲下来，才会执行观察器。</p>
<h2 id="Intersection-observer-的重要概念"><a href="#Intersection-observer-的重要概念" class="headerlink" title="Intersection observer 的重要概念"></a>Intersection observer 的重要概念</h2><p>Intersection observer API 有以下五个重要的概念：</p>
<ul>
<li>目标(target)元素 — 我们要监听的元素</li>
<li>根(root)元素 — 帮助我们判断目标元素是否符合条件的元素</li>
<li>以下两种情况根元素会默认为顶级文档的视口(一般为 html)。</li>
<li><ul>
<li>目标元素不是可滚动元素的后代且不传值时</li>
</ul>
</li>
<li><ul>
<li>指定根元素为 null</li>
</ul>
</li>
<li>交叉比(intersection ratio)—目标元素与根根的交集相对于目标元素百分比的表示(取值范围 0.0-1.0)。</li>
<li>阈值(threshold) — 回调函数触发的条件。</li>
<li>回调函数(callback) — 为该 API 配置的函数，会在设定的条件下触发。</li>
</ul>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>是以<code>new</code>的形式声明一个对象，接收两个参数<code>callback</code>和<code>options</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> io = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(callback [,options])</span><br><span class="line"></span><br><span class="line">io.<span class="title function_">observe</span>(<span class="variable constant_">DOM</span>)</span><br></pre></td></tr></table></figure>

<h3 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h3><p>callback是添加监听后，当监听目标发生滚动变化时触发的回调函数。接收一个参数entries，即IntersectionObserverEntry实例。描述了目标元素与root的交叉状态。具体参数如下：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boundingClientRect</td>
<td>返回包含目标元素的边界信息，返回结果与element.getBoundingClientRect() 相同</td>
</tr>
<tr>
<td><strong>intersectionRatio</strong></td>
<td>返回目标元素出现在可视区的比例</td>
</tr>
<tr>
<td>intersectionRect</td>
<td>用来描述root和目标元素的相交区域</td>
</tr>
<tr>
<td><strong>isIntersecting</strong></td>
<td>返回一个布尔值，下列两种操作均会触发callback：1. 如果目标元素出现在root可视区，返回true。2. 如果从root可视区消失，返回false</td>
</tr>
<tr>
<td>rootBounds</td>
<td>用来描述交叉区域观察者(intersection observer)中的根.</td>
</tr>
<tr>
<td>target</td>
<td>目标元素：与根出现相交区域改变的元素 (Element)</td>
</tr>
<tr>
<td>time</td>
<td>返回一个记录从 IntersectionObserver 的时间原点到交叉被触发的时间的时间戳</td>
</tr>
</tbody></table>
<p>表格中加粗的两个属性是比较常用的判断条件：isIntersecting(是否出现在可视区)和intersectionRatio(出现在可视区的比例)</p>
<h3 id="options"><a href="#options" class="headerlink" title="options"></a>options</h3><p>options是一个对象，用来配置参数，也可以不填。共有三个属性，具体如下：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>root</td>
<td>所监听对象的具体祖先元素。如果未传入值或值为null，则默认使用顶级文档的视窗(一般为html)。</td>
</tr>
<tr>
<td>rootMargin</td>
<td>计算交叉时添加到根(root)边界盒bounding box的矩形偏移量， 可以有效的缩小或扩大根的判定范围从而满足计算需要。所有的偏移量均可用像素(px)或百分比(%)来表达, 默认值为”0px 0px 0px 0px”。</td>
</tr>
<tr>
<td>threshold</td>
<td>一个包含阈值的列表, 按升序排列, 列表中的每个阈值都是监听对象的交叉区域与边界区域的比率。当监听对象的任何阈值被越过时，都会触发callback。默认值为0。</td>
</tr>
</tbody></table>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>介绍了这么多配置项及参数，差点忘了最重要的，IntersectionObserver有哪些方法？ 如果要监听某些元素，则必须要对该元素执行一下observe</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>observe()</td>
<td>开始监听一个目标元素</td>
</tr>
<tr>
<td>unobserve()</td>
<td>停止监听特定目标元素</td>
</tr>
<tr>
<td>takeRecords()</td>
<td>返回所有观察目标的IntersectionObserverEntry对象数组</td>
</tr>
<tr>
<td>disconnect()</td>
<td>使IntersectionObserver对象停止全部监听工作</td>
</tr>
</tbody></table>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><ul>
<li>图片懒加载<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> imgList = [...<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;img&#x27;</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> io = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(<span class="function">(<span class="params">entries</span>) =&gt;</span>&#123;</span><br><span class="line">  entries.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// isIntersecting是一个Boolean值，判断目标元素当前是否可见</span></span><br><span class="line">    <span class="keyword">if</span> (item.<span class="property">isIntersecting</span>) &#123;</span><br><span class="line">      item.<span class="property">target</span>.<span class="property">src</span> = item.<span class="property">target</span>.<span class="property">dataset</span>.<span class="property">src</span></span><br><span class="line">      <span class="comment">// 图片加载后即停止监听该元素</span></span><br><span class="line">      io.<span class="title function_">unobserve</span>(item.<span class="property">target</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// observe遍历监听所有img节点</span></span><br><span class="line">imgList.<span class="title function_">forEach</span>(<span class="function"><span class="params">img</span> =&gt;</span> io.<span class="title function_">observe</span>(img))</span><br></pre></td></tr></table></figure></li>
<li>埋点曝光</li>
</ul>
<p>假如有个需求，对一个页面中的特定元素，只有在其完全显示在可视区内时进行埋点曝光。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> boxList = [...<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;li&#x27;</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> io = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(<span class="function">(<span class="params">entries</span>) =&gt;</span>&#123;</span><br><span class="line">  entries.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// intersectionRatio === 1说明该元素完全暴露出来，符合业务需求</span></span><br><span class="line">    <span class="keyword">if</span> (item.<span class="property">intersectionRatio</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 。。。 埋点曝光代码</span></span><br><span class="line">      <span class="comment">// do something...</span></span><br><span class="line">      io.<span class="title function_">unobserve</span>(item.<span class="property">target</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  <span class="attr">root</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">threshold</span>: <span class="number">1</span>, <span class="comment">// 阀值设为1，当只有比例达到1时才触发回调函数</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// observe遍历监听所有box节点</span></span><br><span class="line">boxList.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> io.<span class="title function_">observe</span>(item))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>demo:</li>
</ul>
<p>大家可以在自己电脑运行一下下面的代码，会有更深的理解。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>IntersectionObserver<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      <span class="selector-tag">li</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">height</span>: <span class="number">400px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">border</span>: <span class="number">1px</span> solid gray;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>1-aaa<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>2-bbb<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>3i-ccc<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>4i<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>5i<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>6i<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>7i<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>8i<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>9i<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>10i<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>l1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>l2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>l3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>l4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>l5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>l6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>l7<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>l8<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>l9<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>10<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>21<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>22<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>23<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>24<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>25<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>26<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>27<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>28<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>29<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>30<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">const</span> imgList = [...<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;li&quot;</span>)];</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">const</span> options = &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">root</span>: <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">rootMargin</span>: <span class="string">&quot;1px&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">thresholds</span>: <span class="number">1</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">//io 为 IntersectionObserver对象 - 由IntersectionObserver()构造器创建</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">const</span> io = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(<span class="function">(<span class="params">entries</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//entries 为 IntersectionObserverEntry对像数组</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        entries.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="comment">//item 为 IntersectionObserverEntry对像</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="comment">// item.isIntersecting是一个Boolean值，判断目标元素当前是否可见</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="keyword">if</span> (item.<span class="property">isIntersecting</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="comment">// item.target.src = item.target.dataset.src;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="comment">// li加载后即停止监听该元素</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            io.<span class="title function_">unobserve</span>(item.<span class="property">target</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="comment">// intersectionRatio === 1说明该元素完全暴露出来</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="comment">// if (item.intersectionRatio === 1) &#123;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="comment">//   埋点曝光代码</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="comment">//   do something...</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="comment">//   停止监听该元素</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="comment">//   io.unobserve(item.target);</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="comment">// &#125;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;, options); <span class="comment">//不传options参数，默认根元素为浏览器视口</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// observe遍历监听所有li节点</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      imgList.<span class="title function_">forEach</span>(<span class="function">(<span class="params">li</span>) =&gt;</span> io.<span class="title function_">observe</span>(li));</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="关于如何判断元素是否在可视区域内的其他方法"><a href="#关于如何判断元素是否在可视区域内的其他方法" class="headerlink" title="关于如何判断元素是否在可视区域内的其他方法"></a>关于如何判断元素是否在可视区域内的其他方法</h1><p><img src="https://xiaojinhe-cdn.iyoudui.cn/upload/common/20231026/img1026.png" alt="本地路径"> </p>
<h3 id="第一种方法：offsetTop、scrollTop"><a href="#第一种方法：offsetTop、scrollTop" class="headerlink" title="第一种方法：offsetTop、scrollTop"></a>第一种方法：offsetTop、scrollTop</h3><p>公式: el.offsetTop - document.documentElement.scrollTop &lt;&#x3D; viewPortHeight</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isInViewPortOfOne</span> (el) &#123;</span><br><span class="line">    <span class="comment">// viewPortHeight 兼容所有浏览器写法</span></span><br><span class="line">    <span class="keyword">const</span> viewPortHeight = <span class="variable language_">window</span>.<span class="property">innerHeight</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span> || <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientHeight</span> </span><br><span class="line">    <span class="keyword">const</span> offsetTop = el.<span class="property">offsetTop</span></span><br><span class="line">    <span class="keyword">const</span> scrollTop = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span></span><br><span class="line">    <span class="keyword">const</span> top = offsetTop - scrollTop</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;top&#x27;</span>, top)</span><br><span class="line">     <span class="comment">// 这里有个+100是为了提前加载+ 100</span></span><br><span class="line">    <span class="keyword">return</span> top &lt;= viewPortHeight + <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="第二种方法：getBoundingClientRect"><a href="#第二种方法：getBoundingClientRect" class="headerlink" title="第二种方法：getBoundingClientRect"></a>第二种方法：getBoundingClientRect</h3><ul>
<li>返回值是一个 DOMRect 对象，拥有 left, top, right, bottom, x, y, width, 和 height 属性</li>
</ul>
<p>公式: el.getBoundingClientReact().top &lt;&#x3D; viewPortHeight</p>
<p>其实, el.offsetTop - document.documentElement.scrollTop &#x3D;  el.getBoundingClientRect().top, 利用这点，我们可以用下面代码代替方法一</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isInViewPortOfTwo</span> (el) &#123;</span><br><span class="line">    <span class="keyword">const</span> viewPortHeight = <span class="variable language_">window</span>.<span class="property">innerHeight</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span> || <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientHeight</span> </span><br><span class="line">    <span class="keyword">const</span> top = el.<span class="title function_">getBoundingClientRect</span>() &amp;&amp; el.<span class="title function_">getBoundingClientRect</span>().<span class="property">top</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;top&#x27;</span>, top)</span><br><span class="line">    <span class="keyword">return</span> top  &lt;= viewPortHeight + <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>JS 前端常用工具方法</title>
    <url>/post/ff1721fc7097/</url>
    <content><![CDATA[<h2 id="JS-前端常用工具方法"><a href="#JS-前端常用工具方法" class="headerlink" title="JS 前端常用工具方法"></a>JS 前端常用工具方法</h2><p>::: tip 提示<br>很实用的工具方法哦，建议收藏！:stuck_out_tongue_winking_eye:<br>:::</p>
<p>邮箱验证</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isEmail</span> = (<span class="params">s</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]&#123;2,3&#125;)&#123;1,2&#125;)$/</span>.<span class="title function_">test</span>(</span><br><span class="line">    s</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>手机号码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isMobile</span> = (<span class="params">s</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/^1[0-9]&#123;10&#125;$/</span>.<span class="title function_">test</span>(s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>电话号码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isPhone</span> = (<span class="params">s</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/^([0-9]&#123;3,4&#125;-)?[0-9]&#123;7,8&#125;$/</span>.<span class="title function_">test</span>(s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>是否 url 地址</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isURL</span> = (<span class="params">s</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/^http[s]?:\/\/.*/</span>.<span class="title function_">test</span>(s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>是否字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isString</span> = (<span class="params">o</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(o).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>) === <span class="string">&quot;String&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>数据类型检测</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span></span><br><span class="line">  .<span class="title function_">call</span>(data)</span><br><span class="line">  .<span class="title function_">replace</span>(<span class="regexp">/\[object (\w+)\]/</span>, <span class="string">&quot;$1&quot;</span>)</span><br><span class="line">  .<span class="title function_">toLowerCase</span>();</span><br></pre></td></tr></table></figure>

<p>打乱数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">shuffleArray</span> = (<span class="params">arr</span>) =&gt; arr.<span class="title function_">sort</span>(<span class="function">() =&gt;</span> <span class="number">0.5</span> - <span class="title class_">Math</span>.<span class="title function_">random</span>());</span><br></pre></td></tr></table></figure>

<p>是否函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isFunction</span> = (<span class="params">o</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(o).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>) === <span class="string">&quot;Function&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>是否错误对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isError</span> = (<span class="params">o</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(o).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>) === <span class="string">&quot;Error&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>是否是微信浏览器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isWeiXin</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> ua.<span class="title function_">match</span>(<span class="regexp">/microMessenger/i</span>) == <span class="string">&quot;micromessenger&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>是否是移动端</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isDeviceMobile</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/android|webos|iphone|ipod|balckberry/i</span>.<span class="title function_">test</span>(ua);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>是否是 QQ 浏览器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isQQBrowser</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> !!ua.<span class="title function_">match</span>(<span class="regexp">/mqqbrowser|qzone|qqbrowser|qbwebviewtype/i</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>是否是爬虫</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isSpider</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/adsbot|googlebot|bingbot|msnbot|yandexbot|baidubot|robot|careerbot|seznambot|bot|baiduspider|jikespider|symantecspider|scannerlwebcrawler|crawler|360spider|sosospider|sogou web sprider|sogou orion spider/</span>.<span class="title function_">test</span>(</span><br><span class="line">    ua</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>是否 ios</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isIos</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> u = navigator.<span class="property">userAgent</span>;</span><br><span class="line">  <span class="keyword">if</span> (u.<span class="title function_">indexOf</span>(<span class="string">&quot;Android&quot;</span>) &gt; -<span class="number">1</span> || u.<span class="title function_">indexOf</span>(<span class="string">&quot;Linux&quot;</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//安卓手机</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u.<span class="title function_">indexOf</span>(<span class="string">&quot;iPhone&quot;</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//苹果手机</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u.<span class="title function_">indexOf</span>(<span class="string">&quot;iPad&quot;</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//iPad</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u.<span class="title function_">indexOf</span>(<span class="string">&quot;Windows Phone&quot;</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//winphone手机</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>是否为 PC 端</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isPC</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> userAgentInfo = navigator.<span class="property">userAgent</span>;</span><br><span class="line">  <span class="keyword">var</span> <span class="title class_">Agents</span> = [</span><br><span class="line">    <span class="string">&quot;Android&quot;</span>,</span><br><span class="line">    <span class="string">&quot;iPhone&quot;</span>,</span><br><span class="line">    <span class="string">&quot;SymbianOS&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Windows Phone&quot;</span>,</span><br><span class="line">    <span class="string">&quot;iPad&quot;</span>,</span><br><span class="line">    <span class="string">&quot;iPod&quot;</span>,</span><br><span class="line">  ];</span><br><span class="line">  <span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> v = <span class="number">0</span>; v &lt; <span class="title class_">Agents</span>.<span class="property">length</span>; v++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (userAgentInfo.<span class="title function_">indexOf</span>(<span class="title class_">Agents</span>[v]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      flag = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>去除 html 标签</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">removeHtmltag</span> = (<span class="params">str</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> str.<span class="title function_">replace</span>(<span class="regexp">/&lt;[^&gt;]+&gt;/g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>获取 url 参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getQueryString</span> = (<span class="params">name</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;(^|&amp;)&quot;</span> + name + <span class="string">&quot;=([^&amp;]*)(&amp;|$)&quot;</span>, <span class="string">&quot;i&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> search = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">search</span>.<span class="title function_">split</span>(<span class="string">&quot;?&quot;</span>)[<span class="number">1</span>] || <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> r = search.<span class="title function_">match</span>(reg) || [];</span><br><span class="line">  <span class="keyword">return</span> r[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>动态引入 js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">injectScript</span> = (<span class="params">src</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> s = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">  s.<span class="property">type</span> = <span class="string">&quot;text/javascript&quot;</span>;</span><br><span class="line">  s.<span class="property">async</span> = <span class="literal">true</span>;</span><br><span class="line">  s.<span class="property">src</span> = src;</span><br><span class="line">  <span class="keyword">const</span> t = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;script&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">  t.<span class="property">parentNode</span>.<span class="title function_">insertBefore</span>(s, t);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>el 是否包含某个 class</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">hasClass</span> = (<span class="params">el, className</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;(^|\\s)&quot;</span> + className + <span class="string">&quot;(\\s|$)&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> reg.<span class="title function_">test</span>(el.<span class="property">className</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>获取滚动的坐标</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getScrollPosition</span> = (<span class="params">el = <span class="variable language_">window</span></span>) =&gt; (&#123;</span><br><span class="line">  <span class="attr">x</span>: el.<span class="property">pageXOffset</span> !== <span class="literal">undefined</span> ? el.<span class="property">pageXOffset</span> : el.<span class="property">scrollLeft</span>,</span><br><span class="line">  <span class="attr">y</span>: el.<span class="property">pageYOffset</span> !== <span class="literal">undefined</span> ? el.<span class="property">pageYOffset</span> : el.<span class="property">scrollTop</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>滚动到顶部</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">scrollToTop</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> c = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span> || <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span>;</span><br><span class="line">  <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(scrollToTop);</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">0</span>, c - c / <span class="number">8</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// window.scrollTo(0,0)</span></span><br></pre></td></tr></table></figure>

<p>el 是否在视口范围内</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">elementIsVisibleInViewport</span> = (<span class="params">el, partiallyVisible = <span class="literal">false</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; top, left, bottom, right &#125; = el.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line">  <span class="keyword">const</span> &#123; innerHeight, innerWidth &#125; = <span class="variable language_">window</span>;</span><br><span class="line">  <span class="keyword">return</span> partiallyVisible</span><br><span class="line">    ? ((top &gt; <span class="number">0</span> &amp;&amp; top &lt; innerHeight) ||</span><br><span class="line">        (bottom &gt; <span class="number">0</span> &amp;&amp; bottom &lt; innerHeight)) &amp;&amp;</span><br><span class="line">        ((left &gt; <span class="number">0</span> &amp;&amp; left &lt; innerWidth) || (right &gt; <span class="number">0</span> &amp;&amp; right &lt; innerWidth))</span><br><span class="line">    : top &gt;= <span class="number">0</span> &amp;&amp; left &gt;= <span class="number">0</span> &amp;&amp; bottom &lt;= innerHeight &amp;&amp; right &lt;= innerWidth;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>洗牌算法随机</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">shuffle</span> = (<span class="params">arr</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> result = [],</span><br><span class="line">    random;</span><br><span class="line">  <span class="keyword">while</span> (arr.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    random = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * arr.<span class="property">length</span>);</span><br><span class="line">    result.<span class="title function_">push</span>(arr[random]);</span><br><span class="line">    arr.<span class="title function_">splice</span>(random, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>判断类型集合</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">checkStr</span> = (<span class="params">str, type</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;phone&quot;</span>: <span class="comment">//手机号码</span></span><br><span class="line">      <span class="keyword">return</span> <span class="regexp">/^1[3|4|5|6|7|8|9][0-9]&#123;9&#125;$/</span>.<span class="title function_">test</span>(str);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;tel&quot;</span>: <span class="comment">//座机</span></span><br><span class="line">      <span class="keyword">return</span> <span class="regexp">/^(0\d&#123;2,3&#125;-\d&#123;7,8&#125;)(-\d&#123;1,4&#125;)?$/</span>.<span class="title function_">test</span>(str);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;card&quot;</span>: <span class="comment">//身份证</span></span><br><span class="line">      <span class="keyword">return</span> <span class="regexp">/(^\d&#123;15&#125;$)|(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)/</span>.<span class="title function_">test</span>(str);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;pwd&quot;</span>: <span class="comment">//密码以字母开头，长度在6~18之间，只能包含字母、数字和下划线</span></span><br><span class="line">      <span class="keyword">return</span> <span class="regexp">/^[a-zA-Z]\w&#123;5,17&#125;$/</span>.<span class="title function_">test</span>(str);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;postal&quot;</span>: <span class="comment">//邮政编码</span></span><br><span class="line">      <span class="keyword">return</span> <span class="regexp">/[1-9]\d&#123;5&#125;(?!\d)/</span>.<span class="title function_">test</span>(str);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;QQ&quot;</span>: <span class="comment">//QQ号</span></span><br><span class="line">      <span class="keyword">return</span> <span class="regexp">/^[1-9][0-9]&#123;4,9&#125;$/</span>.<span class="title function_">test</span>(str);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;email&quot;</span>: <span class="comment">//邮箱</span></span><br><span class="line">      <span class="keyword">return</span> <span class="regexp">/^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/</span>.<span class="title function_">test</span>(str);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;money&quot;</span>: <span class="comment">//金额(小数点2位)</span></span><br><span class="line">      <span class="keyword">return</span> <span class="regexp">/^\d*(?:\.\d&#123;0,2&#125;)?$/</span>.<span class="title function_">test</span>(str);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;URL&quot;</span>: <span class="comment">//网址</span></span><br><span class="line">      <span class="keyword">return</span> <span class="regexp">/(http|ftp|https):\/\/[\w\-_]+(\.[\w\-_]+)+([\w\-\.,@?^=%&amp;:/~\+#]*[\w\-\@?^=%&amp;/~\+#])?/</span>.<span class="title function_">test</span>(</span><br><span class="line">        str</span><br><span class="line">      );</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;IP&quot;</span>: <span class="comment">//IP</span></span><br><span class="line">      <span class="keyword">return</span> <span class="regexp">/((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))/</span>.<span class="title function_">test</span>(</span><br><span class="line">        str</span><br><span class="line">      );</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;date&quot;</span>: <span class="comment">//日期时间</span></span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="regexp">/^(\d&#123;4&#125;)\-(\d&#123;2&#125;)\-(\d&#123;2&#125;) (\d&#123;2&#125;)(?:\:\d&#123;2&#125;|:(\d&#123;2&#125;):(\d&#123;2&#125;))$/</span>.<span class="title function_">test</span>(</span><br><span class="line">          str</span><br><span class="line">        ) || <span class="regexp">/^(\d&#123;4&#125;)\-(\d&#123;2&#125;)\-(\d&#123;2&#125;)$/</span>.<span class="title function_">test</span>(str)</span><br><span class="line">      );</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;number&quot;</span>: <span class="comment">//数字</span></span><br><span class="line">      <span class="keyword">return</span> <span class="regexp">/^[0-9]$/</span>.<span class="title function_">test</span>(str);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;english&quot;</span>: <span class="comment">//英文</span></span><br><span class="line">      <span class="keyword">return</span> <span class="regexp">/^[a-zA-Z]+$/</span>.<span class="title function_">test</span>(str);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;chinese&quot;</span>: <span class="comment">//中文</span></span><br><span class="line">      <span class="keyword">return</span> <span class="regexp">/^[\\u4E00-\\u9FA5]+$/</span>.<span class="title function_">test</span>(str);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;lower&quot;</span>: <span class="comment">//小写</span></span><br><span class="line">      <span class="keyword">return</span> <span class="regexp">/^[a-z]+$/</span>.<span class="title function_">test</span>(str);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;upper&quot;</span>: <span class="comment">//大写</span></span><br><span class="line">      <span class="keyword">return</span> <span class="regexp">/^[A-Z]+$/</span>.<span class="title function_">test</span>(str);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;HTML&quot;</span>: <span class="comment">//HTML标记</span></span><br><span class="line">      <span class="keyword">return</span> <span class="regexp">/&lt;(&quot;[^&quot;]*&quot;|&#x27;[^&#x27;]*&#x27;|[^&#x27;&quot;&gt;])*&gt;/</span>.<span class="title function_">test</span>(str);</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>严格的身份证校验</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isCardID</span> = (<span class="params">sId</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="regexp">/(^\d&#123;15&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)/</span>.<span class="title function_">test</span>(sId)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;你输入的身份证长度或格式错误&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//身份证城市</span></span><br><span class="line">  <span class="keyword">var</span> aCity = &#123;</span><br><span class="line">    <span class="number">11</span>: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">    <span class="number">12</span>: <span class="string">&quot;天津&quot;</span>,</span><br><span class="line">    <span class="number">13</span>: <span class="string">&quot;河北&quot;</span>,</span><br><span class="line">    <span class="number">14</span>: <span class="string">&quot;山西&quot;</span>,</span><br><span class="line">    <span class="number">15</span>: <span class="string">&quot;内蒙古&quot;</span>,</span><br><span class="line">    <span class="number">21</span>: <span class="string">&quot;辽宁&quot;</span>,</span><br><span class="line">    <span class="number">22</span>: <span class="string">&quot;吉林&quot;</span>,</span><br><span class="line">    <span class="number">23</span>: <span class="string">&quot;黑龙江&quot;</span>,</span><br><span class="line">    <span class="number">31</span>: <span class="string">&quot;上海&quot;</span>,</span><br><span class="line">    <span class="number">32</span>: <span class="string">&quot;江苏&quot;</span>,</span><br><span class="line">    <span class="number">33</span>: <span class="string">&quot;浙江&quot;</span>,</span><br><span class="line">    <span class="number">34</span>: <span class="string">&quot;安徽&quot;</span>,</span><br><span class="line">    <span class="number">35</span>: <span class="string">&quot;福建&quot;</span>,</span><br><span class="line">    <span class="number">36</span>: <span class="string">&quot;江西&quot;</span>,</span><br><span class="line">    <span class="number">37</span>: <span class="string">&quot;山东&quot;</span>,</span><br><span class="line">    <span class="number">41</span>: <span class="string">&quot;河南&quot;</span>,</span><br><span class="line">    <span class="number">42</span>: <span class="string">&quot;湖北&quot;</span>,</span><br><span class="line">    <span class="number">43</span>: <span class="string">&quot;湖南&quot;</span>,</span><br><span class="line">    <span class="number">44</span>: <span class="string">&quot;广东&quot;</span>,</span><br><span class="line">    <span class="number">45</span>: <span class="string">&quot;广西&quot;</span>,</span><br><span class="line">    <span class="number">46</span>: <span class="string">&quot;海南&quot;</span>,</span><br><span class="line">    <span class="number">50</span>: <span class="string">&quot;重庆&quot;</span>,</span><br><span class="line">    <span class="number">51</span>: <span class="string">&quot;四川&quot;</span>,</span><br><span class="line">    <span class="number">52</span>: <span class="string">&quot;贵州&quot;</span>,</span><br><span class="line">    <span class="number">53</span>: <span class="string">&quot;云南&quot;</span>,</span><br><span class="line">    <span class="number">54</span>: <span class="string">&quot;西藏&quot;</span>,</span><br><span class="line">    <span class="number">61</span>: <span class="string">&quot;陕西&quot;</span>,</span><br><span class="line">    <span class="number">62</span>: <span class="string">&quot;甘肃&quot;</span>,</span><br><span class="line">    <span class="number">63</span>: <span class="string">&quot;青海&quot;</span>,</span><br><span class="line">    <span class="number">64</span>: <span class="string">&quot;宁夏&quot;</span>,</span><br><span class="line">    <span class="number">65</span>: <span class="string">&quot;新疆&quot;</span>,</span><br><span class="line">    <span class="number">71</span>: <span class="string">&quot;台湾&quot;</span>,</span><br><span class="line">    <span class="number">81</span>: <span class="string">&quot;香港&quot;</span>,</span><br><span class="line">    <span class="number">82</span>: <span class="string">&quot;澳门&quot;</span>,</span><br><span class="line">    <span class="number">91</span>: <span class="string">&quot;国外&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">if</span> (!aCity[<span class="built_in">parseInt</span>(sId.<span class="title function_">substr</span>(<span class="number">0</span>, <span class="number">2</span>))]) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;你的身份证地区非法&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出生日期验证</span></span><br><span class="line">  <span class="keyword">var</span> sBirthday = (</span><br><span class="line">      sId.<span class="title function_">substr</span>(<span class="number">6</span>, <span class="number">4</span>) +</span><br><span class="line">      <span class="string">&quot;-&quot;</span> +</span><br><span class="line">      <span class="title class_">Number</span>(sId.<span class="title function_">substr</span>(<span class="number">10</span>, <span class="number">2</span>)) +</span><br><span class="line">      <span class="string">&quot;-&quot;</span> +</span><br><span class="line">      <span class="title class_">Number</span>(sId.<span class="title function_">substr</span>(<span class="number">12</span>, <span class="number">2</span>))</span><br><span class="line">    ).<span class="title function_">replace</span>(<span class="regexp">/-/g</span>, <span class="string">&quot;/&quot;</span>),</span><br><span class="line">    d = <span class="keyword">new</span> <span class="title class_">Date</span>(sBirthday);</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    sBirthday !=</span><br><span class="line">    d.<span class="title function_">getFullYear</span>() + <span class="string">&quot;/&quot;</span> + (d.<span class="title function_">getMonth</span>() + <span class="number">1</span>) + <span class="string">&quot;/&quot;</span> + d.<span class="title function_">getDate</span>()</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;身份证上的出生日期非法&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 身份证号码校验</span></span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>,</span><br><span class="line">    weights = [<span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>],</span><br><span class="line">    codes = <span class="string">&quot;10X98765432&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; sId.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    sum += sId[i] * weights[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> last = codes[sum % <span class="number">11</span>]; <span class="comment">//计算出来的最后一位身份证号码</span></span><br><span class="line">  <span class="keyword">if</span> (sId[sId.<span class="property">length</span> - <span class="number">1</span>] != last) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;你输入的身份证号非法&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>将阿拉伯数字翻译成中文的大写数字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">numberToChinese</span> = (<span class="params">num</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="variable constant_">AA</span> = <span class="keyword">new</span> <span class="title class_">Array</span>(</span><br><span class="line">    <span class="string">&quot;零&quot;</span>,</span><br><span class="line">    <span class="string">&quot;一&quot;</span>,</span><br><span class="line">    <span class="string">&quot;二&quot;</span>,</span><br><span class="line">    <span class="string">&quot;三&quot;</span>,</span><br><span class="line">    <span class="string">&quot;四&quot;</span>,</span><br><span class="line">    <span class="string">&quot;五&quot;</span>,</span><br><span class="line">    <span class="string">&quot;六&quot;</span>,</span><br><span class="line">    <span class="string">&quot;七&quot;</span>,</span><br><span class="line">    <span class="string">&quot;八&quot;</span>,</span><br><span class="line">    <span class="string">&quot;九&quot;</span>,</span><br><span class="line">    <span class="string">&quot;十&quot;</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">var</span> <span class="variable constant_">BB</span> = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&quot;&quot;</span>, <span class="string">&quot;十&quot;</span>, <span class="string">&quot;百&quot;</span>, <span class="string">&quot;仟&quot;</span>, <span class="string">&quot;萬&quot;</span>, <span class="string">&quot;億&quot;</span>, <span class="string">&quot;点&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> a = (<span class="string">&quot;&quot;</span> + num).<span class="title function_">replace</span>(<span class="regexp">/(^0*)/g</span>, <span class="string">&quot;&quot;</span>).<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>),</span><br><span class="line">    k = <span class="number">0</span>,</span><br><span class="line">    re = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = a[<span class="number">0</span>].<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (k) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        re = <span class="variable constant_">BB</span>[<span class="number">7</span>] + re;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;0&#123;4&#125;//d&#123;&quot;</span> + (a[<span class="number">0</span>].<span class="property">length</span> - i - <span class="number">1</span>) + <span class="string">&quot;&#125;$&quot;</span>).<span class="title function_">test</span>(a[<span class="number">0</span>]))</span><br><span class="line">          re = <span class="variable constant_">BB</span>[<span class="number">4</span>] + re;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        re = <span class="variable constant_">BB</span>[<span class="number">5</span>] + re;</span><br><span class="line">        <span class="variable constant_">BB</span>[<span class="number">7</span>] = <span class="variable constant_">BB</span>[<span class="number">5</span>];</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k % <span class="number">4</span> == <span class="number">2</span> &amp;&amp; a[<span class="number">0</span>].<span class="title function_">charAt</span>(i + <span class="number">2</span>) != <span class="number">0</span> &amp;&amp; a[<span class="number">0</span>].<span class="title function_">charAt</span>(i + <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">      re = <span class="variable constant_">AA</span>[<span class="number">0</span>] + re;</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">0</span>].<span class="title function_">charAt</span>(i) != <span class="number">0</span>) re = <span class="variable constant_">AA</span>[a[<span class="number">0</span>].<span class="title function_">charAt</span>(i)] + <span class="variable constant_">BB</span>[k % <span class="number">4</span>] + re;</span><br><span class="line">    k++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (a.<span class="property">length</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 加上小数部分(如果有小数部分)</span></span><br><span class="line">    re += <span class="variable constant_">BB</span>[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a[<span class="number">1</span>].<span class="property">length</span>; i++) re += <span class="variable constant_">AA</span>[a[<span class="number">1</span>].<span class="title function_">charAt</span>(i)];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (re == <span class="string">&quot;一十&quot;</span>) re = <span class="string">&quot;十&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (re.<span class="title function_">match</span>(<span class="regexp">/^一/</span>) &amp;&amp; re.<span class="property">length</span> == <span class="number">3</span>) re = re.<span class="title function_">replace</span>(<span class="string">&quot;一&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> re;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>将数字转换为大写金额</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">changeToChinese</span> = (<span class="params">Num</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">//判断如果传递进来的不是字符的话转换为字符</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Num</span> == <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    <span class="title class_">Num</span> = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="title class_">Num</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">Num</span> = <span class="title class_">Num</span>.<span class="title function_">replace</span>(<span class="regexp">/,/g</span>, <span class="string">&quot;&quot;</span>); <span class="comment">//替换tomoney()中的“,”</span></span><br><span class="line">  <span class="title class_">Num</span> = <span class="title class_">Num</span>.<span class="title function_">replace</span>(<span class="regexp">/ /g</span>, <span class="string">&quot;&quot;</span>); <span class="comment">//替换tomoney()中的空格</span></span><br><span class="line">  <span class="title class_">Num</span> = <span class="title class_">Num</span>.<span class="title function_">replace</span>(<span class="regexp">/￥/g</span>, <span class="string">&quot;&quot;</span>); <span class="comment">//替换掉可能出现的￥字符</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isNaN</span>(<span class="title class_">Num</span>)) &#123;</span><br><span class="line">    <span class="comment">//验证输入的字符是否为数字</span></span><br><span class="line">    <span class="comment">//alert(&quot;请检查小写金额是否正确&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//字符处理完毕后开始转换，采用前后两部分分别转换</span></span><br><span class="line">  <span class="keyword">var</span> part = <span class="title class_">String</span>(<span class="title class_">Num</span>).<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> newchar = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="comment">//小数点前进行转化</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = part[<span class="number">0</span>].<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (part[<span class="number">0</span>].<span class="property">length</span> &gt; <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="comment">//若数量超过拾亿单位，提示</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> tmpnewchar = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> perchar = part[<span class="number">0</span>].<span class="title function_">charAt</span>(i);</span><br><span class="line">    <span class="keyword">switch</span> (perchar) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;0&quot;</span>:</span><br><span class="line">        tmpnewchar = <span class="string">&quot;零&quot;</span> + tmpnewchar;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;1&quot;</span>:</span><br><span class="line">        tmpnewchar = <span class="string">&quot;壹&quot;</span> + tmpnewchar;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;2&quot;</span>:</span><br><span class="line">        tmpnewchar = <span class="string">&quot;贰&quot;</span> + tmpnewchar;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;3&quot;</span>:</span><br><span class="line">        tmpnewchar = <span class="string">&quot;叁&quot;</span> + tmpnewchar;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;4&quot;</span>:</span><br><span class="line">        tmpnewchar = <span class="string">&quot;肆&quot;</span> + tmpnewchar;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;5&quot;</span>:</span><br><span class="line">        tmpnewchar = <span class="string">&quot;伍&quot;</span> + tmpnewchar;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;6&quot;</span>:</span><br><span class="line">        tmpnewchar = <span class="string">&quot;陆&quot;</span> + tmpnewchar;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;7&quot;</span>:</span><br><span class="line">        tmpnewchar = <span class="string">&quot;柒&quot;</span> + tmpnewchar;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;8&quot;</span>:</span><br><span class="line">        tmpnewchar = <span class="string">&quot;捌&quot;</span> + tmpnewchar;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;9&quot;</span>:</span><br><span class="line">        tmpnewchar = <span class="string">&quot;玖&quot;</span> + tmpnewchar;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (part[<span class="number">0</span>].<span class="property">length</span> - i - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        tmpnewchar = tmpnewchar + <span class="string">&quot;元&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> (perchar != <span class="number">0</span>) tmpnewchar = tmpnewchar + <span class="string">&quot;拾&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> (perchar != <span class="number">0</span>) tmpnewchar = tmpnewchar + <span class="string">&quot;佰&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">if</span> (perchar != <span class="number">0</span>) tmpnewchar = tmpnewchar + <span class="string">&quot;仟&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        tmpnewchar = tmpnewchar + <span class="string">&quot;万&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">if</span> (perchar != <span class="number">0</span>) tmpnewchar = tmpnewchar + <span class="string">&quot;拾&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">if</span> (perchar != <span class="number">0</span>) tmpnewchar = tmpnewchar + <span class="string">&quot;佰&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">if</span> (perchar != <span class="number">0</span>) tmpnewchar = tmpnewchar + <span class="string">&quot;仟&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        tmpnewchar = tmpnewchar + <span class="string">&quot;亿&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">        tmpnewchar = tmpnewchar + <span class="string">&quot;拾&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> newchar = tmpnewchar + newchar;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//小数点之后进行转化</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Num</span>.<span class="title function_">indexOf</span>(<span class="string">&quot;.&quot;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (part[<span class="number">1</span>].<span class="property">length</span> &gt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="comment">// alert(&quot;小数点之后只能保留两位,系统将自动截断&quot;);</span></span><br><span class="line">      part[<span class="number">1</span>] = part[<span class="number">1</span>].<span class="title function_">substr</span>(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; part[<span class="number">1</span>].<span class="property">length</span>; i++) &#123;</span><br><span class="line">      tmpnewchar = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      perchar = part[<span class="number">1</span>].<span class="title function_">charAt</span>(i);</span><br><span class="line">      <span class="keyword">switch</span> (perchar) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;0&quot;</span>:</span><br><span class="line">          tmpnewchar = <span class="string">&quot;零&quot;</span> + tmpnewchar;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;1&quot;</span>:</span><br><span class="line">          tmpnewchar = <span class="string">&quot;壹&quot;</span> + tmpnewchar;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;2&quot;</span>:</span><br><span class="line">          tmpnewchar = <span class="string">&quot;贰&quot;</span> + tmpnewchar;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;3&quot;</span>:</span><br><span class="line">          tmpnewchar = <span class="string">&quot;叁&quot;</span> + tmpnewchar;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;4&quot;</span>:</span><br><span class="line">          tmpnewchar = <span class="string">&quot;肆&quot;</span> + tmpnewchar;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;5&quot;</span>:</span><br><span class="line">          tmpnewchar = <span class="string">&quot;伍&quot;</span> + tmpnewchar;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;6&quot;</span>:</span><br><span class="line">          tmpnewchar = <span class="string">&quot;陆&quot;</span> + tmpnewchar;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;7&quot;</span>:</span><br><span class="line">          tmpnewchar = <span class="string">&quot;柒&quot;</span> + tmpnewchar;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;8&quot;</span>:</span><br><span class="line">          tmpnewchar = <span class="string">&quot;捌&quot;</span> + tmpnewchar;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;9&quot;</span>:</span><br><span class="line">          tmpnewchar = <span class="string">&quot;玖&quot;</span> + tmpnewchar;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">0</span>) tmpnewchar = tmpnewchar + <span class="string">&quot;角&quot;</span>;</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">1</span>) tmpnewchar = tmpnewchar + <span class="string">&quot;分&quot;</span>;</span><br><span class="line">      newchar = newchar + tmpnewchar;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//替换所有无用汉字</span></span><br><span class="line">  <span class="keyword">while</span> (newchar.<span class="title function_">search</span>(<span class="string">&quot;零零&quot;</span>) != -<span class="number">1</span>) newchar = newchar.<span class="title function_">replace</span>(<span class="string">&quot;零零&quot;</span>, <span class="string">&quot;零&quot;</span>);</span><br><span class="line">  newchar = newchar.<span class="title function_">replace</span>(<span class="string">&quot;零亿&quot;</span>, <span class="string">&quot;亿&quot;</span>);</span><br><span class="line">  newchar = newchar.<span class="title function_">replace</span>(<span class="string">&quot;亿万&quot;</span>, <span class="string">&quot;亿&quot;</span>);</span><br><span class="line">  newchar = newchar.<span class="title function_">replace</span>(<span class="string">&quot;零万&quot;</span>, <span class="string">&quot;万&quot;</span>);</span><br><span class="line">  newchar = newchar.<span class="title function_">replace</span>(<span class="string">&quot;零元&quot;</span>, <span class="string">&quot;元&quot;</span>);</span><br><span class="line">  newchar = newchar.<span class="title function_">replace</span>(<span class="string">&quot;零角&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  newchar = newchar.<span class="title function_">replace</span>(<span class="string">&quot;零分&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (newchar.<span class="title function_">charAt</span>(newchar.<span class="property">length</span> - <span class="number">1</span>) == <span class="string">&quot;元&quot;</span>) &#123;</span><br><span class="line">    newchar = newchar + <span class="string">&quot;整&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newchar;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>数组去重</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">unique</span> = (<span class="params">arr</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">indexOf</span>(item) === index;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>求两个集合的并集</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">union</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> newArr = a.<span class="title function_">concat</span>(b);</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">unique</span>(newArr);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>求两个集合的交集</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">intersect</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="variable language_">this</span>;</span><br><span class="line">  a = <span class="variable language_">this</span>.<span class="title function_">unique</span>(a);</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">map</span>(a, <span class="keyword">function</span> (<span class="params">o</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> _this.<span class="title function_">contains</span>(b, o) ? o : <span class="literal">null</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>将类数组转换为数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">formArray</span> = (<span class="params">ary</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> arr = [];</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(ary)) &#123;</span><br><span class="line">    arr = ary;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    arr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(ary);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>检测密码强度</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">checkPwd</span> = (<span class="params">str</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="title class_">Lv</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (str.<span class="property">length</span> &lt; <span class="number">6</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Lv</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="regexp">/[0-9]/</span>.<span class="title function_">test</span>(str)) &#123;</span><br><span class="line">    <span class="title class_">Lv</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="regexp">/[a-z]/</span>.<span class="title function_">test</span>(str)) &#123;</span><br><span class="line">    <span class="title class_">Lv</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="regexp">/[A-Z]/</span>.<span class="title function_">test</span>(str)) &#123;</span><br><span class="line">    <span class="title class_">Lv</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="regexp">/[\.|-|_]/</span>.<span class="title function_">test</span>(str)) &#123;</span><br><span class="line">    <span class="title class_">Lv</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Lv</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>节流</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//节流：单位时间内—只响应第一次</span></span><br><span class="line"><span class="comment">// 时间戳版</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">throttle</span> = (<span class="params">fn, timer = <span class="number">500</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> preTime = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> nowTime = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">    <span class="keyword">if</span> (nowTime - preTime &gt; timer) &#123;</span><br><span class="line">      <span class="comment">// fn.apply(this, arguments);</span></span><br><span class="line">      fn.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...<span class="variable language_">arguments</span>);</span><br><span class="line">      preTime = nowTime;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定时器版</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">      timeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        func.<span class="title function_">apply</span>(context, args)</span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>防抖</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//防抖：单位时间内-只响应最后一次</span></span><br><span class="line"><span class="comment">// 延时执行</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 立即防抖(先执行一遍)</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">      <span class="keyword">var</span> callNow = !timer</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        timer = <span class="literal">null</span></span><br><span class="line">      &#125;, delay)</span><br><span class="line">      <span class="keyword">if</span> (callNow) <span class="title function_">func</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>判断两个对象是否键值相同</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isObjectEqual</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> aProps = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(a);</span><br><span class="line">  <span class="keyword">var</span> bProps = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(b);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (aProps.<span class="property">length</span> !== bProps.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; aProps.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> propName = aProps[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a[propName] !== b[propName]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>16 进制颜色转 RGBRGBA 字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">colorToRGB</span> = (<span class="params">val, opa</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> pattern = <span class="regexp">/^(#?)[a-fA-F0-9]&#123;6&#125;$/</span>; <span class="comment">//16进制颜色值校验规则</span></span><br><span class="line">  <span class="keyword">var</span> isOpa = <span class="keyword">typeof</span> opa == <span class="string">&quot;number&quot;</span>; <span class="comment">//判断是否有设置不透明度</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!pattern.<span class="title function_">test</span>(val)) &#123;</span><br><span class="line">    <span class="comment">//如果值不符合规则返回空字符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> v = val.<span class="title function_">replace</span>(<span class="regexp">/#/</span>, <span class="string">&quot;&quot;</span>); <span class="comment">//如果有#号先去除#号</span></span><br><span class="line">  <span class="keyword">var</span> rgbArr = [];</span><br><span class="line">  <span class="keyword">var</span> rgbStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = v.<span class="title function_">substring</span>(i * <span class="number">2</span>, i * <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">var</span> num = <span class="built_in">parseInt</span>(item, <span class="number">16</span>);</span><br><span class="line">    rgbArr.<span class="title function_">push</span>(num);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  rgbStr = rgbArr.<span class="title function_">join</span>();</span><br><span class="line">  rgbStr =</span><br><span class="line">    <span class="string">&quot;rgb&quot;</span> + (isOpa ? <span class="string">&quot;a&quot;</span> : <span class="string">&quot;&quot;</span>) + <span class="string">&quot;(&quot;</span> + rgbStr + (isOpa ? <span class="string">&quot;,&quot;</span> + opa : <span class="string">&quot;&quot;</span>) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> rgbStr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>生成随机颜色</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*随机获取颜色*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getRandomColor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> r = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">256</span>);</span><br><span class="line">  <span class="keyword">var</span> g = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">256</span>);</span><br><span class="line">  <span class="keyword">var</span> b = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">256</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;rgb(&quot;</span> + r + <span class="string">&quot;,&quot;</span> + g + <span class="string">&quot;,&quot;</span> + b + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">  <span class="comment">//return &#x27;#&#x27; + Math.floor(Math.random() * 0xffffff).toString(16);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>颜色 RGB 转 16 进制</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">rgbToHex</span> = (<span class="params">r, g, b</span>) =&gt;</span><br><span class="line">  <span class="string">&quot;#&quot;</span> + ((<span class="number">1</span> &lt;&lt; <span class="number">24</span>) + (r &lt;&lt; <span class="number">16</span>) + (g &lt;&lt; <span class="number">8</span>) + b).<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">rgbToHex</span>(<span class="number">0</span>, <span class="number">51</span>, <span class="number">255</span>);</span><br><span class="line"><span class="comment">// Result: #0033ff</span></span><br></pre></td></tr></table></figure>

<p>计算 2 个日期之间相差多少天</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">dayDif</span> = (<span class="params">date1, date2</span>) =&gt;</span><br><span class="line">  <span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="title class_">Math</span>.<span class="title function_">abs</span>(date1.<span class="title function_">getTime</span>() - date2.<span class="title function_">getTime</span>()) / <span class="number">86400000</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">dayDif</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2020-10-21&quot;</span>), <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2021-10-22&quot;</span>));</span><br><span class="line"><span class="comment">// Result: 366</span></span><br></pre></td></tr></table></figure>

<p>校验数组是否为空</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">isNotEmpty</span> = (<span class="params">arr</span>) =&gt; <span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr) &amp;&amp; arr.<span class="property">length</span> &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">isNotEmpty</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">// Result: true</span></span><br></pre></td></tr></table></figure>

<p>检验车牌号</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">isCarNum</span>(<span class="params">val</span>) &#123;</span><br><span class="line">              <span class="keyword">var</span> patrn = <span class="regexp">/^([京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]&#123;1&#125;[A-Z]&#123;1&#125;[A-HJ-NP-Z0-9]&#123;4&#125;[A-HJ-NP-Z0-9挂学警港澳]&#123;1&#125;)$/</span>;</span><br><span class="line">              <span class="keyword">var</span> patrn2 = <span class="regexp">/^([京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]&#123;1&#125;[A-Z]&#123;1&#125;(([0-9]&#123;5&#125;[DF])|([DF]([A-HJ-NP-Z0-9])[0-9]&#123;4&#125;)))$/</span>;</span><br><span class="line">              <span class="keyword">if</span> (!patrn.<span class="title function_">test</span>(val) &amp;&amp; !patrn2.<span class="title function_">test</span>(val)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>utils</tag>
      </tags>
  </entry>
  <entry>
    <title>JS异步编程</title>
    <url>/post/0f1b1cae935f/</url>
    <content><![CDATA[<h2 id="JS异步发展历程"><a href="#JS异步发展历程" class="headerlink" title="JS异步发展历程"></a>JS异步发展历程</h2><p>知其然知其所以然，首先了解三个概念：</p>
<p><strong>1.什么是同步？</strong></p>
<p>所谓同步，就是在发出一个”调用”时，在没有得到结果之前，该“调用”就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由“调用者”主动等待这个“调用”的结果。此调用执行完之前，阻塞之后的代码执行。</p>
<p><strong>2.什么是异步？</strong></p>
<p>“调用”在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在”调用”发出后，”被调用者”通过状态、通知来通知调用者，或通过回调函数处理这个调用。异步调用发出后，不影响后面代码的执行。</p>
<p><strong>3.JavaScript 中为什么需要异步？</strong></p>
<p>首先我们知道JavaScript是单线程的(即使新增了webworker，但是本质上JS还是单线程)。同步代码意味着什么呢？意味着有可能会阻塞，当我们有一个任务需要时间较长时，如果使用同步方式，那么就会阻塞之后的代码执行。而异步则不会，我们不会等待异步代码的之后，继续执行异步任务之后的代码。</p>
<p>概念了解完了，我们就要进入今天的正题了。首先大家思考一下：平时在工作中，主要使用了哪些异步解决方案，这些异步方案有什么优缺点？</p>
<p>异步最早的解决方案是回调函数，如事件的回调，setInterval&#x2F;setTimeout中的回调。但是回调函数有一个很常见的问题，就是回调地狱的问题(稍后会举例说明);</p>
<p>为了解决回调地狱的问题，社区提出了Promise解决方案，ES6将其写进了语言标准。Promise一定程度上解决了回调地狱的问题，但是Promise也存在一些问题，如错误不能被try catch，而且使用Promise的链式调用，其实并没有从根本上解决回调地狱的问题，只是换了一种写法。</p>
<p>ES6中引入 Generator 函数，Generator是一种异步编程解决方案，Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权，Generator 函数可以看出是异步任务的容器，需要暂停的地方，都用yield语句注明。但是 Generator 使用起来较为复杂。</p>
<p>ES7又提出了新的异步解决方案:async&#x2F;await，async是 Generator 函数的语法糖，async&#x2F;await 使得异步代码看起来像同步代码，异步编程发展的目标就是让异步逻辑的代码看起来像同步一样。</p>
<div class="tabs" id="test1"><ul class="nav-tabs no-default"></ul><div class="tab-contents"></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>

<h4 id="1-callback"><a href="#1-callback" class="headerlink" title="1.callback"></a>1.callback</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//node读取文件</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(xxx, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>回调函数的使用场景(包括但不限于):</p>
<ul>
<li>事件回调</li>
<li>Node API</li>
<li>setTimeout&#x2F;setInterval中的回调函数</li>
<li>ajax 请求</li>
</ul>
<p>回调函数的优点: 简单。</p>
<p>回调函数的缺点：</p>
<p>异步回调嵌套会导致代码难以维护，并且不方便统一处理错误，不能 try catch 和 回调地狱(如先读取A文本内容，再根据A文本内容读取B再根据B的内容读取C…)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(A, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(B, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">        fs.<span class="title function_">readFile</span>(C, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">            fs.<span class="title function_">readFile</span>(D, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">                <span class="comment">//....</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="2-Promise"><a href="#2-Promise" class="headerlink" title="2.Promise"></a>2.Promise</h3><p>Promise 一定程度上解决了回调地狱的问题，Promise 最早由社区提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。</p>
<p>那么我们看看Promise是如何解决回调地狱问题的，仍然以上文的readFile 为例(先读取A文本内容，再根据A文本内容读取B再根据B的内容读取C)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">read</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        fs.<span class="title function_">readFile</span>(url, <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(err) <span class="title function_">reject</span>(err);</span><br><span class="line">            <span class="title function_">resolve</span>(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">read</span>(A).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">read</span>(B);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">read</span>(C);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">read</span>(D);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Promise 的优点:</p>
<ul>
<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果</li>
<li>可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数</li>
</ul>
<p>缺点:</p>
<ul>
<li>无法取消 Promise</li>
<li>当处于pending状态时，无法得知目前进展到哪一个阶段</li>
<li>错误不能被 try catch<br>假设有这样一个需求：读取A,B,C三个文件内容，都读取成功后，再输出最终的结果。在Promise之前，我们一般可以借助发布订阅模式去实现:</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pubsub = &#123;</span><br><span class="line">    <span class="attr">arry</span>: [],</span><br><span class="line">    <span class="title function_">emit</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">arry</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>());</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">on</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">arry</span>.<span class="title function_">push</span>(fn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = [];</span><br><span class="line">pubsub.<span class="title function_">on</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(data.<span class="property">length</span> === <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">fs.<span class="title function_">readFile</span>(A, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function">(<span class="params">err, value</span>) =&gt;</span> &#123;</span><br><span class="line">    data.<span class="title function_">push</span>(value);</span><br><span class="line">    pubsub.<span class="title function_">emit</span>();</span><br><span class="line">&#125;);</span><br><span class="line">fs.<span class="title function_">readFile</span>(B, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function">(<span class="params">err, value</span>) =&gt;</span> &#123;</span><br><span class="line">    data.<span class="title function_">push</span>(value);</span><br><span class="line">    pubsub.<span class="title function_">emit</span>();</span><br><span class="line">&#125;);</span><br><span class="line">fs.<span class="title function_">readFile</span>(C, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function">(<span class="params">err, value</span>) =&gt;</span> &#123;</span><br><span class="line">    data.<span class="title function_">push</span>(value);</span><br><span class="line">    pubsub.<span class="title function_">emit</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Promise给我们提供了 Promise.all 的方法，对于这个需求，我们可以使用 Promise.all 来实现。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 fs.readFile 包装成promise接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">read</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        fs.<span class="title function_">readFile</span>(url, <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(err) <span class="title function_">reject</span>(err);</span><br><span class="line">            <span class="title function_">resolve</span>(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 Promise</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 通过 Promise.all 可以实现多个异步并行执行，同一时刻获取最终结果的问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">    <span class="title function_">read</span>(A),</span><br><span class="line">    <span class="title function_">read</span>(B),</span><br><span class="line">    <span class="title function_">read</span>(C)</span><br><span class="line">]).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err));</span><br></pre></td></tr></table></figure>
<h3 id="3-Generator"><a href="#3-Generator" class="headerlink" title="3.Generator"></a>3.Generator</h3><p>Generator 函数是 ES6 提供的一种异步编程解决方案，整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用 yield 语句注明。</p>
<p>Generator 函数一般配合 yield 或 Promise 使用。Generator函数返回的是迭代器。对生成器和迭代器不了解的同学，请自行补习下基础。下面我们看一下 Generator 的简单使用:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">yield</span> <span class="number">111</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">    <span class="keyword">let</span> b = <span class="keyword">yield</span> <span class="number">222</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line">    <span class="keyword">let</span> c = <span class="keyword">yield</span> <span class="number">333</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(c);</span><br><span class="line">    <span class="keyword">let</span> d = <span class="keyword">yield</span> <span class="number">444</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> t = <span class="title function_">gen</span>();</span><br><span class="line"><span class="comment">//next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值</span></span><br><span class="line">t.<span class="title function_">next</span>(<span class="number">1</span>); <span class="comment">//第一次调用next函数时，传递的参数无效</span></span><br><span class="line">t.<span class="title function_">next</span>(<span class="number">2</span>); <span class="comment">//a输出2;</span></span><br><span class="line">t.<span class="title function_">next</span>(<span class="number">3</span>); <span class="comment">//b输出3; </span></span><br><span class="line">t.<span class="title function_">next</span>(<span class="number">4</span>); <span class="comment">//c输出4;</span></span><br><span class="line">t.<span class="title function_">next</span>(<span class="number">5</span>); <span class="comment">//d输出5;</span></span><br></pre></td></tr></table></figure>
<p>为了让大家更好的理解上面代码是如何执行的，我画了一张图，分别对应每一次的next方法调用:</p>
<p>仍然以上文的 readFile (先读取A文本内容，再根据A文本内容读取B再根据B的内容读取C)为例，使用 Generator + co库来实现:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">&#x27;co&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> bluebird = <span class="built_in">require</span>(<span class="string">&#x27;bluebird&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> readFile = bluebird.<span class="title function_">promisify</span>(fs.<span class="property">readFile</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">read</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">readFile</span>(A, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">readFile</span>(B, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">readFile</span>(C, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">co</span>(<span class="title function_">read</span>()).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Generator的缺点大约不用我说了，除非是找虐，不然一般不会直接使用 Generator 来解决异步的(当然也不排除是因为我不熟练)~~</p>
<h3 id="4-async-await"><a href="#4-async-await" class="headerlink" title="4.async&#x2F;await"></a>4.async&#x2F;await</h3><p>ES7中引入了 async&#x2F;await 概念。async 其实是一个语法糖，它的实现就是将 Generator函数和自动执行器（co），包装在一个函数中。</p>
<p>async&#x2F;await 的优点是代码清晰，不用像 Promise 写很多 then 链，就可以处理回调地狱的问题。并且错误可以被try catch。</p>
<p>仍然以上文的readFile (先读取A文本内容，再根据A文本内容读取B再根据B的内容读取C) 为例，使用 async&#x2F;await 来实现:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> bluebird = <span class="built_in">require</span>(<span class="string">&#x27;bluebird&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> readFile = bluebird.<span class="title function_">promisify</span>(fs.<span class="property">readFile</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">read</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">readFile</span>(A, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">readFile</span>(B, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">readFile</span>(C, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">read</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>使用 async&#x2F;await 实现此需求：读取A,B,C三个文件内容，都读取成功后，再输出最终的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">read</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        fs.<span class="title function_">readFile</span>(url, <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(err) <span class="title function_">reject</span>(err);</span><br><span class="line">            <span class="title function_">resolve</span>(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">readAsync</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">        <span class="title function_">read</span>(A),</span><br><span class="line">        <span class="title function_">read</span>(B),</span><br><span class="line">        <span class="title function_">read</span>(C)</span><br><span class="line">    ]);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">readAsync</span>().<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>所以JS的异步发展史，可以认为是从 callback -&gt; promise -&gt; generator -&gt; async&#x2F;await。async&#x2F;await 使得异步代码看起来像同步代码，异步编程发展的目标就是让异步逻辑的代码看起来像同步一样。</p>
<p>因本人水平有限，文中内容未必百分百正确，如有不对的地方，请给我留言，谢谢。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS数字精度丢失的问题</title>
    <url>/post/67dc59a2dbf1/</url>
    <content><![CDATA[<h2 id="一、场景复现"><a href="#一、场景复现" class="headerlink" title="一、场景复现"></a>一、场景复现</h2><blockquote>
<p>JS数字精度丢失的一些常见问题</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加法 =====================</span></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span> <span class="comment">// false</span></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> = <span class="number">0.30000000000000004</span></span><br><span class="line"><span class="number">0.7</span> + <span class="number">0.1</span> = <span class="number">0.7999999999999999</span></span><br><span class="line"><span class="number">0.2</span> + <span class="number">0.4</span> = <span class="number">0.6000000000000001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 减法 =====================</span></span><br><span class="line"><span class="number">1.5</span> - <span class="number">1.2</span> = <span class="number">0.30000000000000004</span></span><br><span class="line"><span class="number">0.3</span> - <span class="number">0.2</span> = <span class="number">0.09999999999999998</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 乘法 =====================</span></span><br><span class="line"><span class="number">19.9</span> * <span class="number">100</span> = <span class="number">1989.9999999999998</span></span><br><span class="line"><span class="number">0.8</span> * <span class="number">3</span> = <span class="number">2.4000000000000004</span></span><br><span class="line"><span class="number">35.41</span> * <span class="number">100</span> = <span class="number">3540.9999999999995</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 除法 =====================</span></span><br><span class="line"><span class="number">0.3</span> / <span class="number">0.1</span> = <span class="number">2.9999999999999996</span></span><br><span class="line"><span class="number">0.69</span> / <span class="number">10</span> = <span class="number">0.06899999999999999</span></span><br></pre></td></tr></table></figure>

<p>为什么0.1 + 0.2 &#x3D;&#x3D;&#x3D; 0.3是false呢?</p>
<p>先看下面这个比喻</p>
<p>比如一个数 1÷3&#x3D;0.33333333……</p>
<p>3会一直无限循环，数学可以表示，但是计算机要存储，方便下次取出来再使用，但0.333333…… 这个数无限循环，再大的内存它也存不下，所以不能存储一个相对于数学来说的值，只能存储一个近似值，当计算机存储后再取出时就会出现精度丢失问题</p>
<blockquote>
<p>再看js里保留小数位tofixed()对于小数最后一位为5时进位不正确的问题</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.35</span>.<span class="title function_">toFixed</span>(<span class="number">1</span>) <span class="comment">// 1.4 正确</span></span><br><span class="line"><span class="number">1.335</span>.<span class="title function_">toFixed</span>(<span class="number">2</span>) <span class="comment">// 1.33  错误</span></span><br><span class="line"><span class="number">1.3335</span>.<span class="title function_">toFixed</span>(<span class="number">3</span>) <span class="comment">// 1.333 错误</span></span><br><span class="line"><span class="number">1.33335</span>.<span class="title function_">toFixed</span>(<span class="number">4</span>) <span class="comment">// 1.3334 正确</span></span><br><span class="line"><span class="number">1.333335</span>.<span class="title function_">toFixed</span>(<span class="number">5</span>)  <span class="comment">// 1.33333 错误</span></span><br><span class="line"><span class="number">1.3333335</span>.<span class="title function_">toFixed</span>(<span class="number">6</span>) <span class="comment">// 1.333333 错误</span></span><br></pre></td></tr></table></figure>
<p>可以看到，小数点位数为2，5时四舍五入是正确的，其它是错误。</p>
<p><strong>根本原因还是计算机里浮点数精度丢失的问题</strong></p>
<p>如：1.005.toFixed(2) 返回的是 1.00 而不是 1.01。</p>
<p>原因： 1.005 实际对应的数字是 1.00499999999999989，在四舍五入时全部被舍去</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.005</span>.<span class="title function_">toPrecision</span>(<span class="number">21</span>) <span class="comment">//1.00499999999999989342</span></span><br></pre></td></tr></table></figure>

<h2 id="二、浮点数"><a href="#二、浮点数" class="headerlink" title="二、浮点数"></a>二、浮点数</h2><p>“浮点数”是一种表示数字的标准，整数也可以用浮点数的格式来存储</p>
<p>我们也可以理解成，浮点数就是小数</p>
<p>在JavaScript中，现在主流的数值类型是Number，而Number采用的是IEEE754规范中64位双精度浮点数编码</p>
<p>这样的存储结构优点是可以归一化处理整数和小数，节省存储空间</p>
<p>对于一个整数，可以很轻易转化成十进制或者二进制。但是对于一个浮点数来说，因为小数点的存在，小数点的位置不是固定的。解决思路就是使用科学计数法，这样小数点位置就固定了</p>
<p>而计算机只能用二进制（0或1）表示，二进制转换为科学记数法的公式如下：</p>
<p>其中，a的值为0或者1，e为小数点移动的位置</p>
<p>举个例子：</p>
<p>27.0转化成二进制为11011.0 ，科学计数法表示为：</p>
<p><img src="https://camo.githubusercontent.com/12f207d2ee94ded7dfaaf7e7ca89966aae123735bbe544e411f7df3e63b0b1f8/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31623462313632302d383666342d313165622d616239302d6439616538313462323430642e706e67" alt="Alt text"></p>
<p>其中，a的值为0或者1，e为小数点移动的位置</p>
<p>举个例子：</p>
<p>27.0转化成二进制为11011.0 ，科学计数法表示为：</p>
<p><img src="https://camo.githubusercontent.com/c8ece8a9c352fe775bd4152606a148caf8b4de664e4fbc0d3d046bf492db8647/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33373030373039302d383666342d313165622d616239302d6439616538313462323430642e706e67" alt="Alt text"></p>
<p>前面讲到，javaScript存储方式是双精度浮点数，其长度为8个字节，即64位比特</p>
<p>64位比特又可分为三个部分：</p>
<p>符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数<br>指数位E：中间的 11 位存储指数（exponent），用来表示次方数，可以为正负数。在双精度浮点数中，指数的固定偏移量为1023<br>尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零<br>如下图所示：</p>
<p><img src="https://camo.githubusercontent.com/f19ec5ac0b29d0362429db14f835d79fef3fb569bd0e9cae6e57229aa8e3ba5c/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f34333064303130302d383666342d313165622d383566362d3666616337376330633962332e706e67" alt="Alt text"></p>
<p>举个例子：</p>
<p>27.5 转换为二进制11011.1</p>
<p>11011.1转换为科学记数法 [公式]</p>
<p>符号位为1(正数)，指数位为4+，1023+4，即1027</p>
<p>因为它是十进制的需要转换为二进制，即 10000000011，小数部分为10111，补够52位即： 1011 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000&#96;</p>
<p>所以27.5存储为计算机的二进制标准形式（符号位+指数位+小数部分 (阶数)），既下面所示</p>
<p>0+10000000011+011 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000&#96;</p>
<h2 id="二、问题分析"><a href="#二、问题分析" class="headerlink" title="二、问题分析"></a>二、问题分析</h2><p>再回到问题上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span> <span class="comment">// false</span></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> = <span class="number">0.30000000000000004</span></span><br></pre></td></tr></table></figure>

<p>通过上面的学习，我们知道，在javascript语言中，0.1 和 0.2 都需要先将十进制转化成二进制后再进行运算</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0.1 和 0.2 都转化成二进制后再进行运算</span></span><br><span class="line"><span class="number">0.00011001100110011001100110011001100110011001100110011010</span> +</span><br><span class="line"><span class="number">0.0011001100110011001100110011001100110011001100110011010</span> =</span><br><span class="line"><span class="number">0.0100110011001100110011001100110011001100110011001100111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转成十进制正好是 0.30000000000000004</span></span><br></pre></td></tr></table></figure>
<p>所以输出false</p>
<p>再来一个问题，那么为什么x&#x3D;0.1得到0.1？</p>
<p>主要是存储二进制时小数点的偏移量最大为52位，最多可以表达的位数是2^53&#x3D;9007199254740992，对应科学计数尾数是 9.007199254740992，这也是 JS 最多能表示的精度</p>
<p>它的长度是 16，所以可以使用 toPrecision(16) 来做精度运算，超过的精度会自动做凑整处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">.10000000000000000555</span>.<span class="title function_">toPrecision</span>(<span class="number">16</span>)</span><br><span class="line"><span class="comment">// 返回 0.1000000000000000，去掉末尾的零后正好为 0.1</span></span><br></pre></td></tr></table></figure>
<p>但看到的 0.1 实际上并不是 0.1。不信你可用更高的精度试试：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0.1</span>.<span class="title function_">toPrecision</span>(<span class="number">21</span>) = <span class="number">0.100000000000000005551</span></span><br></pre></td></tr></table></figure>
<p>如果整数大于 9007199254740992 会出现什么情况呢？</p>
<p>由于指数位最大值是1023，所以最大可以表示的整数是 2^1024 - 1，这就是能表示的最大整数。但你并不能这样计算这个数字，因为从 2^1024 开始就变成了 Infinity</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">1023</span>)</span><br><span class="line"><span class="number">8.98846567431158e+307</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">1024</span>)</span><br><span class="line"><span class="title class_">Infinity</span></span><br></pre></td></tr></table></figure>
<p>那么对于 (2^53, 2^63) 之间的数会出现什么情况呢？</p>
<ul>
<li>(2^53, 2^54) 之间的数会两个选一个，只能精确表示偶数</li>
<li>(2^54, 2^55) 之间的数会四个选一个，只能精确表示4个倍数</li>
<li>… 依次跳过更多2的倍数</li>
</ul>
<p>要想解决大数的问题你可以引用第三方库 bignumber.js，原理是把所有数字当作字符串，重新实现了计算逻辑，缺点是性能比原生差很多</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>计算机存储双精度浮点数需要先把十进制数转换为二进制的科学记数法的形式，然后计算机以自己的规则{符号位+(指数位+指数偏移量的二进制)+小数部分}存储二进制的科学记数法</p>
<p>因为存储时有位数限制（64位），并且某些十进制的浮点数在转换为二进制数时会出现无限循环，会造成二进制的舍入操作(0舍1入)，当再转换为十进制时就造成了计算误差</p>
<h2 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a>三、解决方案</h2><p>理论上用有限的空间来存储无限的小数是不可能保证精确的，但我们可以处理一下得到我们期望的结果</p>
<p>当你拿到 1.4000000000000001 这样的数据要展示时，建议使用 toPrecision 凑整并 parseFloat 转成数字后再显示，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="number">1.4000000000000001</span>.<span class="title function_">toPrecision</span>(<span class="number">12</span>)) === <span class="number">1.4</span>  <span class="comment">// True</span></span><br></pre></td></tr></table></figure>
<p>封装成方法就是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">strip</span>(<span class="params">num, precision = <span class="number">12</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> +<span class="built_in">parseFloat</span>(num.<span class="title function_">toPrecision</span>(precision));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于运算类操作，如 +-*&#x2F;，就不能使用 toPrecision 了。正确的做法是把小数转成整数后再运算(先扩大再缩小法)。</p>
<p>以加法为例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 精确加法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> num1Digits = (num1.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)[<span class="number">1</span>] || <span class="string">&#x27;&#x27;</span>).<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">const</span> num2Digits = (num2.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)[<span class="number">1</span>] || <span class="string">&#x27;&#x27;</span>).<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">const</span> baseNum = <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">10</span>, <span class="title class_">Math</span>.<span class="title function_">max</span>(num1Digits, num2Digits));</span><br><span class="line">  <span class="keyword">return</span> (num1 * baseNum + num2 * baseNum) / baseNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以toFixed()为例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先扩大再缩小法 </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toFixed</span>(<span class="params">num, s</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> times = <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">10</span>, s)</span><br><span class="line">    <span class="comment">// 0.5 为了舍入</span></span><br><span class="line">    <span class="keyword">var</span> des = num * times + <span class="number">0.5</span></span><br><span class="line">    <span class="comment">// 去除小数</span></span><br><span class="line">    des = <span class="built_in">parseInt</span>(des, <span class="number">10</span>) / times</span><br><span class="line">    <span class="keyword">return</span> des + <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">toFixed</span>(<span class="number">1.333332</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<p>最后还可以使用第三方库，如<a href="https://mathjs.org/">Math.js</a>、BigDecimal.js</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://www.bookstack.cn/read/javascript-tutorial/docs-types-number.md">数值-阮一峰</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS正则表达式的使用</title>
    <url>/post/43f1f7cbd836/</url>
    <content><![CDATA[<p>正则表达式用来处理字符串特别好用，在JavaScript中能用到正则表达式的地方有很多，本文对正则表达式基础知识和Javascript中正则表达式的使用做一个总结。</p>
<p>第一部分简单列举了正则表达式在JavaScript中的使用场景；第二部分详细介绍正则表达式的基础知识，写出一些例子方便理解。</p>
<p>本文的内容是我自己看完正则表达式写法，和犀牛书中js正则表达式的章节后的总结，所以内容可能会有疏漏和不严谨的地方。若有大神路过发现文中错误的地方，欢迎斧正！</p>
<h1 id="Javascript中正则表达式的使用"><a href="#Javascript中正则表达式的使用" class="headerlink" title="Javascript中正则表达式的使用"></a>Javascript中正则表达式的使用</h1><p>一个正则表达式可以认为是对一种字符片段的特征描述，而它的作用就是从一堆字符串中找出满足条件的子字符串。比如我在JavaScript中定义一个正则表达式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg=<span class="regexp">/hello/</span>    或者  <span class="keyword">var</span> reg=<span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>那么这个正则表达式可以用来从一堆字符串中找出 hello 这个单词。而“找出”这个动作，其结果可能是找出第一个hello的位置、用别的字符串替换hello、找出所有hello等等。下面就列举一下JavaScript中可以使用正则表达式的函数，简单介绍一下这些函数的作用，更复杂的用法会在第二部分中介绍。</p>
<h2 id="String-prototype-search方法"><a href="#String-prototype-search方法" class="headerlink" title="String.prototype.search方法"></a>String.prototype.search方法</h2><p>用来找出原字符串中某个子字符串首次出现的index，没有则返回-1</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;abchello&quot;</span>.<span class="title function_">search</span>(<span class="regexp">/hello/</span>);  <span class="comment">//  3</span></span><br></pre></td></tr></table></figure>

<h2 id="String-prototype-replace方法"><a href="#String-prototype-replace方法" class="headerlink" title="String.prototype.replace方法"></a>String.prototype.replace方法</h2><p>用来替换字符串中的子串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;abchello&quot;</span>.<span class="title function_">replace</span>(<span class="regexp">/hello/</span>,<span class="string">&quot;hi&quot;</span>);   <span class="comment">//  &quot;abchi&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="String-prototype-split方法"><a href="#String-prototype-split方法" class="headerlink" title="String.prototype.split方法"></a>String.prototype.split方法</h2><p>用来分割字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;abchelloasdasdhelloasd&quot;</span>.<span class="title function_">split</span>(<span class="regexp">/hello/</span>);  <span class="comment">//[&quot;abc&quot;, &quot;asdasd&quot;, &quot;asd&quot;]</span></span><br></pre></td></tr></table></figure>

<h2 id="String-prototype-match方法"><a href="#String-prototype-match方法" class="headerlink" title="String.prototype.match方法"></a>String.prototype.match方法</h2><p>用来捕获字符串中的子字符串到一个数组中。默认情况下只捕获一个结果到数组中，正则表达式有”全局捕获“的属性时(定义正则表达式的时候添加参数g)，会捕获所有结果到数组中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;abchelloasdasdhelloasd&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/hello/</span>);  <span class="comment">//[&quot;hello&quot;]</span></span><br><span class="line"><span class="string">&quot;abchelloasdasdhelloasd&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/hello/g</span>);  <span class="comment">//[&quot;hello&quot;,&quot;hello&quot;]</span></span><br></pre></td></tr></table></figure>

<p>作为match参数的正则表达式在是否拥有全局属性的情况下，match方法的表现还不一样，这一点会在后边的正则表达式分组中讲到。</p>
<h2 id="RegExp-prototype-test方法"><a href="#RegExp-prototype-test方法" class="headerlink" title="RegExp.prototype.test方法"></a>RegExp.prototype.test方法</h2><p>用来测试字符串中是否含有子字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/hello/.<span class="title function_">test</span>(<span class="string">&quot;abchello&quot;</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="RegExp-prototype-exec方法"><a href="#RegExp-prototype-exec方法" class="headerlink" title="RegExp.prototype.exec方法"></a>RegExp.prototype.exec方法</h2><p>和字符串的match方法类似，这个方法也是从字符串中捕获满足条件的字符串到数组中，但是也有两个区别。</p>
<ol>
<li>exec方法一次只能捕获一份子字符串到数组中，无论正则表达式是否有全局属性</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg=<span class="regexp">/hello/g</span>;</span><br><span class="line">reg.<span class="title function_">exec</span>(<span class="string">&quot;abchelloasdasdhelloasd&quot;</span>);   <span class="comment">// [&quot;hello&quot;]</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>正则表达式对象(也就是JavaScript中的RegExp对象)有一个lastIndex属性，用来表示下一次从哪个位置开始捕获，每一次执行exec方法后，lastIndex就会往后推，直到找不到匹配的字符返回null，然后又从头开始捕获。 这个属性可以用来遍历捕获字符串中的子串。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg=<span class="regexp">/hello/g</span>;</span><br><span class="line">reg.<span class="property">lastIndex</span>; <span class="comment">//0</span></span><br><span class="line">reg.<span class="title function_">exec</span>(<span class="string">&quot;abchelloasdasdhelloasd&quot;</span>); <span class="comment">// [&quot;hello&quot;]</span></span><br><span class="line">reg.<span class="property">lastIndex</span>; <span class="comment">//8</span></span><br><span class="line">reg.<span class="title function_">exec</span>(<span class="string">&quot;abchelloasdasdhelloasd&quot;</span>); <span class="comment">// [&quot;hello&quot;]</span></span><br><span class="line">reg.<span class="property">lastIndex</span>; <span class="comment">//19</span></span><br><span class="line">reg.<span class="title function_">exec</span>(<span class="string">&quot;abchelloasdasdhelloasd&quot;</span>); <span class="comment">// null</span></span><br><span class="line">reg.<span class="property">lastIndex</span>; <span class="comment">//0</span></span><br></pre></td></tr></table></figure>


<h1 id="正则表达式基础"><a href="#正则表达式基础" class="headerlink" title="正则表达式基础"></a>正则表达式基础</h1><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p> 上面第一节以&#x2F;hello&#x2F;为例，但是实际应用中可能会遇到这样的需求： 匹配一串不确定的数字、匹配开始的位置、匹配结束的位置、匹配空白符。此时就可以用到元字符。</p>
<p>元字符：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配数字:  \d</span></span><br><span class="line"><span class="string">&quot;ad3ad2ad&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/\d/g</span>);  <span class="comment">// [&quot;3&quot;, &quot;2&quot;]</span></span><br><span class="line"><span class="comment">//匹配除换行符以外的任意字符:  .</span></span><br><span class="line"><span class="string">&quot;a\nb\rc&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/./g</span>);  <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"><span class="comment">//匹配字母或数字或下划线 ： \w</span></span><br><span class="line"><span class="string">&quot;a5_  汉字@!-=&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/\w/g</span>);  <span class="comment">// [&quot;a&quot;, &quot;5&quot;, &quot;_&quot;]</span></span><br><span class="line"><span class="comment">//匹配空白符:\s</span></span><br><span class="line"><span class="string">&quot;\n \r&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/\s/g</span>);  <span class="comment">//[&quot; &quot;, &quot; &quot;, &quot;&quot;] 第一个结果是\n，最后一个结果是\r</span></span><br><span class="line"><span class="comment">//匹配【单词开始或结束】的位置 ： \b</span></span><br><span class="line"><span class="string">&quot;how are you&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/\b\w/g</span>);  <span class="comment">//[&quot;h&quot;, &quot;a&quot;, &quot;y&quot;] </span></span><br><span class="line"><span class="comment">// 匹配【字符串开始和结束】的位置:  开始 ^ 结束 $</span></span><br><span class="line"><span class="string">&quot;how are you&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/^\w/g</span>); <span class="comment">// [&quot;h&quot;]</span></span><br></pre></td></tr></table></figure>

<p>反义元字符，写法就是把上面的小写字母变成大写的，比如 ， 匹配所有不是数字的字符： \D</p>
<p>另外还有一些用来表示重复的元字符，会在下面的内容中介绍。</p>
<h2 id="字符范围"><a href="#字符范围" class="headerlink" title="字符范围"></a>字符范围</h2><p>在 [] 中使用符号 -  ，可以用来表示字符范围。如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配字母 a-z 之间所有字母</span></span><br><span class="line">/[a-z]/</span><br><span class="line"><span class="comment">// 匹配Unicode中 数字 0 到 字母 z 之间的所有字符</span></span><br><span class="line"><span class="regexp">/[0-z]/</span> </span><br><span class="line"><span class="comment">// unicode编码查询地址：</span></span><br><span class="line"><span class="comment">//https://en.wikibooks.org/wiki/Unicode/Character_reference/0000-0FFF</span></span><br><span class="line"><span class="comment">//根据上面的内容，我们可以找出汉字的Unicode编码范围是 \u4E00 到 \u9FA5，所以我们可以写一个正则表达式来判断一个字符串中是否有汉字</span></span><br><span class="line"><span class="regexp">/[\u4E00-\u9FA5]/</span>.<span class="title function_">test</span>(<span class="string">&quot;测试&quot;</span>);  <span class="comment">// true </span></span><br></pre></td></tr></table></figure>

<h2 id="重复-贪婪与懒惰"><a href="#重复-贪婪与懒惰" class="headerlink" title="重复 &amp; 贪婪与懒惰"></a>重复 &amp; 贪婪与懒惰</h2><p>首先来讲重复，当我们希望匹配一些重复的字符时，就需要用到一些和重复相关的正则表达式，写法如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重复n次 &#123;n&#125;</span></span><br><span class="line"><span class="string">&quot;test12&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/test\d&#123;3&#125;/</span>); <span class="comment">// null</span></span><br><span class="line"><span class="string">&quot;test123&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/test\d&#123;3&#125;/</span>); <span class="comment">// [&quot;test123&quot;]</span></span><br><span class="line"><span class="comment">//重复n次或更多次  &#123;n,&#125;</span></span><br><span class="line"><span class="string">&quot;test123&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/test\d&#123;3,&#125;/</span>); <span class="comment">//  [&quot;test123&quot;]</span></span><br><span class="line"><span class="comment">//重复n到m次</span></span><br><span class="line"><span class="string">&quot;test12&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/test\d&#123;3,5&#125;/</span>); <span class="comment">//  null</span></span><br><span class="line"><span class="string">&quot;test12345&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/test\d&#123;3,5&#125;/</span>);  <span class="comment">// [&quot;test12345&quot;]</span></span><br><span class="line"><span class="string">&quot;test12345678&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/test\d&#123;3,5&#125;/</span>);  <span class="comment">// [&quot;test12345&quot;]</span></span><br><span class="line"><span class="comment">// 匹配字符test后边跟着数字，数字重复0次或多次</span></span><br><span class="line"><span class="string">&quot;test&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/test\d*/</span>); <span class="comment">// [&quot;test&quot;]</span></span><br><span class="line"><span class="string">&quot;test123&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/test\d*/</span>); <span class="comment">// [&quot;test123&quot;]</span></span><br><span class="line"><span class="comment">//重复一次或多次</span></span><br><span class="line"><span class="string">&quot;test&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/test\d+/</span>) ; <span class="comment">// null</span></span><br><span class="line"><span class="string">&quot;test1&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/test\d*/</span>); <span class="comment">//[&quot;test1&quot;]</span></span><br><span class="line"><span class="comment">//重复一次或0次</span></span><br><span class="line"><span class="string">&quot;test&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/test\d?/</span>) ; <span class="comment">// null</span></span><br><span class="line"><span class="string">&quot;test1&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/test\d?/</span>); <span class="comment">//[&quot;test1&quot;]</span></span><br></pre></td></tr></table></figure>

<p>从上面的结果可以看到，字符test后边跟着的数字可以重复0次或多次时，正则表达式捕获的子字符串会返回尽量多的数字，比如&#x2F;test\d*&#x2F;匹配 test123 ，返回的是test123，而不是test或者test12。</p>
<p>正则表达式捕获字符串时，在满足条件的情况下捕获尽可能多的字符串，这就是所谓的“贪婪模式”。</p>
<p>对应的”懒惰模式“，就是在满足条件的情况下捕获尽可能少的字符串，使用懒惰模式的方法，就是在字符重复标识后面加上一个 “?”，写法如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数字重复3~5次，满足条件的情况下返回尽可能少的数字</span></span><br><span class="line"><span class="string">&quot;test12345&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/test\d&#123;3,5&#125;?/</span>);  <span class="comment">//[&quot;test123&quot;]</span></span><br><span class="line"><span class="comment">// 数字重复1次或更多，满足条件的情况下只返回一个数字</span></span><br><span class="line"><span class="string">&quot;test12345&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/test\d+?/</span>);  <span class="comment">// [&quot;test1&quot;]</span></span><br></pre></td></tr></table></figure>

<h2 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h2><p>在正则表达式中元字符是有特殊的含义的，当我们要匹配元字符本身时，就需要用到字符转义，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/\./.<span class="title function_">test</span>(<span class="string">&quot;.&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="分组-分支条件"><a href="#分组-分支条件" class="headerlink" title="分组 &amp; 分支条件"></a>分组 &amp; 分支条件</h2><p>正则表达式可以用 “ ()  “ 来进行分组，具有分组的正则表达式除了正则表达式整体会匹配子字符串外，分组中的正则表达式片段也会匹配字符串。</p>
<p>分组按照嵌套关系和前后关系，每个分组会分配得到一个数字组号，在一些场景中可以用组号来使用分组。</p>
<p>在 replace、match、exec函数中，分组都能体现不同的功能。</p>
<p><strong>replace函数</strong>中，第二个参数里边可以用 $+数字组号来指代第几个分组的内容，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot; the best language in the world is java &quot;</span>.<span class="title function_">replace</span>(<span class="regexp">/(java)/</span>,<span class="string">&quot;$1script&quot;</span>); <span class="comment">// &quot; the best language in the world is javascript &quot;</span></span><br><span class="line"><span class="string">&quot;/static/app1/js/index.js&quot;</span>.<span class="title function_">replace</span>(<span class="regexp">/(\/\w+)\.js/</span>,<span class="string">&quot;$1-v0.0.1.js&quot;</span>); <span class="comment">//&quot;/static/app1/js/index-v0.0.1.js&quot;    (\/\w+)分组匹配的就是 /index ，在第二个参数中为其添加上版本号</span></span><br></pre></td></tr></table></figure>

<p><strong>match函数</strong>中，当正则表达式有全局属性时，会捕获所有满足正则表达式的子字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;abchellodefhellog&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/h(ell)o/g</span>); <span class="comment">//[&quot;hello&quot;, &quot;hello&quot;]</span></span><br></pre></td></tr></table></figure>

<p>但是当正则表达式没有全局属性，且正则表达式中有分组的时候，match函数只会返回整个正则表达式匹配的第一个结果，同时会将分组匹配到的字符串也放入结果数组中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;abchellodefhellog&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/h(ell)o/</span>); <span class="comment">//[&quot;hello&quot;, &quot;ell&quot;]</span></span><br><span class="line"><span class="comment">// 我们可以用match函数来分解url，获取协议、host、path、查询字符串等信息</span></span><br><span class="line"><span class="string">&quot;http://www.baidu.com/test?t=5&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/^((\w+):\/\/([\w\.]+))\/([^?]+)\?(\S+)$/</span>);</span><br><span class="line"><span class="comment">// [&quot;http://www.baidu.com/test?t=5&quot;, &quot;http://www.baidu.com&quot;, &quot;http&quot;, &quot;www.baidu.com&quot;, &quot;test&quot;, &quot;t=5&quot;]</span></span><br></pre></td></tr></table></figure>

<p><strong>exec函数</strong>在正则表达式中有分组的情况下，表现和match函数很像，只是无论正则表达式是否有全局属性，exec函数都只返回一个结果，并捕获分组的结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/<span class="title function_">h</span>(ell)o/g.<span class="title function_">exec</span>(<span class="string">&quot;abchellodefhellog&quot;</span>); <span class="comment">//[&quot;hello&quot;, &quot;ell&quot;]</span></span><br></pre></td></tr></table></figure>

<p>当正则表达式需要匹配几种类型的结果时，可以用到<strong>分支条件</strong>，例如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;asdasd hi  asdad hello asdasd&quot;</span>.<span class="title function_">replace</span>(<span class="regexp">/hi|hello/</span>,<span class="string">&quot;nihao&quot;</span>); <span class="comment">//&quot;asdasd nihao  asdad hello asdasd&quot;</span></span><br><span class="line"><span class="string">&quot;asdasd hi  asdad hello asdasd&quot;</span>.<span class="title function_">split</span>(<span class="regexp">/hi|hello/</span>); <span class="comment">//[&quot;asdasd &quot;, &quot;  asdad &quot;, &quot; asdasd&quot;]</span></span><br></pre></td></tr></table></figure>

<p> 注意，分支条件影响它两边的所有内容， 比如 hi|hello  匹配的是hi或者hello，而不是 hiello 或者 hhello</p>
<p>分组中的分支条件不会影响分组外的内容</p>
<p>“abc acd  bbc bcd “.match(&#x2F;(a|b)bc&#x2F;g); &#x2F;&#x2F;[“abc”, “bbc”]</p>
<h2 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h2><p>正则表达式的分组可以在其后边的语句中通过  +数字组号来引用</p>
<p>比如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配重复的单词</span></span><br><span class="line">/(\b[a-zA-Z]+\b)\s+\<span class="number">1</span>/.<span class="title function_">exec</span>(<span class="string">&quot; asd sf  hello hello asd&quot;</span>); <span class="comment">//[&quot;hello hello&quot;, &quot;hello&quot;]</span></span><br></pre></td></tr></table></figure>

<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>** (?:exp)** , 用此方式定义的分组，正则表达式会匹配分组中的内容，但是不再给此分组分配组号，此分组在replace、match等函数中的作用也会消失，效果如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/(hello)\sworld/.<span class="title function_">exec</span>(<span class="string">&quot;asdadasd hello world asdasd&quot;</span>)  <span class="comment">// [&quot;hello world&quot;, &quot;hello&quot;],正常捕获结果字符串和分组字符串</span></span><br><span class="line">/(?:hello)\sworld/.<span class="title function_">exec</span>(<span class="string">&quot;asdadasd hello world asdasd&quot;</span>)  <span class="comment">// [&quot;hello world&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;/static/app1/js/index.js&quot;</span>.<span class="title function_">replace</span>(<span class="regexp">/(\/\w+)\.js/</span>,<span class="string">&quot;$1-v0.0.1.js&quot;</span>); <span class="comment">//&quot;/static/app1/js/index-v0.0.1.js&quot;</span></span><br><span class="line"><span class="string">&quot;/static/app1/js/index.js&quot;</span>.<span class="title function_">replace</span>(<span class="regexp">/(?:\/\w+)\.js/</span>,<span class="string">&quot;$1-v0.0.1.js&quot;</span>); <span class="comment">//&quot;/static/app1/js$1-v0.0.1.js&quot;</span></span><br></pre></td></tr></table></figure>

<p>**(?&#x3D;exp) **这个分组用在正则表达式的后面，用来捕获exp前面的字符，分组中的内容不会被捕获，也不分配组号</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/hello\<span class="title function_">s</span>(?=world)/.<span class="title function_">exec</span>(<span class="string">&quot;asdadasd hello world asdasd&quot;</span>)  <span class="comment">// [&quot;hello &quot;]</span></span><br></pre></td></tr></table></figure>

<p>**(?!exp) ** 和前面的断言相反，用在正则表达式的后面，捕获后面不是exp的字符，同样不捕获分组的内容，也不分配组号</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/hello\<span class="title function_">s</span>(?!world)/.<span class="title function_">exec</span>(<span class="string">&quot;asdadasd hello world asdasd&quot;</span>) <span class="comment">//null</span></span><br></pre></td></tr></table></figure>

<h2 id="处理选项"><a href="#处理选项" class="headerlink" title="处理选项"></a>处理选项</h2><p>javascript中正则表达式支持的正则表达式有三个，g、i、m，分别代表全局匹配、忽略大小写、多行模式。三种属性可以自由组合共存。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局匹配  g </span></span><br><span class="line"><span class="string">&quot;abchelloasdasdhelloasd&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/hello/</span>);  <span class="comment">//[&quot;hello&quot;]</span></span><br><span class="line"><span class="string">&quot;abchelloasdasdhelloasd&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/hello/g</span>);  <span class="comment">//[&quot;hello&quot;,&quot;hello&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//忽略大小写 i</span></span><br><span class="line"><span class="string">&quot;abchelloasdasdHelloasd&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/hello/g</span>); <span class="comment">//[&quot;hello&quot;]</span></span><br><span class="line"><span class="string">&quot;abchelloasdasdHelloasd&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/hello/gi</span>); <span class="comment">//[&quot;hello&quot;,&quot;Hello&quot;]</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>


<p>在默认的模式下，元字符 ^ 和 $ 分别匹配字符串的开头和结尾处，模式 m 改变了这俩元字符的定义，让他们匹配一行的开头和结尾</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;aadasd\nbasdc&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/^[a-z]+$/g</span>);  <span class="comment">//null  字符串^和$之间有换行符，匹配不上 [a-z]+ ,故返回null</span></span><br><span class="line"><span class="string">&quot;aadasd\nbasdc&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/^[a-z]+$/gm</span>);  <span class="comment">// [&quot;aadasd&quot;, &quot;basdc&quot;] ，改变^$的含义，让其匹配一行的开头和末尾，可以得到两行的结果</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown使用教程</title>
    <url>/post/f60c57e73b04/</url>
    <content><![CDATA[<h1 id="Markdown使用教程"><a href="#Markdown使用教程" class="headerlink" title="Markdown使用教程"></a>Markdown使用教程</h1><h2 id="一、Markdown"><a href="#一、Markdown" class="headerlink" title="一、Markdown"></a>一、Markdown</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><img src="https://xiaojinhe-cdn.iyoudui.cn/upload/common/20221030/md_logo.png" alt="logo"></p>
<p><code>Markdown</code> 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>
<span id="more"></span>

<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>当前许多网站都广泛使用 <code>Markdown</code> 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、知乎等</p>
<h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><p>推荐使用<code>Typora</code>，官网：<a href="https://typora.io/">https://typora.io/</a></p>
<h2 id="二、徽章"><a href="#二、徽章" class="headerlink" title="二、徽章"></a>二、徽章</h2><h4 id="什么是徽章"><a href="#什么是徽章" class="headerlink" title="什么是徽章"></a>什么是徽章</h4><p>徽章是一种小巧精美的小图标，一般配有相关文字进行辅助说明，可对数据进行监控，链接跳转等，富有表现力。</p>
<p>常见于<code>github</code>项目主页，但其不仅出现于 <code>github</code> 项目主页，凡是能够表现图片的地方都可以出现徽章。</p>
<h4 id="徽章的使用"><a href="#徽章的使用" class="headerlink" title="徽章的使用"></a>徽章的使用</h4><ul>
<li>在<code>markdown</code>中使用</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">格式:</span><br><span class="line">[<span class="string">![图片文字说明</span>](<span class="link">图片源地址</span>)](<span class="link">超链接地址</span>)  # 即超链接内部嵌套图片</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">[<span class="string">![github</span>](<span class="link">https://img.shields.io/badge/github-ytking-brightgreen.svg</span>)](<span class="link">https://github.com/ytking</span>)</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/ytking"><img src="https://img.shields.io/badge/github-ytking-brightgreen.svg" alt="github"></a></p>
<p>徽章生成网站：<a href="https://shields.io/">https://shields.io/</a></p>
<p>本文档主要介绍markdown，不对徽章做过多介绍，详细介绍请 <a href="https://segmentfault.com/a/1190000019552597"> 戳我 </a> 了解。</p>
<h2 id="三、设置目录"><a href="#三、设置目录" class="headerlink" title="三、设置目录"></a>三、设置目录</h2><p>设置之后会根据分级标题来自动生成目录。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[TOC]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：github暂未支持。</p>
</blockquote>
<p>[TOC]</p>
<p>在github生成TOC的方法：<a href="https://github.com/ekalinin/github-markdown-toc">https://github.com/ekalinin/github-markdown-toc</a></p>
<p>windows系统需要基于golang实现的工具：<a href="https://github.com/ekalinin/github-markdown-toc.go">https://github.com/ekalinin/github-markdown-toc.go</a></p>
<blockquote>
<p>如果你有GO语言的编译环境，可以尝试自己编译，如果没有，可以直接下载编译好的二进制文件。</p>
<p>如windows系统64位 下载：gh-md-toc.windows.amd64.tgz （386 是32位，amd64是64位）</p>
<p>下载解压后，发现没有后缀名无法识别，实际上这是个exe文件，所以只需要暴力地在后面加上.exe就可以开始愉快使用了。</p>
<p>使用方法：</p>
<ol>
<li>首先将.md文档复制到gh-md-toc.exe的根目录下</li>
<li>在该目录下打开系统命令行，输入命令：gh-md-toc.exe README.MD 生成目录</li>
<li>把生成的目录复制到.md文件即可。</li>
</ol>
</blockquote>
<p><strong>这是gh-md-toc生成的目录：</strong></p>
<ul>
<li><a href="#%E4%B8%80markdown">一、Markdown</a><ul>
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li>
<li><a href="#%E5%BA%94%E7%94%A8">应用</a></li>
<li><a href="#%E7%BC%96%E8%BE%91%E5%99%A8">编辑器</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E5%BE%BD%E7%AB%A0">二、徽章</a><ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%BD%E7%AB%A0">什么是徽章</a></li>
<li><a href="#%E5%BE%BD%E7%AB%A0%E7%9A%84%E4%BD%BF%E7%94%A8">徽章的使用</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E8%AE%BE%E7%BD%AE%E7%9B%AE%E5%BD%95">三、设置目录</a></li>
<li><a href="#%E5%9B%9B%E6%A0%87%E9%A2%98">四、标题</a></li>
<li><a href="#%E4%B8%80%E7%BA%A7%E6%A0%87%E9%A2%98">一级标题</a><ul>
<li><a href="#%E4%BA%8C%E7%BA%A7%E6%A0%87%E9%A2%98">二级标题</a><ul>
<li><a href="#%E4%B8%89%E7%BA%A7%E6%A0%87%E9%A2%98">三级标题</a><ul>
<li><a href="#%E5%9B%9B%E7%BA%A7%E6%A0%87%E9%A2%98">四级标题</a><ul>
<li><a href="#%E4%BA%94%E7%BA%A7%E6%A0%87%E9%A2%98">五级标题</a><ul>
<li><a href="#%E5%85%AD%E7%BA%A7%E6%A0%87%E9%A2%98">六级标题</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BA%94%E6%96%87%E6%9C%AC">五、文本</a><ul>
<li><a href="#%E6%AE%B5%E8%90%BD">段落</a></li>
<li><a href="#%E5%AD%97%E4%BD%93">字体</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E7%BA%BF">删除线</a></li>
<li><a href="#%E4%B8%8B%E5%88%92%E7%BA%BF">下划线</a></li>
<li><a href="#%E6%96%87%E5%AD%97%E9%AB%98%E4%BA%AE">文字高亮</a></li>
<li><a href="#%E5%88%86%E9%9A%94%E7%BA%BF">分隔线</a></li>
<li><a href="#%E8%84%9A%E6%B3%A8">脚注</a></li>
</ul>
</li>
<li><a href="#%E5%85%AD%E5%88%97%E8%A1%A8">六、列表</a><ul>
<li><a href="#%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8">无序列表</a></li>
<li><a href="#%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8">有序列表</a></li>
<li><a href="#%E6%8A%98%E5%8F%A0%E5%88%97%E8%A1%A8">折叠列表</a></li>
<li><a href="#%E5%B8%A6%E5%A4%8D%E9%80%89%E6%A1%86%E5%88%97%E8%A1%A8">带复选框列表</a></li>
<li><a href="#%E5%88%97%E8%A1%A8%E5%B5%8C%E5%A5%97">列表嵌套</a></li>
</ul>
</li>
<li><a href="#%E4%B8%83%E5%8C%BA%E5%9D%97%E5%BC%95%E7%94%A8">七、区块引用</a><ul>
<li><a href="#%E5%8C%BA%E5%9D%97%E5%B5%8C%E5%A5%97">区块嵌套</a></li>
<li><a href="#%E5%8C%BA%E5%9D%97%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%88%97%E8%A1%A8">区块中使用列表</a></li>
<li><a href="#%E5%88%97%E8%A1%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%9D%97">列表中使用区块</a></li>
</ul>
</li>
<li><a href="#%E5%85%AB%E4%BB%A3%E7%A0%81">八、代码</a><ul>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%8C%BA%E5%9D%97">代码区块</a></li>
</ul>
</li>
<li><a href="#%E4%B9%9D%E9%93%BE%E6%8E%A5">九、链接</a><ul>
<li><a href="#%E5%8F%98%E9%87%8F%E9%93%BE%E6%8E%A5">变量链接</a></li>
<li><a href="#github%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E9%93%BE%E6%8E%A5">Github中使用内部链接</a></li>
<li><a href="#%E9%94%9A%E7%82%B9%E9%93%BE%E6%8E%A5">锚点链接</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81%E5%9B%BE%E7%89%87">十、图片</a><ul>
<li><a href="#%E5%9B%BE%E7%89%87%E5%AE%BD%E9%AB%98">图片宽高</a></li>
<li><a href="#%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E4%BB%A5%E5%8F%8Agithub%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%9B%BE%E7%89%87">相对路径以及Github中使用图片</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81%E4%B8%80%E8%A1%A8%E6%A0%BC">十一、表格</a></li>
<li><a href="#%E5%8D%81%E4%BA%8Cemoji%E8%A1%A8%E6%83%85%E5%8C%85">十二、Emoji表情包</a></li>
<li><a href="#%E5%8D%81%E4%B8%89%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7">十三、其他技巧</a><ul>
<li><a href="#%E6%94%AF%E6%8C%81%E7%9A%84-html-%E5%85%83%E7%B4%A0">支持的 HTML 元素</a></li>
<li><a href="#%E8%BD%AC%E4%B9%89">转义</a></li>
<li><a href="#%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F">数学公式</a></li>
<li><a href="#%E5%9B%BE%E8%A1%A8">图表</a></li>
<li><a href="#%E6%B5%81%E7%A8%8B%E5%9B%BE">流程图</a></li>
<li><a href="#%E6%97%B6%E5%BA%8F%E5%9B%BE">时序图</a></li>
<li><a href="#%E7%94%98%E7%89%B9%E5%9B%BE">甘特图</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="四、标题"><a href="#四、标题" class="headerlink" title="四、标题"></a>四、标题</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure>

<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="五、文本"><a href="#五、文本" class="headerlink" title="五、文本"></a>五、文本</h2><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>Markdown 段落没有特殊的格式，直接编写文字，<strong>需要段落缩进时使用2个Tab</strong></p>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体文本*</span></span><br><span class="line">或 <span class="emphasis">_斜体文本_</span></span><br><span class="line"><span class="strong">**粗体文本**</span></span><br><span class="line">或  <span class="strong">__粗体文本__</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*粗斜体文本*</span>**</span></span><br><span class="line">或 <span class="strong">__<span class="emphasis">_粗斜体文本_</span>__</span></span><br></pre></td></tr></table></figure>

<p><em>斜体文本</em></p>
<p><em>斜体文本</em></p>
<p><strong>粗体文本</strong></p>
<p><strong>粗体文本</strong></p>
<p><em><strong>粗斜体文本</strong></em></p>
<p><em><strong>粗斜体文本</strong></em></p>
<h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 <strong>~~</strong> 即可，实例如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">~~BAIDU.COM~~</span><br></pre></td></tr></table></figure>



<p><del>BAIDU.COM</del></p>
<h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>下划线可以通过 HTML 的<code>&lt;u&gt;</code> 标签来实现：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>带下划线的文本<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><u>带下划线的文本</u></p>
<h3 id="文字高亮"><a href="#文字高亮" class="headerlink" title="文字高亮"></a>文字高亮</h3><p>文字高亮能使行内部分文字高亮，使用一对反引号。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">`html`</span> <span class="code">`css`</span> <span class="code">`javascript`</span></span><br></pre></td></tr></table></figure>

<p><code>html</code> <code>css</code> <code>javascript</code></p>
<h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">***</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">**</span><span class="strong">***</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">- - -</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">----------</span></span><br></pre></td></tr></table></figure>





<hr>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>脚注是对文本的补充说明。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[^变量]</span><br><span class="line">在文档结尾或其他位置給变量赋值：</span><br><span class="line">[<span class="symbol">^变量</span>]: <span class="link">注明框内显示的内容</span></span><br><span class="line"></span><br><span class="line">鼠标移到这里&gt; [^哈喽]</span><br><span class="line">[<span class="symbol">^哈喽</span>]: <span class="link">注明框内显示的内容</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：在部分线上预览未支持</p>
</blockquote>
<p>鼠标移到这里&gt; <a href="%E6%B3%A8%E6%98%8E%E6%A1%86%E5%86%85%E6%98%BE%E7%A4%BA%E7%9A%84%E5%86%85%E5%AE%B9">^哈喽</a></p>
<h2 id="六、列表"><a href="#六、列表" class="headerlink" title="六、列表"></a>六、列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>使用星号<code>*</code>、加号<code>+</code>或是减号<code>-</code>作为列表标记：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> 第一项</span><br><span class="line"><span class="bullet">*</span> 第二项</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> 第一项</span><br><span class="line"><span class="bullet">+</span> 第二项</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 第一项</span><br><span class="line"><span class="bullet">-</span> 第二项</span><br></pre></td></tr></table></figure>



<ul>
<li>第一项</li>
<li>第二项</li>
</ul>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>使用数字并加上<code> .</code> 号来表示</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 第一项</span><br><span class="line"><span class="bullet">2.</span> 第二项</span><br></pre></td></tr></table></figure>



<ol>
<li>第一项</li>
<li>第二项</li>
</ol>
<h3 id="折叠列表"><a href="#折叠列表" class="headerlink" title="折叠列表"></a>折叠列表</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">summary</span>&gt;</span></span>点我打开关闭折叠<span class="language-xml"><span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span></span><br><span class="line"> 折叠内容</span><br><span class="line"> <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="code">     &lt;li&gt;1&lt;/li&gt;</span></span><br><span class="line"><span class="code">     &lt;li&gt;2&lt;/li&gt;</span></span><br><span class="line"><span class="code">     &lt;li&gt;3&lt;/li&gt;</span></span><br><span class="line"><span class="code"> &lt;/ul&gt;</span></span><br><span class="line"><span class="code">&lt;/details&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：&lt;details&gt; 标签内写markdown代码无效，可写html代码，如ul&gt;li、table等</p>
</blockquote>
<details>
<summary>点我打开关闭折叠</summary>
 折叠内容
 <ul>
     <li>1</li>
     <li>2</li>
     <li>3</li>
 </ul>
</details>

<details>
<summary>包含table的折叠</summary>
    <table>
        <thead>
            <tr>
                <th align="center">分类</th>
                <th align="center">例词</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td align="center">人称代词-主格</td>
                <td align="center">I我，you你，he他，she她，they他们， we我们</td>
            </tr>
            <tr>
                <td align="center">人称代词-宾格</td>
                <td align="center">me我， you你， him他， her她， them他们， us我们</td>
            </tr>
            <tr>
                <td align="center">物主代词</td>
                <td align="center">my我的， his他的， your你的（your你们的）， their他们的， hers她的</td>
            </tr>
            <tr>
                <td align="center">指示代词</td>
                <td align="center">this这， that那， these这些， those 那些</td>
            </tr>
            <tr>
                <td align="center">反身代词</td>
                <td align="center">myself我自己， himself他自己， themselves他们自己， yourself你(们)自己，herself她自己</td>
            </tr>
            <tr>
                <td align="center">疑问代词</td>
                <td align="center">who谁， what什么， which哪个</td>
            </tr>
            <tr>
                <td align="center">不定代词</td>
                <td align="center">some一些， many许多， both两个、两个都， any许多</td>
            </tr>
            <tr>
                <td align="center">关系代词</td>
                <td align="center">which……的物， who……的人， that……的人或物， who谁， that引导定语从句</td>
            </tr>
            <tr>
                <td align="center">相互代词</td>
                <td align="center">each other 互相， one another互相</td>
            </tr>
            <tr>
                <td align="center">连接代词</td>
                <td align="center">who,whom,whose,what,which,whatever,whichever,whoever,whomever</td>
            </tr>
            <tr>
                <td align="center">替代词</td>
                <td align="center">one（单数），ones（复数）</td>
            </tr>
        </tbody>
    </table>
</details>



<h3 id="带复选框列表"><a href="#带复选框列表" class="headerlink" title="带复选框列表"></a>带复选框列表</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> [x] 第一项</span><br><span class="line"><span class="bullet">*</span> [ ] 第二项</span><br><span class="line"><span class="bullet">*</span> [ ] 第三项</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：在部分线上预览未支持</p>
</blockquote>
<ul>
<li><p><input checked="" disabled="" type="checkbox"> 
第一项</p>
</li>
<li><p><input disabled="" type="checkbox"> 
第二项</p>
</li>
<li><p><input disabled="" type="checkbox"> 
第三项</p>
</li>
</ul>
<h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 第一项：</span><br><span class="line"><span class="bullet">    -</span> 第一项嵌套的第一个元素</span><br><span class="line"><span class="bullet">    -</span> 第一项嵌套的第二个元素</span><br><span class="line"><span class="bullet">2.</span> 第二项：</span><br><span class="line"><span class="bullet">    -</span> 第二项嵌套的第一个元素</span><br><span class="line"><span class="bullet">       -</span> 第三层嵌套</span><br></pre></td></tr></table></figure>



<ol>
<li>第一项<ul>
<li>嵌套1</li>
<li>嵌套2</li>
</ul>
</li>
<li>第二项<br>- 嵌套1<br>   - 嵌套2</li>
</ol>
<h2 id="七、区块引用"><a href="#七、区块引用" class="headerlink" title="七、区块引用"></a>七、区块引用</h2><p>区块引用是在段落开头使用 <code>&gt;</code>符号 ，然后后面紧跟一个<strong>空格</strong>符号：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 区块引用</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>区块引用</p>
<p>Typora中回车键自动延伸区块</p>
</blockquote>
<h4 id="区块嵌套"><a href="#区块嵌套" class="headerlink" title="区块嵌套"></a>区块嵌套</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 第一层</span></span><br><span class="line"><span class="quote">&gt; &gt; 第二层</span></span><br><span class="line"><span class="quote">&gt; &gt; &gt; 第三层</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一层</p>
<blockquote>
<p>第二层</p>
<blockquote>
<p>第三层</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="区块中使用列表"><a href="#区块中使用列表" class="headerlink" title="区块中使用列表"></a>区块中使用列表</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 区块中使用列表</span></span><br><span class="line"><span class="quote">&gt; 1. 第一项</span></span><br><span class="line"><span class="quote">&gt; 2. 第二项</span></span><br><span class="line"><span class="quote">&gt; * 111</span></span><br><span class="line"><span class="quote">&gt; * 222</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>区块中使用列表</p>
<ol>
<li>第一项</li>
<li>第二项<ul>
<li>111</li>
<li>222</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="列表中使用区块"><a href="#列表中使用区块" class="headerlink" title="列表中使用区块"></a>列表中使用区块</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> 第一项</span><br><span class="line"><span class="code">    &gt; 区块</span></span><br><span class="line"><span class="code">* 第二项</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一项</p>
<blockquote>
<p>区块</p>
<p>区块</p>
</blockquote>
</li>
<li><p>第二项</p>
</li>
</ul>
<h2 id="八、代码"><a href="#八、代码" class="headerlink" title="八、代码"></a>八、代码</h2><p>如果是段落上的一个代码片段可以用反引号把它包起来（**&#96;**），示例：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">`alert()`</span></span><br></pre></td></tr></table></figure>

<p><code>alert()</code></p>
<h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><p>用三个反引号 <strong>&#96;&#96;&#96;</strong> 包裹一段代码，并指定一种语言（也可以不指定），指定代码语言后会有代码的颜色高亮</p>
<p>本代码区块为示例说明：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">​<span class="code">```javascript</span></span><br><span class="line"><span class="code">function test() &#123;</span></span><br><span class="line"><span class="code">	alert(&#x27;test&#x27;)</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">​```</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="title function_">alert</span>(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="九、链接"><a href="#九、链接" class="headerlink" title="九、链接"></a>九、链接</h2><p>格式：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">链接名称</span>](<span class="link">链接地址</span>)</span><br><span class="line"></span><br><span class="line">[<span class="string">链接名称</span>](<span class="link">链接地址,可选的alt</span>)</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">&lt;链接地址&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">百度</span>](<span class="link">http://www.baidu.com,&#x27;百度&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><a href="http://www.baidu.com,'百度'/">百度</a></p>
<p>直接显示链接地址：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">&lt;http://www.baidu.com&gt;</span></span><br></pre></td></tr></table></figure>

<p><a href="http://www.baidu.com/">http://www.baidu.com</a></p>
<h3 id="变量链接"><a href="#变量链接" class="headerlink" title="变量链接"></a>变量链接</h3><p>链接可以用变量来代替，文档末尾或其他位置附带变量地址：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这个链接用 1 作为网址变量 [<span class="string">Google</span>][<span class="symbol">1</span>]</span><br><span class="line">这个链接用 baidu 作为网址变量 [<span class="string">Baidu</span>][<span class="symbol">baidu</span>]</span><br><span class="line"></span><br><span class="line">然后在文档的结尾或其他位置给变量赋值（网址）</span><br><span class="line">  [1]: http://www.google.com/</span><br><span class="line">  [baidu]: http://www.baidu.com/</span><br></pre></td></tr></table></figure>



<p>这个链接用 1 作为网址变量 <a href="http://www.google.com/">Google</a></p>
<p>这个链接用 baidu 作为网址变量 <a href="http://www.baidu.com/">Baidu</a></p>
<h3 id="Github仓库中使用内部链接"><a href="#Github仓库中使用内部链接" class="headerlink" title="Github仓库中使用内部链接"></a>Github仓库中使用内部链接</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">可使用相对路径（前提是有该路径下的文件）</span><br><span class="line">[<span class="string">test</span>](<span class="link">test.md</span>)</span><br></pre></td></tr></table></figure>
<p><a href="./md-img/test.md">test</a></p>
<h3 id="锚点链接"><a href="#锚点链接" class="headerlink" title="锚点链接"></a>锚点链接</h3><p>本文件中每一个标题都是一个锚点，和HTML的锚点（<code>#</code>）类似</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">Markdown</span>](<span class="link">#Markdown</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注： github对含有标点符号的标题进行锚点时会忽略掉标点符号，<br>本页中，如果这样写则无法跳转：[链接](#九、链接)<br>正确写法：[链接](#九链接)</p>
</blockquote>
<p><a href="#%E4%B8%80Markdown">Markdown</a></p>
<p><a href="#%E4%B9%9D%E9%93%BE%E6%8E%A5">链接</a></p>
<p><a href="#%E6%B5%81%E7%A8%8B%E5%9B%BE">流程图</a></p>
<h2 id="十、图片"><a href="#十、图片" class="headerlink" title="十、图片"></a>十、图片</h2><p>和链接的区别是前面多一个感叹号<code>!</code></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">图片名</span>](<span class="link">图片链接</span>)</span><br></pre></td></tr></table></figure>

<p>当然，你也可以像链接那样对图片地址使用变量:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这里链接用 img 作为图片地址变量</span><br><span class="line">然后在文档的结尾或其他位置给变量赋值（图片地址）</span><br><span class="line">![<span class="string">RUNOOB</span>][<span class="symbol">img</span>]</span><br><span class="line">[<span class="symbol">img</span>]: <span class="link">https://xiaojinhe-cdn.iyoudui.cn/upload/common/20221030/md_logo.png</span></span><br></pre></td></tr></table></figure>

<p> <img src="https://xiaojinhe-cdn.iyoudui.cn/upload/common/20221030/md_logo.png" alt="RUNOOB"></p>
<h3 id="图片宽高"><a href="#图片宽高" class="headerlink" title="图片宽高"></a>图片宽高</h3><p>如下想设置图片宽高，可以使用 <code>&lt;img&gt;</code> 标签。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://xiaojinhe-cdn.iyoudui.cn/upload/common/20221030/md_logo.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;50px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;30px&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>



<img src="https://xiaojinhe-cdn.iyoudui.cn/upload/common/20221030/md_logo.png" width="50px" height="30px">



<h3 id="相对路径以及Github中使用图片"><a href="#相对路径以及Github中使用图片" class="headerlink" title="相对路径以及Github中使用图片"></a>相对路径以及Github中使用图片</h3><p>不管是在本地还是在github同一个仓库中，如果图片存在，可以使用<strong>相对路径</strong>。</p>
<p>相对路径图片：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">头像图片</span>](<span class="link">./md-img/test.jpg</span>)</span><br></pre></td></tr></table></figure>

<p>github上如果引用其他github仓库中的图片则要注意地址格式：<code>仓库地址/raw/分支名/图片路径</code> 或 <code>https://raw.githubusercontent.com/用户名/仓库名/分支名/图片路径</code></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">其他仓库的图片1</span>](<span class="link">https://github.com/xxx/branch/raw/master/src/common/image/default.png</span>)</span><br><span class="line">或</span><br><span class="line">![<span class="string">其他仓库的图片2</span>](<span class="link">https://raw.githubusercontent.com/xxx/image_store/master/blog/md_logo.png</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="十一、表格"><a href="#十一、表格" class="headerlink" title="十一、表格"></a>十一、表格</h2><p>制作表格使用 <code>|</code>来分隔不同的单元格，使用<code>-</code>来分隔表头和其他行。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">|  表头   | 表头  |</span><br><span class="line">|  ----  | ----  |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line">| 单元格  | 单元格 |</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th align="center">表头</th>
<th align="center">表头</th>
</tr>
</thead>
<tbody><tr>
<td align="center">单元格</td>
<td align="center">单元格</td>
</tr>
<tr>
<td align="center">单元格</td>
<td align="center">单元格</td>
</tr>
</tbody></table>
<p><strong>对齐方式</strong></p>
<ul>
<li><strong>-:</strong> 设置内容和标题栏居右对齐</li>
<li><strong>:-</strong> 设置内容和标题栏居左对齐</li>
<li><strong>:-:</strong> 设置内容和标题栏居中对齐</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="right">右对齐</th>
<th align="center">居中对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
<tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
</tbody></table>
<h2 id="十二、Emoji表情包"><a href="#十二、Emoji表情包" class="headerlink" title="十二、Emoji表情包"></a>十二、Emoji表情包</h2><p>Emoji表情英文名的前后加冒号，Typore上先输入冒号再输入首字母有表情提示</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">:smirk:</span><br></pre></td></tr></table></figure>
<p>:kiss:<br>:smile_cat::see_no_evil::horse:<br>:smirk::blush::smiley::smile: :sunny:</p>
<p>更多表情名称请查看：<a href="https://www.webfx.com/tools/emoji-cheat-sheet/">表情包清单</a></p>
<h2 id="十三、其他技巧"><a href="#十三、其他技巧" class="headerlink" title="十三、其他技巧"></a>十三、其他技巧</h2><h3 id="支持的-HTML-元素"><a href="#支持的-HTML-元素" class="headerlink" title="支持的 HTML 元素"></a>支持的 HTML 元素</h3><p>不在 Markdown 语法涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p>
<p>目前支持的 HTML 元素有：<code>&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;</code>等等 ，如：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">使用 <span class="language-xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Ctrl<span class="language-xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span>+<span class="language-xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Alt<span class="language-xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span>+<span class="language-xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Del<span class="language-xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> 重启电脑</span><br></pre></td></tr></table></figure>

<p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p>
<p><b>我是使用b标签的加粗字体</b></p>
<h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用反斜杠转义字符：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**未转义星号显示加粗**</span></span><br><span class="line">\<span class="emphasis">*\*</span> 转义显示星号 \<span class="emphasis">*\*</span></span><br></pre></td></tr></table></figure>

<p><strong>未转义星号显示加粗</strong><br>** 转义显示星号 **</p>
<p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">`   反引号</span><br><span class="line"><span class="bullet">*</span>   星号</span><br><span class="line">_   下划线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  小括号</span><br><span class="line"><span class="section">#   井字号</span></span><br><span class="line"><span class="bullet">+</span>   加号</span><br><span class="line"><span class="bullet">-</span>   减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   感叹号</span><br></pre></td></tr></table></figure>



<hr>
<p>*** <strong>以下部分在Github或其他在线预览中暂未支持</strong> ***</p>
<hr>
<h3 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h3><p>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\mathbf&#123;V&#125;<span class="emphasis">_1 \times \mathbf&#123;V&#125;_</span>2 =  \begin&#123;vmatrix&#125;</span><br><span class="line">\mathbf&#123;i&#125; &amp; \mathbf&#123;j&#125; &amp; \mathbf&#123;k&#125; \\</span><br><span class="line">\frac&#123;\partial X&#125;&#123;\partial u&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial u&#125; &amp; 0 \\</span><br><span class="line">\frac&#123;\partial X&#125;&#123;\partial v&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial v&#125; &amp; 0 \\</span><br><span class="line">\end&#123;vmatrix&#125;</span><br><span class="line">$$tep1&#125;&#123;\style&#123;visibility:hidden&#125;&#123;(x+1)(x+1)&#125;&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>


<p>$$<br>\mathbf{V}_1 \times \mathbf{V}_2 &#x3D;  \begin{vmatrix}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \<br>\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \<br>\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \<br>\end{vmatrix}<br>$$</p>
<h3 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">​<span class="code">```chart</span></span><br><span class="line"><span class="code">,Budget,Income,Expenses,Debt</span></span><br><span class="line"><span class="code">June,5000,8000,4000,6000</span></span><br><span class="line"><span class="code">July,3000,1000,4000,3000</span></span><br><span class="line"><span class="code">Aug,5000,7000,6000,3000</span></span><br><span class="line"><span class="code">Sep,7000,2000,3000,1000</span></span><br><span class="line"><span class="code">Oct,6000,5000,4000,2000</span></span><br><span class="line"><span class="code">Nov,4000,3000,5000,</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">type: pie</span></span><br><span class="line"><span class="code">title: Monthly Revenue</span></span><br><span class="line"><span class="code">x.title: Amount</span></span><br><span class="line"><span class="code">y.title: Month</span></span><br><span class="line"><span class="code">y.suffix: $</span></span><br><span class="line"><span class="code">​```</span></span><br><span class="line">​<span class="code">```mermaid</span></span><br><span class="line"><span class="code">sequenceDiagram</span></span><br><span class="line"><span class="code">A-&gt;&gt;B: 是否已收到消息？</span></span><br><span class="line"><span class="code">B--&gt;&gt;A: 已收到消息</span></span><br><span class="line"><span class="code">​```</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：在Typora中未支持</p>
</blockquote>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">​<span class="code">```mermaid</span></span><br><span class="line"><span class="code">graph TD</span></span><br><span class="line"><span class="code">A[模块A] --&gt;|A1| B(模块B)</span></span><br><span class="line"><span class="code">B --&gt; C&#123;判断条件C&#125;</span></span><br><span class="line"><span class="code">C --&gt;|条件C1| D[模块D]</span></span><br><span class="line"><span class="code">C --&gt;|条件C2| E[模块E]</span></span><br><span class="line"><span class="code">C --&gt;|条件C3| F[模块F]</span></span><br><span class="line"><span class="code">​```</span></span><br></pre></td></tr></table></figure>

<p>流程图相关文章：</p>
<p><a href="https://www.jianshu.com/p/b421cc723da5">https://www.jianshu.com/p/b421cc723da5</a></p>
<p><a href="http://www.imooc.com/article/292708">http://www.imooc.com/article/292708</a></p>
<h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">​<span class="code">```mermaid</span></span><br><span class="line"><span class="code">sequenceDiagram</span></span><br><span class="line"><span class="code">A-&gt;&gt;B: 是否已收到消息？</span></span><br><span class="line"><span class="code">B--&gt;&gt;A: 已收到消息</span></span><br><span class="line"><span class="code">​```</span></span><br></pre></td></tr></table></figure>




<h3 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a>甘特图</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">​<span class="code">```mermaid</span></span><br><span class="line"><span class="code">gantt</span></span><br><span class="line"><span class="code">title 甘特图</span></span><br><span class="line"><span class="code">dateFormat  YYYY-MM-DD</span></span><br><span class="line"><span class="code">section 项目A</span></span><br><span class="line"><span class="code">任务1           :a1, 2018-06-06, 30d</span></span><br><span class="line"><span class="code">任务2     :after a1  , 20d</span></span><br><span class="line"><span class="code">section 项目B</span></span><br><span class="line"><span class="code">任务3      :2018-06-12  , 12d</span></span><br><span class="line"><span class="code">任务4      : 24d</span></span><br><span class="line"><span class="code">​```</span></span><br></pre></td></tr></table></figure>

<p>​																														     									<a href="#markdown%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B">回到顶部</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>NodeJS框架Express与Koa对比</title>
    <url>/post/57df6de567e2/</url>
    <content><![CDATA[<h1 id="NodeJS框架Express与Koa对比"><a href="#NodeJS框架Express与Koa对比" class="headerlink" title="NodeJS框架Express与Koa对比"></a>NodeJS框架Express与Koa对比</h1><h2 id="框架介绍"><a href="#框架介绍" class="headerlink" title="框架介绍"></a>框架介绍</h2><p>express框架是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，主要基于 Connect 中间件，并且自身封装了路由、视图处理等功能。</p>
<p>koa是 Express 原班人马基于 ES6 新特性重新开发的框架，主要基于 co 中间件，框架自身不包含任何中间件，很多功能需要借助第三方中间件解决，但是由于其基于 ES6 generator 特性的异步流程控制，解决了 “callback hell” 和麻烦的错误处理问题。</p>
<p><strong>相同点</strong><br>两个框架都对http进行了封装。相关的api都差不多，同一批人所写。</p>
<p><strong>不同点</strong><br>express内置了许多中间件可供使用，而koa没有。</p>
<p>express包含路由，视图渲染等特性，而koa只有http模块。</p>
<p>express的中间件模型为线型，而koa的中间件模型为U型，也可称为洋葱模型构造中间件。</p>
<p>express通过回调实现异步函数，在多个回调、多个中间件中写起来容易逻辑混乱。</p>
<h2 id="一、起步：创建一个简单的服务器"><a href="#一、起步：创建一个简单的服务器" class="headerlink" title="一、起步：创建一个简单的服务器"></a>一、起步：创建一个简单的服务器</h2><p>原生node</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="keyword">function</span> (<span class="params">request, response</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送 HTTP 头部 </span></span><br><span class="line">    <span class="comment">// HTTP 状态值: 200 : OK</span></span><br><span class="line">    <span class="comment">// 内容类型: text/plain</span></span><br><span class="line">    response.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送响应数据 &quot;Hello World&quot;</span></span><br><span class="line">    response.<span class="title function_">end</span>(<span class="string">&#x27;Hello World\n&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终端打印如下信息</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server running at http://127.0.0.1:8888/&#x27;</span>);</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="keyword">const</span> app=http.<span class="title function_">createServer</span>()</span><br><span class="line">app.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>express</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//express_demo.js 文件</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> app = <span class="title function_">express</span>();</span><br><span class="line"> </span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">   res.<span class="title function_">send</span>(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> server = app.<span class="title function_">listen</span>(<span class="number">8081</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">var</span> host = server.<span class="title function_">address</span>().<span class="property">address</span></span><br><span class="line">  <span class="keyword">var</span> port = server.<span class="title function_">address</span>().<span class="property">port</span></span><br><span class="line"> </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;应用实例，访问地址为 http://%s:%s&quot;</span>, host, port)</span><br><span class="line"> </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>koa</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入koa，和koa 1.x不同，在koa2中，我们导入的是一个class，因此用大写的Koa表示:</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Koa对象表示web app本身:</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于任何请求，app将调用该异步函数处理请求：</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;&lt;h1&gt;Hello, koa2!&lt;/h1&gt;&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在端口3000监听:</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;app started at port 3000...&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="二、请求和响应"><a href="#二、请求和响应" class="headerlink" title="二、请求和响应"></a>二、请求和响应</h2><p><strong>express</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">   <span class="comment">// request 和 response 对象来处理请求和响应的数据</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>koa</strong><br>参数ctx是由koa传入的封装了request和response的变量，我们可以通过它访问request和response，next是koa传入的将要处理的下一个异步函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    <span class="comment">// 设置response的Content-Type:</span></span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">    <span class="comment">// 设置response的内容:</span></span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;&lt;h1&gt;Hello, koa2!&lt;/h1&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、路由"><a href="#三、路由" class="headerlink" title="三、路由"></a>三、路由</h2><p><strong>原生node</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">&quot;./server&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> router = <span class="built_in">require</span>(<span class="string">&quot;./router&quot;</span>);</span><br><span class="line"> </span><br><span class="line">server.<span class="title function_">use</span>(router.<span class="property">route</span>);</span><br></pre></td></tr></table></figure>

<p><strong>express</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  GET 请求</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;主页 GET 请求&quot;</span>);</span><br><span class="line">   res.<span class="title function_">send</span>(<span class="string">&#x27;Hello GET&#x27;</span>);</span><br><span class="line">&#125;) </span><br><span class="line"><span class="comment">//  POST 请求</span></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;主页 POST 请求&quot;</span>);</span><br><span class="line">   res.<span class="title function_">send</span>(<span class="string">&#x27;Hello POST&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>koa</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  GET 请求    写法1：</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.<span class="property">request</span>.<span class="property">path</span> === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;index page&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//  GET 请求    写法2：</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)();<span class="comment">// 注意require(&#x27;koa-router&#x27;)返回的是函数:</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// add url-route:</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/hello/:name&#x27;</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> name = ctx.<span class="property">params</span>.<span class="property">name</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">`&lt;h1&gt;Hello, <span class="subst">$&#123;name&#125;</span>!&lt;/h1&gt;`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;&lt;h1&gt;Index&lt;/h1&gt;&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// add router middleware:</span></span><br><span class="line">app.<span class="title function_">use</span>(router.<span class="title function_">routes</span>());</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;app started at port 3000...&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="四、静态文件"><a href="#四、静态文件" class="headerlink" title="四、静态文件"></a>四、静态文件</h2><p><strong>express</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  Express 提供了内置的中间件 express.static 来设置静态文件如：img， CSS, JavaScript 等。</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/public&#x27;</span>, express.<span class="title function_">static</span>(<span class="string">&#x27;public&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>koa</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一：自己写一个处理方法</span></span><br><span class="line"><span class="keyword">let</span> staticFiles = <span class="built_in">require</span>(<span class="string">&#x27;./static-files&#x27;</span>);</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">staticFiles</span>(<span class="string">&#x27;/static/&#x27;</span>, __dirname + <span class="string">&#x27;/static&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：引一个包</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;koa-bodyparser&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Router</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>();</span><br><span class="line"><span class="keyword">const</span> render = <span class="built_in">require</span>(<span class="string">&#x27;koa-ejs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> serve = <span class="built_in">require</span>(<span class="string">&#x27;koa-static&#x27;</span>);</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">bodyParser</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">/**静态资源（服务端） */</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">serve</span>(path.<span class="title function_">join</span>(__dirname + <span class="string">&quot;/public&quot;</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化ejs，设置后缀为html，文件目录为`views`</span></span><br><span class="line"><span class="title function_">render</span>(app, &#123;</span><br><span class="line">    <span class="attr">root</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;views&#x27;</span>),</span><br><span class="line">    <span class="attr">layout</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">viewExt</span>: <span class="string">&#x27;html&#x27;</span>,</span><br><span class="line">    <span class="attr">cache</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">debug</span>: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 监听3000端口</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<h2 id="五、get-post传参接收方法"><a href="#五、get-post传参接收方法" class="headerlink" title="五、get\post传参接收方法"></a>五、get\post传参接收方法</h2><p><strong>原生node</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get </span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="keyword">function</span>(<span class="params">req, res</span>)&#123;</span><br><span class="line">    res.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span>&#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 解析 url 参数</span></span><br><span class="line">    <span class="keyword">var</span> params = url.<span class="title function_">parse</span>(req.<span class="property">url</span>, <span class="literal">true</span>).<span class="property">query</span>;</span><br><span class="line">    res.<span class="title function_">write</span>(<span class="string">&quot;网站名：&quot;</span> + params.<span class="property">name</span>);</span><br><span class="line">    res.<span class="title function_">write</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    res.<span class="title function_">write</span>(<span class="string">&quot;网站 URL：&quot;</span> + params.<span class="property">url</span>);</span><br><span class="line">    res.<span class="title function_">end</span>();</span><br><span class="line"> </span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">// post</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"></span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> body = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  req.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span> (<span class="params">chunk</span>) &#123;</span><br><span class="line">    body += chunk;</span><br><span class="line">  &#125;);</span><br><span class="line">  req.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 解析参数</span></span><br><span class="line">    body = querystring.<span class="title function_">parse</span>(body);</span><br><span class="line">    <span class="comment">// 设置响应头部信息及编码</span></span><br><span class="line">    res.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html; charset=utf8&#x27;</span>&#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(body.<span class="property">name</span> &amp;&amp; body.<span class="property">url</span>) &#123; <span class="comment">// 输出提交的数据</span></span><br><span class="line">        res.<span class="title function_">write</span>(<span class="string">&quot;网站名：&quot;</span> + body.<span class="property">name</span>);</span><br><span class="line">        res.<span class="title function_">write</span>(<span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">        res.<span class="title function_">write</span>(<span class="string">&quot;网站 URL：&quot;</span> + body.<span class="property">url</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 输出表单</span></span><br><span class="line">        res.<span class="title function_">write</span>(postHTML);</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="title function_">end</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p><strong>express</strong><br>get 传参接收方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/process_get&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 输出 JSON 格式</span></span><br><span class="line">   <span class="keyword">var</span> response = &#123;</span><br><span class="line">       <span class="string">&quot;first_name&quot;</span>:req.<span class="property">query</span>.<span class="property">first_name</span>,</span><br><span class="line">       <span class="string">&quot;last_name&quot;</span>:req.<span class="property">query</span>.<span class="property">last_name</span></span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">   res.<span class="title function_">end</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(response));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>post传参接收方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/process_post&#x27;</span>, urlencodedParser, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 输出 JSON 格式</span></span><br><span class="line">   <span class="keyword">var</span> response = &#123;</span><br><span class="line">       <span class="string">&quot;first_name&quot;</span>:req.<span class="property">body</span>.<span class="property">first_name</span>,</span><br><span class="line">       <span class="string">&quot;last_name&quot;</span>:req.<span class="property">body</span>.<span class="property">last_name</span></span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">   res.<span class="title function_">end</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(response));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>koa</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// POST</span></span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;koa-bodyparser&#x27;</span>);</span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/signin&#x27;</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">        name = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">name</span> || <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        password = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">password</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`signin with name: <span class="subst">$&#123;name&#125;</span>, password: <span class="subst">$&#123;password&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">if</span> (name === <span class="string">&#x27;koa&#x27;</span> &amp;&amp; password === <span class="string">&#x27;12345&#x27;</span>) &#123;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">`&lt;h1&gt;Welcome, <span class="subst">$&#123;name&#125;</span>!&lt;/h1&gt;`</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">`&lt;h1&gt;Login failed!&lt;/h1&gt;</span></span><br><span class="line"><span class="string">        &lt;p&gt;&lt;a href=&quot;/&quot;&gt;Try again&lt;/a&gt;&lt;/p&gt;`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">bodyParser</span>());</span><br></pre></td></tr></table></figure>



<h2 id="六、cookie管理"><a href="#六、cookie管理" class="headerlink" title="六、cookie管理"></a>六、cookie管理</h2><p><strong>express</strong><br>使用中间件向 Node.js 服务器发送 cookie 信息</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// express_cookie.js 文件</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> cookieParser = <span class="built_in">require</span>(<span class="string">&#x27;cookie-parser&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> app = <span class="title function_">express</span>()</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cookieParser</span>())</span><br><span class="line"> </span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Cookies: &quot;</span> + util.<span class="title function_">inspect</span>(req.<span class="property">cookies</span>));</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">8081</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
        <tag>Express</tag>
        <tag>Koa</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是 Proxy</title>
    <url>/post/913d762db9ee/</url>
    <content><![CDATA[<h2 id="什么是-Proxy"><a href="#什么是-Proxy" class="headerlink" title="什么是 Proxy"></a>什么是 Proxy</h2><p>通常，当谈到JavaScript语言时，我们讨论的是ES6标准提供的新特性，本文也不例外。 我们将讨论JavaScript代理以及它们的作用，但在我们深入研究之前，我们先来看一下Proxy的定义是什么。</p>
<p>MDN上的定义是：代理对象是用于定义基本操作的自定义行为（例如，属性查找，赋值，枚举，函数调用等）。</p>
<p>换句话说，我们可以说代理对象是我们的目标对象的包装器，我们可以在其中操纵其属性并阻止对它的直接访问。 你可能会发现将它们应用到实际代码中很困难，我鼓励你仔细阅读这个概念，它可能会改变你的观点。</p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>handler</p>
<p>包含陷阱（traps）的占位符对象。</p>
<p>traps</p>
<p>提供属性访问的方法。这类似于操作系统中捕获器的概念。</p>
<p>target</p>
<p>代理虚拟化的对象。(由代理对象包装和操作的实际对象)</p>
<p>在本文中，我将为 get 和 set 陷阱 提供简单的用例，考虑到最后，我们将看到如何使用它们并包含更复杂的功能，如API。</p>
<h3 id="语法和用例"><a href="#语法和用例" class="headerlink" title="语法和用例"></a>语法和用例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>
<p>将目标和处理程序传递给Proxy构造函数，这样就创建了一个proxy对象。现在，让我们看看如何利用它。为了更清楚地看出Proxy的好处，首先，我们需要编写一些没有它的代码。</p>
<p>想象一下，我们有一个带有几个属性的用户对象，如果属性存在，我们想要打印用户信息，如果不存在，则抛出异常。在不使用代理对象时，判断属性值是否存在的代码也放在了打印用户信息的函数，即 printUser 中(这并不是我们所希望的)，如下demo所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">    <span class="attr">surname</span>: <span class="string">&#x27;Doe&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">printUser</span> = (<span class="params">property</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> value = user[property];</span><br><span class="line">    <span class="keyword">if</span> (!value) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`The property [<span class="subst">$&#123;property&#125;</span>] does not exist`</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`The user <span class="subst">$&#123;property&#125;</span> is <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printUser</span>(<span class="string">&#x27;name&#x27;</span>); <span class="comment">// 输出: &#x27;The user name is John&#x27;</span></span><br><span class="line"><span class="title function_">printUser</span>(<span class="string">&#x27;email&#x27;</span>); <span class="comment">// 抛出错误: The property [email] does not exist</span></span><br></pre></td></tr></table></figure>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>通过查看上面的代码，你会发现：将条件和异常移到其他地方，而printUser中仅关注显示用户信息的实际逻辑会更好。这是我们可以使用代理对象的地方，让我们更新一下这个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">    <span class="attr">surname</span>: <span class="string">&#x27;Doe&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(user, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> value = target[property];</span><br><span class="line">        <span class="keyword">if</span> (!value) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`The property [<span class="subst">$&#123;property&#125;</span>] does not exist`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">printUser</span> = (<span class="params">property</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`The user <span class="subst">$&#123;property&#125;</span> is <span class="subst">$&#123;proxy[property]&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printUser</span>(<span class="string">&#x27;name&#x27;</span>); <span class="comment">// 输出： &#x27;The user name is John&#x27;</span></span><br><span class="line"><span class="title function_">printUser</span>(<span class="string">&#x27;email&#x27;</span>); <span class="comment">// 抛出错误: The property [email] does not exist</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们包装了 user 对象，并设置了一个 get 方法。 此方法充当拦截器，在返回值之前，会首先对属性值进行检查，如果不存在，则抛出异常。</p>
<p>输出与第一种情况相同，但此时 printUser 函数专注于逻辑，只处理消息。</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>代理可能有用的另一个例子是属性值验证。在这种情况下，我们需要使用 set 方法，并在其中进行验证。例如，当我们需要确保目标类型时，这是一个非常有用的钩子。我们来看一下实际使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, property, value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (property === <span class="string">&#x27;name&#x27;</span> &amp;&amp; <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(value) !== <span class="string">&#x27;[object String]&#x27;</span>) &#123; <span class="comment">// 确保是 string 类型</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`The value for [<span class="subst">$&#123;property&#125;</span>] must be a string`</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        target[property] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">user.<span class="property">name</span> = <span class="number">1</span>; <span class="comment">// 抛出错误: The value for [name] must be a string</span></span><br></pre></td></tr></table></figure>
<p>这些是相当简单的用例，以下场景，proxy均可以派上用场：</p>
<ul>
<li>格式化</li>
<li>价值和类型修正</li>
<li>数据绑定</li>
<li>调试</li>
<li>…<br>现在是时候创建一个更复杂的用例了。</li>
</ul>
<h3 id="具有代理的API-更复杂的示例"><a href="#具有代理的API-更复杂的示例" class="headerlink" title="具有代理的API - 更复杂的示例"></a>具有代理的API - 更复杂的示例</h3><p>通过使用简单用例中的知识，我们可以创建一个API包装器，以便在我们的应用程序中使用。 当前只支持 get 和 post 请求，但它可以很容易地扩展。代码如下所示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> api = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, context</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> target[key] || [<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;post&#x27;</span>].<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, key</span>) =&gt;</span> &#123;</span><br><span class="line">            acc[key] = <span class="function">(<span class="params">config, data</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!config &amp;&amp; !config.<span class="property">url</span> || config.<span class="property">url</span> === <span class="string">&#x27;&#x27;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Url cannot be empty.&#x27;</span>);</span><br><span class="line">                <span class="keyword">let</span> isPost = key === <span class="string">&#x27;post&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isPost &amp;&amp; !data) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Please provide data in JSON format when using POST request.&#x27;</span>);</span><br><span class="line"></span><br><span class="line">                config.<span class="property">headers</span> = isPost ? <span class="title class_">Object</span>.<span class="title function_">assign</span>(config.<span class="property">headers</span> || &#123;&#125;, &#123; <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;application/json;chartset=utf8&#x27;</span> &#125;) :</span><br><span class="line">                    config.<span class="property">headers</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">                    xhr.<span class="title function_">open</span>(key, config.<span class="property">url</span>);</span><br><span class="line">                    <span class="keyword">if</span> (config.<span class="property">headers</span>) &#123;</span><br><span class="line">                        <span class="title class_">Object</span>.<span class="title function_">keys</span>(config.<span class="property">headers</span>).<span class="title function_">forEach</span>(<span class="function">(<span class="params">header</span>) =&gt;</span> &#123;</span><br><span class="line">                            xhr.<span class="title function_">setRequestHeader</span>(header, config.<span class="property">headers</span>[header]);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    xhr.<span class="property">onload</span> = <span class="function">() =&gt;</span> (xhr.<span class="property">status</span> === <span class="number">200</span> ? resolve : reject)(xhr);</span><br><span class="line">                    xhr.<span class="property">onerror</span> = <span class="function">() =&gt;</span> <span class="title function_">reject</span>(xhr);</span><br><span class="line">                    xhr.<span class="title function_">send</span>(isPost ? <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data) : <span class="literal">null</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> acc;</span><br><span class="line">        &#125;, target)[key];</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;API methods are readonly&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">deleteProperty</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;API methods cannot be deleted!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>让我们解释一下简单实现，set 和 deleteProperty。 我们添加了一个保护级别，并确保每当有人意外或无意地尝试为任何API属性设置新值时，都会抛出异常。</p>
<p>每次尝试删除属性时都会调用 deleteProperty 方法。可以确保没有人可以从我们的代理(即此处的 api)中删除任何属性，因为通常我们都不想丢失API方法。</p>
<p>get 在这里很有趣，它做了几件事。target 是一个空对象，get 方法将在第一次有人使用 api 时创建所有方法(如当前的 get 和 post请求)，在 reduce 回调中，我们根据提供的配置执行API规范所需的验证和检查。在此示例中，我们不允许空URL和发布请求而不提供数据。这些检查可以扩展和修改，但重要的是我们只能在这一个地方集中处理。</p>
<p>reduce 仅在第一次API调用时完成，之后都会跳过整个 reduce 进程，get 只会执行默认行为并返回属性值，即API处理程序。每个处理程序返回一个Promise对象，负责创建请求并调用服务。</p>
<p>使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">api.<span class="title function_">get</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;my-url&#x27;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">xhr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line">&#125;, <span class="function">(<span class="params">xhr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;Fail&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete api.get; //throw new Error(&#x27;API methods cannot be deleted!&#x27;); </span><br></pre></td></tr></table></figure>
<p>结论</p>
<p>当您需要对数据进行更多控制时，代理可以派上用场。你可以根据受控规则扩展或拒绝对原始数据的访问，从而监视对象并确保正确行为。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Set、Map、WeakSet、WeakMap是什么</title>
    <url>/post/a9a087945710/</url>
    <content><![CDATA[<h3 id="Set、Map、WeakSet、WeakMap"><a href="#Set、Map、WeakSet、WeakMap" class="headerlink" title="Set、Map、WeakSet、WeakMap"></a>Set、Map、WeakSet、WeakMap</h3><p>如果要用一句来描述，我们可以说<br><strong>Set是一种叫做集合的数据结构，Map是一种叫做字典的数据结构</strong></p>
<p>那什么是集合？什么又是字典呢？</p>
<ul>
<li>集合</li>
</ul>
<blockquote>
<p>集合，是由一堆无序的、相关联的，且不重复的内存结构【数学中称为元素】组成的组合</p>
</blockquote>
<ul>
<li>字典</li>
</ul>
<blockquote>
<p>字典（dictionary）是一些元素的集合。每个元素有一个称作key 的域，不同元素的key 各不相同</p>
</blockquote>
<p>那么集合和字典又有什么区别呢？</p>
<ul>
<li>共同点：集合、字典都可以存储不重复的值</li>
<li>不同点：集合是以[值，值]的形式存储元素，字典是以[键，值]的形式存储</li>
</ul>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>大多数主流编程语言都有多种内置的数据集合。例如<code>Python</code>拥有列表（<code>list</code>）、元组（<code>tuple</code>）和字典（<code>dictionary</code>）,Java有列表（<code>list</code>）、集合（<code>set</code>)、队列（<code>queue</code>）</p>
<p>然而  <code>JavaScript</code> 直到<code>ES6</code>的发布之前，只拥有数组（<code>array</code>）和对象（<code>object</code>）这两个内建的数据集合</p>
<p>在 <code>ES6</code> 之前,我们通常使用内置的 <code>Object</code> 模拟Map</p>
<p>但是这样模拟出来的<code>map</code>会有一些缺陷，如下:</p>
<ol>
<li><code>Object</code>的属性键是<code>String</code>或<code>Symbol</code>，这限制了它们作为不同数据类型的键&#x2F;值对集合的能力</li>
<li><code>Object</code>不是设计来作为一种数据集合，因此没有直接有效的方法来确定对象具有多少属性</li>
</ol>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><blockquote>
<p>定义: <code>Set</code> 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用，<code>Set</code>对象是值的集合，你可以按照插入的顺序迭代它的元素。 <code>Set</code>中的元素只会出现一次，即 <code>Set</code> 中的元素是唯一的</p>
</blockquote>
<p><code>Set</code>本身是一个构造函数，用来生成 <code>Set</code> 数据结构</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ul>
<li>语法<br><code>new Set([iterable])</code> 接收一个数组（或者具有 iterable 接口的其他数据结构）, 返回一个新的<code>Set</code>对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set) <span class="comment">// &#123;1,2&#125; </span></span><br></pre></td></tr></table></figure>
<p>上面代码可以看出 <code>Set</code> 是可以去除数组中的重复元素</p>
<h3 id="属性及方法"><a href="#属性及方法" class="headerlink" title="属性及方法"></a>属性及方法</h3><p><strong>属性</strong></p>
<ul>
<li>size: 返回集合中所包含的元素的数量<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]).<span class="property">size</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<strong>操作方法</strong></li>
<li>add(value): 向集合中添加一个新的项</li>
<li>delete(value): 从集合中删除一个值</li>
<li>has(value): 如果值在集合中存在，返回ture, 否则返回false</li>
<li>clear(): 移除集合中的所有项</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">1</span>)</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">2</span>)</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">2</span>)</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set) <span class="comment">// &#123;1,2,3&#125;</span></span><br><span class="line">set.<span class="title function_">has</span>(<span class="number">2</span>) <span class="comment">// true</span></span><br><span class="line">set.<span class="title function_">delete</span>(<span class="number">2</span>)  </span><br><span class="line">set.<span class="title function_">has</span>(<span class="number">2</span>) <span class="comment">// false</span></span><br><span class="line">set.<span class="title function_">clear</span>() </span><br></pre></td></tr></table></figure>

<p><strong>遍历方法</strong></p>
<ul>
<li>keys(): 返回键名的遍历器</li>
<li>values(): 返回键值的遍历器</li>
<li>entries(): 返回键值对的遍历器</li>
<li>forEach(): 使用回调函数遍历每个成员</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于set只有键值，没有键名，所以keys() values()行为完全一致</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(set.<span class="title function_">keys</span>())) <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(set.<span class="title function_">values</span>())) <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(set.<span class="title function_">entries</span>())) <span class="comment">//  [[1,1],[2,2],[3,3],[4,4]]</span></span><br><span class="line"></span><br><span class="line">set.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(item)&#125;) <span class="comment">// 1,2,3,4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>因为 <code>Set</code> 结构的值是唯一的，我们可以很轻松的实现以下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组去重</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> unique = [... <span class="keyword">new</span> <span class="title class_">Set</span>(arr)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = [...<span class="keyword">new</span> <span class="title class_">Set</span>([...a, ...b])]; <span class="comment">// [1,2,3,4]</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = [...<span class="keyword">new</span> <span class="title class_">Set</span>([...a].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> b.<span class="title function_">has</span>(x)))]; [<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>([...a].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> !b.<span class="title function_">has</span>(x)))); [<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><blockquote>
<p>WeakSet 对象是一些对象值的集合, 并且其中的每个对象值都只能出现一次。在WeakSet的集合中是唯一的</p>
</blockquote>
<p><code>WeakSet</code> 的出现主要解决弱引用对象存储的场景, 其结构与<code>Set</code>类似</p>
<p>与<code>Set</code>的区别</p>
<ul>
<li>与Set相比，WeakSet 只能是对象的集合，而不能是任何类型的任意值</li>
<li>WeakSet集合中对象的引用为弱引用。 如果没有其他的对WeakSet中对象的引用，那么这些对象会被当成垃圾回收掉。 这也意味着WeakSet中没有存储当前对象的列表。 正因为这样，WeakSet 是不可枚举的</li>
</ul>
<p><code>WeakSet</code> 的属性跟操作方法与 <code>Set</code> 一致，不同的是 <code>WeakSet</code> 没有遍历方法，因为其成员都是弱引用，弱引用随时都会消失，遍历机制无法保证成员的存在</p>
<p><strong>上面一直有提到弱引用，那弱引用到底是指什么呢？</strong></p>
<blockquote>
<p>弱引用是指不能确保其引用的对象不会被垃圾回收器回收的引用，换句话说就是可能在任意时间被回收</p>
</blockquote>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><blockquote>
<p>Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值(对象或者原始值) 都可以作为一个键或一个值。一个Map对象在迭代时会根据对象中元素的插入顺序来进行 — 一个  for…of 循环在每次迭代后会返回一个形式为[key，value]的数组</p>
</blockquote>
<h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><ul>
<li>语法</li>
</ul>
<p><code>new Map([iterable])</code> <code>Iterable</code> 可以是一个数组或者其他 <code>iterable</code> 对象，其元素为键值对(两个元素的数组，例如: [[ 1, ‘one’ ],[ 2, ‘two’ ]])。 每个键值对都会添加到新的 <code>Map</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;vuejs.cn&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h3 id="属性及方法-1"><a href="#属性及方法-1" class="headerlink" title="属性及方法"></a>属性及方法</h3><p>基本跟 <code>Set</code> 类似，同样具有如下方法<br><strong>属性</strong></p>
<ul>
<li>size: 返回 Map 结构的元素总数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;vuejs.cn&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="property">size</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;vue3js.cn&#x27;</span>], [<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;18&#x27;</span>]]).<span class="property">size</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<strong>操作方法</strong></li>
<li>set(key, value): 向 Map 中加入或更新键值对</li>
<li>get(key): 读取 key 对用的值，如果没有，返回 undefined</li>
<li>has(key): 某个键是否在 Map 对象中，在返回 true 否则返回 false</li>
<li>delete(key): 删除某个键，返回 true, 如果删除失败返回 false</li>
<li>clear(): 删除所有元素</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;vue3js.cn&#x27;</span>)</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;18&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map) <span class="comment">// Map &#123;&quot;name&quot; =&gt; &quot;vuejs.cn&quot;, &quot;age&quot; =&gt; &quot;18&quot;&#125;</span></span><br><span class="line">map.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>) <span class="comment">// vue3js.cn </span></span><br><span class="line">map.<span class="title function_">has</span>(<span class="string">&#x27;name&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">map.<span class="title function_">delete</span>(<span class="string">&#x27;name&#x27;</span>)  </span><br><span class="line">map.<span class="title function_">has</span>(name) <span class="comment">// false</span></span><br><span class="line">map.<span class="title function_">clear</span>() <span class="comment">// Map &#123;&#125; </span></span><br></pre></td></tr></table></figure>
<p><strong>遍历方法</strong></p>
<ul>
<li>keys()：返回键名的遍历器</li>
<li>values()：返回键值的遍历器</li>
<li>entries()：返回所有成员的遍历器</li>
<li>forEach()：遍历 Map 的所有成员</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;vue3js.cn&#x27;</span>)</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;18&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...map.<span class="title function_">keys</span>()])  <span class="comment">// [&quot;name&quot;, &quot;age&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...map.<span class="title function_">values</span>()])  <span class="comment">// [&quot;vue3js.cn&quot;, &quot;18&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...map.<span class="title function_">entries</span>()]) <span class="comment">// [[&#x27;name&#x27;,&#x27;vue3js.cn&#x27;], [&#x27;age&#x27;,&#x27;18&#x27;]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// name vuejs.cn</span></span><br><span class="line"><span class="comment">// age 18</span></span><br><span class="line">map.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value)&#125;) </span><br></pre></td></tr></table></figure>

<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p><code>Map</code> 会保留所有元素的顺序, 是在基于可迭代的基础上构建的，如果考虑到元素迭代或顺序保留或键值类型丰富的情况下都可以使用，下面摘抄自 <code>vue3</code> 源码中依赖收集的核心实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line"><span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">  targetMap.<span class="title function_">set</span>(target, (depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dep = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line"><span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">  depsMap.<span class="title function_">set</span>(key, (dep = <span class="keyword">new</span> <span class="title class_">Set</span>()))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!dep.<span class="title function_">has</span>(activeEffect)) &#123;</span><br><span class="line">  dep.<span class="title function_">add</span>(activeEffect)</span><br><span class="line">  activeEffect.<span class="property">deps</span>.<span class="title function_">push</span>(dep)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><blockquote>
<p>WeakMap 对象是一组键&#x2F;值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的</p>
</blockquote>
<p>与<code>Map</code>的区别</p>
<ul>
<li>Map 的键可以是任意类型，WeakMap 的键只能是对象类型 </li>
<li>WeakMap 键名所指向的对象，不计入垃圾回收机制</li>
</ul>
<p><code>WeakMap</code> 的属性跟操作方法与 <code>Map</code> 一致，同 <code>WeakSet</code> 一样，因为是弱引用，所以 <code>WeakSet</code> 也没有遍历方法</p>
<h2 id="类型的转换"><a href="#类型的转换" class="headerlink" title="类型的转换"></a>类型的转换</h2><ul>
<li><code>Map</code> 转为 <code>Array</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解构</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">3</span>]])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...map])	<span class="comment">// [[1, 1], [2, 2], [3, 3]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from()</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">3</span>]])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(map))	<span class="comment">// [[1, 1], [2, 2], [3, 3]]</span></span><br></pre></td></tr></table></figure></li>
<li><code>Array</code> 转为 <code>Map</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">3</span>]])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map)	<span class="comment">// Map &#123;1 =&gt; 1, 2 =&gt; 2, 3 =&gt; 3&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><code>Map</code> 转为 <code>Object</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非字符串键名会被转换为字符串</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mapToObj</span>(<span class="params">map</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">        obj[key] = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;vue3js.cn&#x27;</span>).<span class="title function_">set</span>(<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;18&#x27;</span>)</span><br><span class="line"><span class="title function_">mapToObj</span>(map)  <span class="comment">// &#123;name: &quot;vue3js.cn&quot;, age: &quot;18&quot;&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><code>Object</code> 转为 <code>Map</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>, <span class="string">&quot;b&quot;</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(obj))</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Set、Map、WeakSet、WeakMap、都是一种集合的数据结构</li>
<li>Set、WeakSet 是[值,值]的集合，且具有唯一性 </li>
<li>Map 和 WeakMap 是一种[键,值]的集合，Map 的键可以是任意类型，WeakMap 的键只能是对象类型</li>
<li>Set 和 Map 有遍历方法，WeakSet 和 WeakMap 属于弱引用不可遍历</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%BC%B1%E5%BC%95%E7%94%A8">https://zh.wikipedia.org/wiki/%E5%BC%B1%E5%BC%95%E7%94%A8</a></li>
<li><a href="https://developer.mozilla.org/">https://developer.mozilla.org/</a>  </li>
<li><a href="https://es6.ruanyifeng.com/">https://es6.ruanyifeng.com/</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？</title>
    <url>/post/582971d4aea1/</url>
    <content><![CDATA[<h1 id="面试官：Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？"><a href="#面试官：Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？" class="headerlink" title="面试官：Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？"></a>面试官：Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？</h1><p> <img src="https://static.vue-js.com/8d6dd7b0-6048-11eb-85f6-6fac77c0c9b3.png"></p>
<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p><code>Composition API</code> 可以说是<code>Vue3</code>的最大特点，那么为什么要推出<code>Composition Api</code>，解决了什么问题？</p>
<p>通常使用<code>Vue2</code>开发的项目，普遍会存在以下问题：</p>
<ul>
<li>代码的可读性随着组件变大而变差</li>
<li>每一种代码复用的方式，都存在缺点</li>
<li>TypeScript支持有限</li>
</ul>
<p>以上通过使用<code>Composition Api</code>都能迎刃而解</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="一、Options-Api"><a href="#一、Options-Api" class="headerlink" title="一、Options Api"></a>一、Options Api</h3><p><code>Options API</code>，即大家常说的选项API，即以<code>vue</code>为后缀的文件，通过定义<code>methods</code>，<code>computed</code>，<code>watch</code>，<code>data</code>等属性与方法，共同处理页面逻辑</p>
<p>如下图：</p>
<p> <img src="https://static.vue-js.com/9bf6d9d0-6048-11eb-85f6-6fac77c0c9b3.png"></p>
<p>可以看到<code>Options</code>代码编写方式，如果是组件状态，则写在<code>data</code>属性上，如果是方法，则写在<code>methods</code>属性上…</p>
<p>用组件的选项 (<code>data</code>、<code>computed</code>、<code>methods</code>、<code>watch</code>) 组织逻辑在大多数情况下都有效</p>
<p>然而，当组件变得复杂，导致对应属性的列表也会增长，这可能会导致组件难以阅读和理解</p>
<h3 id="二、Composition-Api"><a href="#二、Composition-Api" class="headerlink" title="二、Composition Api"></a>二、Composition Api</h3><p>在 Vue3 Composition API 中，组件根据逻辑功能来组织的，一个功能所定义的所有 API 会放在一起（更加的高内聚，低耦合）</p>
<p>即使项目很大，功能很多，我们都能快速的定位到这个功能所用到的所有 API</p>
<p> <img src="https://static.vue-js.com/acee9200-6048-11eb-ab90-d9ae814b240d.png"></p>
<h3 id="三、对比"><a href="#三、对比" class="headerlink" title="三、对比"></a>三、对比</h3><p>下面对<code>Composition Api </code>与<code>Options Api</code>进行两大方面的比较</p>
<ul>
<li>逻辑组织</li>
<li>逻辑复用</li>
</ul>
<h4 id="逻辑组织"><a href="#逻辑组织" class="headerlink" title="逻辑组织"></a>逻辑组织</h4><h5 id="Options-API"><a href="#Options-API" class="headerlink" title="Options API"></a>Options API</h5><p>假设一个组件是一个大型组件，其内部有很多处理逻辑关注点（对应下图不用颜色）</p>
<p> <img src="https://static.vue-js.com/dc83d070-6048-11eb-ab90-d9ae814b240d.png"></p>
<p>可以看到，这种碎片化使得理解和维护复杂组件变得困难</p>
<p>选项的分离掩盖了潜在的逻辑问题。此外，在处理单个逻辑关注点时，我们必须不断地“跳转”相关代码的选项块</p>
<h5 id="Compostion-API"><a href="#Compostion-API" class="headerlink" title="Compostion API"></a>Compostion API</h5><p>而<code>Compositon API</code>正是解决上述问题，将某个逻辑关注点相关的代码全都放在一个函数里，这样当需要修改一个功能时，就不再需要在文件中跳来跳去</p>
<p>下面举个简单例子，将处理<code>count</code>属性相关的代码放在同一个函数了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useCount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="title function_">ref</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">let</span> double = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count.<span class="property">value</span> * <span class="number">2</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleConut</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        count.<span class="property">value</span> = count.<span class="property">value</span> * <span class="number">2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        count,</span><br><span class="line">        double,</span><br><span class="line">        handleConut,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件上中使用<code>count</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; count, double, handleConut &#125; = <span class="title function_">useCount</span>();</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            count,</span><br><span class="line">            double,</span><br><span class="line">            handleConut</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>再来一张图进行对比，可以很直观地感受到 <code>Composition API </code>在逻辑组织方面的优势，以后修改一个属性功能的时候，只需要跳到控制该属性的方法中即可</p>
<p><img src="https://static.vue-js.com/e5804bc0-5c58-11eb-85f6-6fac77c0c9b3.png"></p>
<h4 id="逻辑复用"><a href="#逻辑复用" class="headerlink" title="逻辑复用"></a>逻辑复用</h4><p>在<code>Vue2</code>中，我们是用过<code>mixin</code>去复用相同的逻辑</p>
<p>下面举个例子，我们会另起一个<code>mixin.js</code>文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">MoveMixin</span> = &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">y</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">handleKeyup</span>(<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">code</span>);</span><br><span class="line">      <span class="comment">// 上下左右 x y</span></span><br><span class="line">      <span class="keyword">switch</span> (e.<span class="property">code</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ArrowUp&quot;</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">y</span>--;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ArrowDown&quot;</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">y</span>++;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ArrowLeft&quot;</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">x</span>--;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ArrowRight&quot;</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">x</span>++;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;keyup&quot;</span>, <span class="variable language_">this</span>.<span class="property">handleKeyup</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">unmounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;keyup&quot;</span>, <span class="variable language_">this</span>.<span class="property">handleKeyup</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在组件中使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Mouse position: x &#123;&#123; x &#125;&#125; / y &#123;&#123; y &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> mousePositionMixin <span class="keyword">from</span> <span class="string">&#x27;./mouse&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">mixins</span>: [mousePositionMixin]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>使用单个<code>mixin</code>似乎问题不大，但是当我们一个组件混入大量不同的 <code>mixins</code> 的时候</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">mixins</span>: [mousePositionMixin, fooMixin, barMixin, otherMixin]</span><br></pre></td></tr></table></figure>

<p>会存在两个非常明显的问题：</p>
<ul>
<li>命名冲突</li>
<li>数据来源不清晰</li>
</ul>
<p>现在通过<code>Compositon API</code>这种方式改写上面的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; onMounted, onUnmounted, reactive &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useMove</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> position = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleKeyup</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">code</span>);</span><br><span class="line">    <span class="comment">// 上下左右 x y</span></span><br><span class="line">    <span class="keyword">switch</span> (e.<span class="property">code</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ArrowUp&quot;</span>:</span><br><span class="line">        <span class="comment">// y.value--;</span></span><br><span class="line">        position.<span class="property">y</span>--;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ArrowDown&quot;</span>:</span><br><span class="line">        <span class="comment">// y.value++;</span></span><br><span class="line">        position.<span class="property">y</span>++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ArrowLeft&quot;</span>:</span><br><span class="line">        <span class="comment">// x.value--;</span></span><br><span class="line">        position.<span class="property">x</span>--;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ArrowRight&quot;</span>:</span><br><span class="line">        <span class="comment">// x.value++;</span></span><br><span class="line">        position.<span class="property">x</span>++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;keyup&quot;</span>, handleKeyup);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onUnmounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;keyup&quot;</span>, handleKeyup);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; position &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在组件中使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Mouse position: x &#123;&#123; x &#125;&#125; / y &#123;&#123; y &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; useMove &#125; <span class="keyword">from</span> <span class="string">&quot;./useMove&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; toRefs &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> &#123; position &#125; = <span class="title function_">useMove</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> &#123; x, y &#125; = <span class="title function_">toRefs</span>(position);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      x,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      y,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>可以看到，整个数据来源清晰了，即使去编写更多的 hook 函数，也不会出现命名冲突的问题</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>在逻辑组织和逻辑复用方面，<code>Composition API</code>是优于<code>Options  API</code></li>
<li>因为<code>Composition API</code>几乎是函数，会有更好的类型推断。</li>
<li><code>Composition API </code>对 <code>tree-shaking</code> 友好，代码也更容易压缩</li>
<li><code>Composition API</code>中见不到<code>this</code>的使用，减少了<code>this</code>指向不明的情况</li>
<li>如果是小型组件，可以继续使用<code>Options API</code>，也是十分友好的</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>面试官：Vue3.0里为什么要用 Proxy API 替代 defineProperty API</title>
    <url>/post/95f7ade9b089/</url>
    <content><![CDATA[<h1 id="面试官：Vue3-0里为什么要用-Proxy-API-替代-defineProperty-API-？"><a href="#面试官：Vue3-0里为什么要用-Proxy-API-替代-defineProperty-API-？" class="headerlink" title="面试官：Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？"></a>面试官：Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？</h1><p> <img src="https://static.vue-js.com/57aa5c80-5f7f-11eb-ab90-d9ae814b240d.png"></p>
<h2 id="一、Object-defineProperty"><a href="#一、Object-defineProperty" class="headerlink" title="一、Object.defineProperty"></a>一、Object.defineProperty</h2><p>定义：<code>Object.defineProperty()</code> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象</p>
<h5 id="为什么能实现响应式"><a href="#为什么能实现响应式" class="headerlink" title="为什么能实现响应式"></a>为什么能实现响应式</h5><p>通过<code>defineProperty</code> 两个属性，<code>get</code>及<code>set</code></p>
<ul>
<li>get</li>
</ul>
<p>属性的 getter 函数，当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值</p>
<ul>
<li>set</li>
</ul>
<p>属性的 setter 函数，当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。默认为 undefined</p>
<p>下面通过代码展示：</p>
<p>定义一个响应式函数<code>defineReactive</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    app.<span class="property">innerText</span> = obj.<span class="property">foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, key, val</span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`get <span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newVal !== val) &#123;</span><br><span class="line">                val = newVal</span><br><span class="line">                <span class="title function_">update</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>defineReactive</code>，数据发生变化触发<code>update</code>方法，实现数据响应式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="title function_">defineReactive</span>(obj, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    obj.<span class="property">foo</span> = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toLocaleTimeString</span>()</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>在对象存在多个<code>key</code>情况下，需要进行遍历</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">defineReactive</span>(obj, key, obj[key])</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果存在嵌套对象的情况，还需要在<code>defineReactive</code>中进行递归</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, key, val</span>) &#123;</span><br><span class="line">    <span class="title function_">observe</span>(val)</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`get <span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newVal !== val) &#123;</span><br><span class="line">                val = newVal</span><br><span class="line">                <span class="title function_">update</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当给<code>key</code>赋值为对象的时候，还需要在<code>set</code>属性中进行递归</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newVal !== val) &#123;</span><br><span class="line">        <span class="title function_">observe</span>(newVal) <span class="comment">// 新值是对象的情况</span></span><br><span class="line">        <span class="title function_">notifyUpdate</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述例子能够实现对一个对象的基本响应式，但仍然存在诸多问题</p>
<p>现在对一个对象进行删除与添加属性操作，无法劫持到</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="string">&quot;bar&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">observe</span>(obj)</span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">foo</span> <span class="comment">// no ok</span></span><br><span class="line">obj.<span class="property">jar</span> = <span class="string">&#x27;xxx&#x27;</span> <span class="comment">// no ok</span></span><br></pre></td></tr></table></figure>

<p>当我们对一个数组进行监听的时候，并不那么好使了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arrData = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">arrData.<span class="title function_">forEach</span>(<span class="function">(<span class="params">val,index</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">defineProperty</span>(arrData,index,val)</span><br><span class="line">&#125;)</span><br><span class="line">arrData.<span class="title function_">push</span>() <span class="comment">// no ok</span></span><br><span class="line">arrData.<span class="title function_">pop</span>()  <span class="comment">// no ok</span></span><br><span class="line">arrDate[<span class="number">0</span>] = <span class="number">99</span> <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>可以看到数据的<code>api</code>无法劫持到，从而无法实现数据响应式，</p>
<p>所以在<code>Vue2</code>中，增加了<code>set</code>、<code>delete</code> API，并且对数组<code>api</code>方法进行一个重写</p>
<p>还有一个问题则是，如果存在深层的嵌套对象关系，需要深层的进行监听，造成了性能的极大问题</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>检测不到对象属性的添加和删除</li>
<li>数组<code>API</code>方法无法监听到</li>
<li>需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题</li>
</ul>
<h2 id="二、proxy"><a href="#二、proxy" class="headerlink" title="二、proxy"></a>二、proxy</h2><p><code>Proxy</code>的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，这就完全可以代理所有属性了</p>
<p>在<code>ES6</code>系列中，我们详细讲解过<code>Proxy</code>的使用，就不再述说了</p>
<p>下面通过代码进行展示：</p>
<p>定义一个响应式方法<code>reactive</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> &amp;&amp; obj != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Proxy相当于在对象外层加拦截</span></span><br><span class="line">    <span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`获取<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`设置<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">deleteProperty</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, key)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`删除<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> observed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试一下简单数据的操作，发现都能劫持</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1.获取</span></span><br><span class="line">state.<span class="property">foo</span> <span class="comment">// ok</span></span><br><span class="line"><span class="comment">// 2.设置已存在属性</span></span><br><span class="line">state.<span class="property">foo</span> = <span class="string">&#x27;fooooooo&#x27;</span> <span class="comment">// ok</span></span><br><span class="line"><span class="comment">// 3.设置不存在属性</span></span><br><span class="line">state.<span class="property">dong</span> = <span class="string">&#x27;dong&#x27;</span> <span class="comment">// ok</span></span><br><span class="line"><span class="comment">// 4.删除属性</span></span><br><span class="line"><span class="keyword">delete</span> state.<span class="property">dong</span> <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>再测试嵌套对象情况，这时候发现就不那么 OK 了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">bar</span>: &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置嵌套对象属性</span></span><br><span class="line">state.<span class="property">bar</span>.<span class="property">a</span> = <span class="number">10</span> <span class="comment">// no ok</span></span><br></pre></td></tr></table></figure>

<p>如果要解决，需要在<code>get</code>之上再进行一层代理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> &amp;&amp; obj != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Proxy相当于在对象外层加拦截</span></span><br><span class="line">    <span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`获取<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">isObject</span>(res) ? <span class="title function_">reactive</span>(res) : res</span><br><span class="line">        &#125;,</span><br><span class="line">    <span class="keyword">return</span> observed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p><code>Object.defineProperty</code>只能遍历对象属性进行劫持</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">defineReactive</span>(obj, key, obj[key])</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Proxy</code>直接可以劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式目的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> &amp;&amp; obj != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Proxy相当于在对象外层加拦截</span></span><br><span class="line">    <span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`获取<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`设置<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">deleteProperty</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, key)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`删除<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> observed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Proxy</code>可以直接监听数组的变化（<code>push</code>、<code>shift</code>、<code>splice</code>）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> proxtObj = <span class="title function_">reactive</span>(obj)</span><br><span class="line">obj.<span class="title function_">psuh</span>(<span class="number">4</span>) <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p><code>Proxy</code>有多达13种拦截方法,不限于<code>apply</code>、<code>ownKeys</code>、<code>deleteProperty</code>、<code>has</code>等等，这是<code>Object.defineProperty</code>不具备的</p>
<p>正因为<code>defineProperty</code>自身的缺陷，导致<code>Vue2</code>在实现响应式过程需要实现其他的方法辅助（如重写数组方法、增加额外<code>set</code>、<code>delete</code>方法）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组重写</span></span><br><span class="line"><span class="keyword">const</span> originalProto = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="title class_">Object</span>.<span class="title function_">create</span>(originalProto)</span><br><span class="line">[<span class="string">&#x27;push&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;shift&#x27;</span>, <span class="string">&#x27;unshift&#x27;</span>, <span class="string">&#x27;splice&#x27;</span>, <span class="string">&#x27;reverse&#x27;</span>, <span class="string">&#x27;sort&#x27;</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">  arrayProto[method] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    originalProto[method].<span class="title function_">apply</span>(<span class="variable language_">this</span>.<span class="property">arguments</span>)</span><br><span class="line">    dep.<span class="title function_">notice</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set、delete</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">set</span>(obj,<span class="string">&#x27;bar&#x27;</span>,<span class="string">&#x27;newbar&#x27;</span>)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">delete</span>(obj),<span class="string">&#x27;bar&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><code>Proxy</code> 不兼容IE，也没有 <code>polyfill</code>, <code>defineProperty</code> 能支持到IE9</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Spring-SpringMVC-Mybatis整合</title>
    <url>/post/b76cc576c624/</url>
    <content><![CDATA[<h1 id="Maven-Spring-SpringMVC-Mybatis-整合"><a href="#Maven-Spring-SpringMVC-Mybatis-整合" class="headerlink" title="Maven + Spring + SpringMVC + Mybatis 整合"></a>Maven + Spring + SpringMVC + Mybatis 整合</h1><p>通过这篇文章你可以获取的内容：</p>
<ol>
<li>整个配置流程。</li>
<li>对于每一个配置项，Spring 到底帮我们做了什么？</li>
</ol>
<p>本文假设读者：</p>
<ol>
<li>未使用 IDEA 进行过 Web 项目开发</li>
<li>未使用过 Maven 进行项目构建</li>
<li>已学习过 Spring、SpringMVC、Mybatis</li>
</ol>
<p>环境搭建：</p>
<ul>
<li>IDE： <code>IntelliJ IDEA 2017.1.1（Ultimate)</code></li>
<li>Web Server: <code>Tomcat 8.0.43</code></li>
<li>Spring: <code>4.3.7.RELEASE</code></li>
<li>Mybatis: <code>3.4.4</code></li>
</ul>
<p>如果需要示例代码，可以参考 <a href="https://github.com/c-rainstorm/ssm-Demo">SSM-Demo</a>.</p>
<hr>
<!-- TOC -->

<ul>
<li><a href="#maven--spring--springmvc--mybatis-%E6%95%B4%E5%90%88">Maven + Spring + SpringMVC + Mybatis 整合</a><ul>
<li><a href="#spring--springmvc">Spring &amp;&amp; SpringMVC</a><ul>
<li><a href="#%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA">工程搭建</a><ul>
<li><a href="#%E6%96%B0%E5%BB%BA-web-application">新建 Web Application</a></li>
<li><a href="#%E6%B7%BB%E5%8A%A0-maven-%E6%94%AF%E6%8C%81">添加 Maven 支持</a></li>
<li><a href="#%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95%E7%AE%80%E4%BB%8B">工程目录简介</a></li>
</ul>
</li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a><ul>
<li><a href="#view-%E5%B1%82">View 层</a></li>
<li><a href="#controller">Controller</a></li>
<li><a href="#service">Service</a></li>
</ul>
</li>
<li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99">配置文件编写</a><ul>
<li><a href="#springxml"><code>Spring.xml</code></a></li>
<li><a href="#spring-mvcxml"><code>Spring-mvc.xml</code></a></li>
<li><a href="#webxml"><code>web.xml</code></a></li>
</ul>
</li>
<li><a href="#%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95">运行测试</a></li>
</ul>
</li>
<li><a href="#spring--springmvc--mybatis">Spring &amp;&amp; SpringMVC &amp;&amp; Mybatis</a><ul>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1">代码实现</a><ul>
<li><a href="#dao">Dao</a></li>
<li><a href="#service-1">service</a></li>
</ul>
</li>
<li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99-1">配置文件编写</a><ul>
<li><a href="#userdaoxml"><code>UserDao.xml</code></a></li>
<li><a href="#springxml-1"><code>Spring.xml</code></a></li>
<li><a href="#pomxml">pom.xml</a></li>
</ul>
</li>
<li><a href="#%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95-1">运行测试</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83">参考</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<hr>
<h2 id="Spring-SpringMVC"><a href="#Spring-SpringMVC" class="headerlink" title="Spring &amp;&amp; SpringMVC"></a>Spring &amp;&amp; SpringMVC</h2><h3 id="工程搭建"><a href="#工程搭建" class="headerlink" title="工程搭建"></a>工程搭建</h3><h4 id="新建-Web-Application"><a href="#新建-Web-Application" class="headerlink" title="新建 Web Application"></a>新建 Web Application</h4><ol>
<li>File -&gt; new -&gt; project..</li>
<li>Java -&gt; Web Application<ul>
<li><img src="/../res/ssm-newProject.png"></li>
</ul>
</li>
</ol>
<h4 id="添加-Maven-支持"><a href="#添加-Maven-支持" class="headerlink" title="添加 Maven 支持"></a>添加 Maven 支持</h4><ol>
<li>右键工程名，点击 Add Framwork Support..<ul>
<li><img src="/../res/ssm-addFS.png"></li>
</ul>
</li>
<li>配置编译器源版本及目标字节码版本<ul>
<li>在 <code>pom.xml</code> 配置文件中添加以下配置。</li>
<li><strong>Tips：不添加的话目标字节码版本默认使用 <code>JDK1.5</code></strong> <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="工程目录简介"><a href="#工程目录简介" class="headerlink" title="工程目录简介"></a>工程目录简介</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">|-- pom.xml                    // Maven 配置文件</span><br><span class="line">|-- src</span><br><span class="line">|   |-- main</span><br><span class="line">|   |   |-- java               // Java 代码存放位置</span><br><span class="line">|   |   `-- resources          // 配置文件存放位置</span><br><span class="line">|   `-- test</span><br><span class="line">|       `-- java               // 测试类存放位置</span><br><span class="line">`-- web                        // 存放 View 层用到的文件，会直接部署到服务器</span><br><span class="line">    |-- index.jsp</span><br><span class="line">    `-- WEB-INF</span><br><span class="line">        `-- web.xml            // Web 应用程序的 Web 组件的配置和部署信息</span><br></pre></td></tr></table></figure>


<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>我们以一个最简单的用户登陆操作来说明配置的过程。</p>
<h4 id="View-层"><a href="#View-层" class="headerlink" title="View 层"></a>View 层</h4><ol>
<li>form 表单 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. 对应控制层 URL 为 /user/checkLogin --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2. input 标签中的 class 属性在 JS 中进行元素定位需要用到 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 3. input 标签中的 name 属性在控制层中提取表单数据时需要用到，即必须与控制层中对应方法的参数名或参数实体类中的域的名称一致，否则获取不到数据 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/user/checkLogin&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;username&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;username...&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;password...&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>使用 JS 在传输之前进行加密 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 以为网络传输时使用明文，所以直接将密码提交到后台的方式很不安全，所以在传输之前就进行加密。</span></span><br><span class="line">    <span class="comment">// 在这里加密方法用的是 MD5 。你也可以选择其他的加密方式，加密用的 JS 库应该很容易着，</span></span><br><span class="line">    <span class="comment">// 这里我用的是 [JavaScript-MD5](https://github.com/blueimp/JavaScript-MD5)。</span></span><br><span class="line">    $(<span class="string">&quot;form&quot;</span>).<span class="title function_">on</span>(<span class="string">&quot;submit&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> pass = $(<span class="string">&quot;.password&quot;</span>);</span><br><span class="line">        pass.<span class="title function_">val</span>(<span class="title function_">md5</span>(pass.<span class="title function_">val</span>()));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><ol>
<li><p>因为 Controller 需要用到 Spring 的注解，所以需要先添加 Maven 依赖，即将下面的配置写入 pom.xml 中，并 Import Change。</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">org.springframework.version</span>&gt;</span>4.3.7.RELEASE<span class="tag">&lt;/<span class="name">org.springframework.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;org.springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;org.springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-orm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;org.springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;org.springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;org.springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;org.springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;org.springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>Controller</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.crainstorm.oss.user.action;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserAction</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LogManager.getLogger(UserAction.class);</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/checkLogin&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">checkLogin</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;enter checkLogin...&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (service.loginSuccess(user)) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;login success...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;login failed...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;login/user&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>用到了 <code>log4j2</code>, 简单配置一下</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">&quot;WARN&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">&quot;Console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;%d [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 类寻找 Logger 时会根据包名一层一层向上找，如果没有找到，则默认使用 Root --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">&quot;trace&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.crainstorm.oss.user.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">loginSuccess</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.crainstorm.oss.user.service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LogManager.getLogger(UserServiceImpl.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为先配置 Spring + SpringMVC， 所以 dao 层先不管</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">loginSuccess</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置文件编写"><a href="#配置文件编写" class="headerlink" title="配置文件编写"></a>配置文件编写</h3><p>配置文件编写前我们需要简单了解一下整个请求流程：</p>
<ul>
<li><img src="/../res/springmvc-flow.png"></li>
</ul>
<h4 id="Spring-xml"><a href="#Spring-xml" class="headerlink" title="Spring.xml"></a><code>Spring.xml</code></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- context:annotation-config 配置可以使 Spring 帮我们加载几个常用的 BeanPostProcessor --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1. AutowiredAnnotationBeanPostProcessor： 用于处理 @Autowired --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2. CommonAnnotationBeanPostProcessor： 用于处理 @PostConstruct、@PreDestory、@Resource --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 3. PersistenceAnnotationBeanPostProcessor： 用于处理 @PersistenceUnit、@ PersistenceContext --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 4. RequiredAnnotationBeanPostProcessor： 用于处理 @Required --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--&lt;context:annotation-config&gt;&lt;/context:annotation-config&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 1. context:component-scan 隐含实现了 context:annotation-config 的功能， 所以使用了 context:component-scan 就不需要 context:annotation-config 了 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.github.crainstorm.oss&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 不扫描控制层组件，控制层组件的扫描放到 SpringMVC 配置文件中进行 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">expression</span>=<span class="string">&quot;org.springframework.web.bind.annotation.ControllerAdvice&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h4 id="Spring-mvc-xml"><a href="#Spring-mvc-xml" class="headerlink" title="Spring-mvc.xml"></a><code>Spring-mvc.xml</code></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 该注解帮我们注册了 DefaultServletHttpRequestHandler，用来处理静态资源。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 我们一般配置 DispatcherServlet 的 url-pattern 为 &#x27;/&#x27; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这种方法只能映射到我们编写的 Controller，如果直接请求 JSP 文件的话会直接返回 404 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 加上该注解后，JSP 这种静态文件可以交给 DefaultServletHttpRequestHandler 来处理，就可以正常返回了--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:default-servlet-handler</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- mvc:annotation-driven 配置使 Spring 加载了多个类，这里只举出几个： --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1. @RequestMapping： RequestMappingHandlerMapping(用来注册 Mapping)、RequestMappingHandlerAdapter(根据 Mapping 调用相应的 Controller) --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2. @ExceptionHandler： ExceptionHandlerExceptionResolver --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2. HttpMessageConverter: 转换器，用来提取 Request 中的参数(@RequestBody)，和将返回值转换成相应的格式(JSON 等)写入 Response 中(@ResponseBody)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 组件扫描，只扫描 Controller--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.github.crainstorm.oss&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:include-filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">expression</span>=<span class="string">&quot;org.springframework.web.bind.annotation.ControllerAdvice&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:include-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 注册 ViewResolver, mvc:annotation-driven 其实已经注册过一个默认的了，该定义会覆盖原来的定义 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/views/&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a><code>web.xml</code></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    作用：基于 &quot;contextClass&quot; and &quot;contextConfigLocation&quot; servlet context-params 初始化 root application context</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ContextLoaderListener 是 ContextLoader 的子类，实际的初始化工作由 ContextLoader 来做。</span></span><br><span class="line"><span class="comment">    1. ContextLoader 先在 web.xml 查找一个叫 contextClass 的 context-params, 如果找到了就创建一个该类型的 ApplicationContext，如果找不到就创建一个 XmlWebApplicationContext。我们通常都没有配置该参数，所以用的都是默认的这种.</span></span><br><span class="line"><span class="comment">    2. 从 web.xml 中查找一个叫 contextConfigLocation 的 context-param。如果找到了就将该值传递给之前创建的 XmlWebApplicationContext 实例，如果没有找到，就使用 XmlWebApplicationContext 默认的路径 `/WEB-INF/applicationContext.xml`</span></span><br><span class="line"><span class="comment">    3. 解析 contextConfigLocation 配置文件，加载 BeanBefinition</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 指定配置文件位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 字符编码过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 注册 DispatcherServlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 初始化该 Servlet 时会创建一个 XmlWebApplicationContext, 该参数指定了对应的配置文件所在位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 启动时加载，小于 0 则忽略该配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 该 Servlet 拦截所有请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Tomcat 运行时逻辑模型：<ul>
<li><img src="/../res/ssm-tomcatRuntimeModel.png"></li>
</ul>
<ol>
<li>Tomcat 容器中一个 Context 为一个工程，一个 wrapper 封装一个 Servlet。注意这里的 Context 跟 Spring 中的 ApplicationContext 没有关系，它代表的是一个容器，实现类是 <code>org.apache.catalina.core.StandardContext</code></li>
<li>Tomcat 容器中的 Context 与 Spring 中的 ApplicationContext 的关系如下图(不是类图)：<ul>
<li><img src="/../res/ssm-contextInTomcatAndSpring.png"></li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><ol>
<li>因为 IDEA 不会自动帮我们部署 Maven 库，所以我们需要将这些库添加到 &#x2F;WEB-INF&#x2F;lib&#x2F; 下：<ol>
<li>右键工程，点击 Open Module Settings，点击左侧的 Artifacts</li>
<li>我们可以看到的是 Output Layout，左侧是 WEB-INF，右侧是添加的 Maven 依赖，全选右侧 Maven，右键并点击 put into &#x2F;WEB-INF&#x2F;lib</li>
<li>这样在启动服务器时依赖库就可以自动部署到服务器了，需要注意的是<strong>每增加一些 Maven 依赖，在启动服务器前都需要将这些依赖添加到 &#x2F;WEB-INF&#x2F;lib</strong></li>
</ol>
</li>
<li>配置 Tomcat 服务器<ol>
<li>File -&gt; settings -&gt; Build,Execution,Deployment -&gt; Application Servers ,添加一个 Tomcat 服务器</li>
<li>Run -&gt; Edit Configurations 添加一个 Tomcat Server(Local)</li>
<li>Application server 选择刚配置的 Tomcat 服务器</li>
<li>Deployment 添加 Artifacts，右侧的 Application context 指的是如何访问该工程，比如 如果填了 <code>/oss</code>， 那么可以通过 <code>http://localhost:8080/oss</code> 来访问首页，如果这个地方做了修改 Server 下的默认连接也需要作相应修改，否则是无法访问的。</li>
<li>也可以修改一下配置的命名，默认是 Unnamed。</li>
</ol>
</li>
<li>使用 log4j2 来输出 Spring 的日志，这样万一出了什么问题的话就能很快的定位问题位置<ol>
<li>配置 Logger <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.springframework&quot;</span> <span class="attr">level</span>=<span class="string">&quot;debug&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>导入适配器依赖 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-jcl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>测试结果<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2017-04-23 10:23:09,422 [http-nio-8080-exec-11] TRACE com.github.crainstorm.oss.user.action.UserAction - enter checkLogin...</span><br><span class="line">2017-04-23 10:23:09,422 [http-nio-8080-exec-11] DEBUG com.github.crainstorm.oss.user.action.UserAction - User&#123;username=&#x27;17839918876&#x27;, password=&#x27;f217305153bc4761daaf98b3e5bb41c7&#x27;, nickname=&#x27;17839918876&#x27;, phone=&#x27;null&#x27;, birthday=null&#125;</span><br><span class="line">2017-04-23 10:23:09,422 [http-nio-8080-exec-11] INFO  com.github.crainstorm.oss.user.action.UserAction - login success...</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Spring-SpringMVC-Mybatis"><a href="#Spring-SpringMVC-Mybatis" class="headerlink" title="Spring &amp;&amp; SpringMVC &amp;&amp; Mybatis"></a>Spring &amp;&amp; SpringMVC &amp;&amp; Mybatis</h2><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="Dao"><a href="#Dao" class="headerlink" title="Dao"></a>Dao</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span></span><br><span class="line">(</span><br><span class="line">   user_id              <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> AUTO_INCREMENT,</span><br><span class="line">   username             <span class="type">varchar</span>(<span class="number">25</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span>,</span><br><span class="line">   password             <span class="type">varchar</span>(<span class="number">120</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">   nickname             <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">   phone                <span class="type">char</span>(<span class="number">11</span>) <span class="keyword">unique</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">   avatar               <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">default</span> <span class="string">&#x27;/images/avatars/default.jpg&#x27;</span>,</span><br><span class="line">   sex                  <span class="type">varchar</span>(<span class="number">8</span>) <span class="keyword">default</span> <span class="string">&#x27;保密&#x27;</span>,</span><br><span class="line">   birthday             <span class="type">date</span>,</span><br><span class="line">   is_valid             bool <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="literal">true</span>,</span><br><span class="line">   <span class="keyword">primary</span> key (user_id),</span><br><span class="line">   index (username),</span><br><span class="line">   <span class="keyword">check</span>(sex <span class="keyword">in</span>(<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;保密&#x27;</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.crainstorm.oss.user.dao;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by chen on 4/17/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">checkLogin</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="service"><a href="#service" class="headerlink" title="service"></a>service</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>                               <span class="comment">// 事务</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span>                 <span class="comment">// 重要！重要！重要！ 如果不加的话，部署到服务器上以后事务无法生效，即 JDBC 无法被 Spring 的事务管理器管理，执行过程中出现问题无法回滚</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LogManager.getLogger(UserServiceImpl.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao dao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">loginSuccess</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> dao.checkLogin(user);</span><br><span class="line">        <span class="keyword">if</span> (LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">            LOGGER.debug(<span class="string">&quot;selected &quot;</span> + num + <span class="string">&quot; records....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置文件编写-1"><a href="#配置文件编写-1" class="headerlink" title="配置文件编写"></a>配置文件编写</h3><h4 id="UserDao-xml"><a href="#UserDao-xml" class="headerlink" title="UserDao.xml"></a><code>UserDao.xml</code></h4><ul>
<li>与 UserDao 放在同一目录下<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.github.crainstorm.oss.user.dao.UserDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkLogin&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.github.crainstorm.oss.user.entity.User&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        SELECT COUNT(*)</span><br><span class="line">        FROM user</span><br><span class="line">        WHERE username = #&#123;username&#125; AND password = #&#123;password&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Spring-xml-1"><a href="#Spring-xml-1" class="headerlink" title="Spring.xml"></a><code>Spring.xml</code></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 导入 db 配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:db.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置数据源，使用的是 Druid 连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mysql-connector 6.0 以后会自动配置驱动，之前常用的 com.mysql.jdbc.Driver 已经被弃用了 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc_mysql_driver&#125;&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc_mysql_url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc_mysql_username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc_mysql_password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置 sqlSessionFactory --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis.xml&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置 MapperScannerConfigurer， 配置文件都与 Dao 层接口在一块 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--须扫描的基本包以分号或逗号分割，扫描器无法处理通配符--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.github.crainstorm.oss.user.dao&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--绑定 sqlSessionFactory--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注意是 value，不是 ref--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    启用事务注解，部署到服务器上以后 annotation-driven 不管用，事务执行出了异常无法回滚，所以就直接用 @EnableTransactionManagement 注解替换了</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;tx:annotation-driven/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置Spring的事务管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.29<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- mybatis-spring 的版本与使用的 Spring 和 Mybatis 的版本有关，具体的请查看官网 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="运行测试-1"><a href="#运行测试-1" class="headerlink" title="运行测试"></a>运行测试</h3><ol>
<li>配置 log4j2 输出 Mybatis 和 spring-mybatis 的日志 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.mybatis&quot;</span> <span class="attr">level</span>=<span class="string">&quot;debug&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.apache.ibatis&quot;</span> <span class="attr">level</span>=<span class="string">&quot;debug&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>部署 Dao 层 Mapper。IDEA 会将 <code>src/main/java</code> 下的类编译好以后部署到 <code>/WEB-INF/class</code>， 但是 <code>src/main/java</code> 里的其他文件默认是不部署的，所以我们需要配置 <code>pom.xml</code> 将 Mapper 也部署到服务器 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/dao/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>测试结果 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2017-04-23 12:42:07,682 [http-nio-8080-exec-2] TRACE com.github.crainstorm.oss.user.action.UserAction - enter checkLogin...</span><br><span class="line">2017-04-23 12:42:07,682 [http-nio-8080-exec-2] DEBUG com.github.crainstorm.oss.user.action.UserAction - User&#123;username=&#x27;rainstorm&#x27;, password=&#x27;f217305153bc4761daaf98b3e5bb41c7&#x27;, nickname=&#x27;rainstorm&#x27;, phone=&#x27;null&#x27;, birthday=null&#125;</span><br><span class="line">2017-04-23 12:42:07,682 [http-nio-8080-exec-2] DEBUG org.springframework.jdbc.datasource.DataSourceTransactionManager - Creating new transaction with name [com.github.crainstorm.oss.user.service.UserServiceImpl.loginSuccess]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT,readOnly; &#x27;&#x27;</span><br><span class="line">2017-04-23 12:42:07,687 [http-nio-8080-exec-2] DEBUG org.springframework.jdbc.datasource.DataSourceTransactionManager - Acquired Connection [com.mysql.cj.jdbc.ConnectionImpl@20c3cf2a] for JDBC transaction</span><br><span class="line">2017-04-23 12:42:07,687 [http-nio-8080-exec-2] DEBUG org.springframework.jdbc.datasource.DataSourceUtils - Setting JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@20c3cf2a] read-only</span><br><span class="line">2017-04-23 12:42:07,688 [http-nio-8080-exec-2] DEBUG org.springframework.jdbc.datasource.DataSourceTransactionManager - Switching JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@20c3cf2a] to manual commit</span><br><span class="line">2017-04-23 12:42:07,688 [http-nio-8080-exec-2] DEBUG org.mybatis.spring.SqlSessionUtils - Creating a new SqlSession</span><br><span class="line">2017-04-23 12:42:07,688 [http-nio-8080-exec-2] DEBUG org.mybatis.spring.SqlSessionUtils - Registering transaction synchronization for SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@34a6aa63]</span><br><span class="line">2017-04-23 12:42:07,688 [http-nio-8080-exec-2] DEBUG org.mybatis.spring.transaction.SpringManagedTransaction - JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@20c3cf2a] will be managed by Spring</span><br><span class="line">2017-04-23 12:42:07,688 [http-nio-8080-exec-2] DEBUG com.github.crainstorm.oss.user.dao.UserDao.checkLogin - ==&gt;  Preparing: SELECT COUNT(*) FROM user WHERE username = ? AND password = ?;</span><br><span class="line">2017-04-23 12:42:07,689 [http-nio-8080-exec-2] DEBUG com.github.crainstorm.oss.user.dao.UserDao.checkLogin - ==&gt; Parameters: rainstorm(String), f217305153bc4761daaf98b3e5bb41c7(String)</span><br><span class="line">2017-04-23 12:42:07,705 [http-nio-8080-exec-2] TRACE com.github.crainstorm.oss.user.dao.UserDao.checkLogin - &lt;==    Columns: COUNT(*)</span><br><span class="line">2017-04-23 12:42:07,705 [http-nio-8080-exec-2] TRACE com.github.crainstorm.oss.user.dao.UserDao.checkLogin - &lt;==        Row: 1</span><br><span class="line">2017-04-23 12:42:07,705 [http-nio-8080-exec-2] DEBUG com.github.crainstorm.oss.user.dao.UserDao.checkLogin - &lt;==      Total: 1</span><br><span class="line">2017-04-23 12:42:07,705 [http-nio-8080-exec-2] DEBUG org.mybatis.spring.SqlSessionUtils - Releasing transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@34a6aa63]</span><br><span class="line">2017-04-23 12:42:07,705 [http-nio-8080-exec-2] DEBUG com.github.crainstorm.oss.user.service.UserServiceImpl - selected 1 records....</span><br><span class="line">2017-04-23 12:42:07,705 [http-nio-8080-exec-2] DEBUG org.mybatis.spring.SqlSessionUtils - Transaction synchronization committing SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@34a6aa63]</span><br><span class="line">2017-04-23 12:42:07,705 [http-nio-8080-exec-2] DEBUG org.mybatis.spring.SqlSessionUtils - Transaction synchronization deregistering SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@34a6aa63]</span><br><span class="line">2017-04-23 12:42:07,706 [http-nio-8080-exec-2] DEBUG org.mybatis.spring.SqlSessionUtils - Transaction synchronization closing SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@34a6aa63]</span><br><span class="line">2017-04-23 12:42:07,706 [http-nio-8080-exec-2] DEBUG org.springframework.jdbc.datasource.DataSourceTransactionManager - Initiating transaction commit</span><br><span class="line">2017-04-23 12:42:07,706 [http-nio-8080-exec-2] DEBUG org.springframework.jdbc.datasource.DataSourceTransactionManager - Committing JDBC transaction on Connection [com.mysql.cj.jdbc.ConnectionImpl@20c3cf2a]</span><br><span class="line">2017-04-23 12:42:07,708 [http-nio-8080-exec-2] DEBUG org.springframework.jdbc.datasource.DataSourceUtils - Resetting read-only flag of JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@20c3cf2a]</span><br><span class="line">2017-04-23 12:42:07,709 [http-nio-8080-exec-2] DEBUG org.springframework.jdbc.datasource.DataSourceTransactionManager - Releasing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@20c3cf2a] after transaction</span><br><span class="line">2017-04-23 12:42:07,709 [http-nio-8080-exec-2] DEBUG org.springframework.jdbc.datasource.DataSourceUtils - Returning JDBC Connection to DataSource</span><br><span class="line">2017-04-23 12:42:07,709 [http-nio-8080-exec-2] INFO  com.github.crainstorm.oss.user.action.UserAction - login success...</span><br><span class="line">2017-</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://docs.spring.io/spring/docs/4.3.7.RELEASE/spring-framework-reference/html/beans.html#beans-annotation-config">Annotation-based container configuration</a></li>
<li><a href="https://docs.spring.io/spring/docs/4.3.7.RELEASE/spring-framework-reference/html/beans.html#beans-classpath-scanning">Classpath scanning and managed components</a></li>
<li><a href="https://docs.spring.io/spring/docs/4.3.7.RELEASE/spring-framework-reference/html/mvc.html#mvc-config">Configuring Spring MVC</a></li>
<li><a href="http://blog.csdn.net/walkerjong/article/details/7520896"> @RequestBody, @ResponseBody 注解详解 </a></li>
<li><a href="http://stackoverflow.com/questions/23325111/spring-mvc-handlermapping-vs-handleradapter">Spring mvc HandlerMapping VS HandlerAdapter</a></li>
<li><a href="https://docs.spring.io/spring/docs/4.3.7.RELEASE/javadoc-api/org/springframework/web/context/ContextLoaderListener.html">org.springframework.web.context.ContextLoaderListener</a></li>
<li><a href="https://docs.spring.io/spring/docs/4.3.7.RELEASE/javadoc-api/org/springframework/web/context/ContextLoader.html">org.springframework.web.context.ContextLoader</a></li>
<li><a href="https://docs.spring.io/spring/docs/4.3.7.RELEASE/spring-framework-reference/html/mvc.html#mvc-servlet">22.2 The DispatcherServlet</a></li>
<li><a href="https://schoudari.wordpress.com/2012/07/23/purpose-of-contextloaderlistener-spring-mvc/">Purpose of ContextLoaderListener – Spring MVC</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-servlet/">Servlet 工作原理解析</a></li>
<li><a href="http://www.mybatis.org/mybatis-3/zh/">mybatis</a></li>
<li><a href="http://www.mybatis.org/spring/zh/index.html">mybatis-spring</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/post/273d9ef113fc/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 和 React 的区别</title>
    <url>/post/5939c1eb0f86/</url>
    <content><![CDATA[<p>Vue 和 React 的区别看这里</p>
<h2 id="简单说说-Vue-和-React-的区别"><a href="#简单说说-Vue-和-React-的区别" class="headerlink" title="简单说说 Vue 和 React 的区别"></a>简单说说 Vue 和 React 的区别</h2><h3 id="青铜级"><a href="#青铜级" class="headerlink" title="青铜级"></a>青铜级</h3><p>只要真正了解一些，或者用过两个框架开发，就一定能说上来的一些语法层面：</p>
<ul>
<li>Vue API 多，React API 少</li>
<li>Vue 双向绑定，修改数据自动更新视图，而 React 单向数据流，需要手动 setState</li>
<li>Vue template 结构表现分离，React 用 jsx 结构表现融合，html&#x2F;css都可以写到js里</li>
<li>都可以通过 props 进行父子组件数据传递，只是 Vue props 要声明，React 不用声明可能直接使用</li>
<li>Vue 可以用插槽，React 是万物皆可 props</li>
<li>Vue2 利用基本都是 Mixin，React 可以用高阶函数、自定义 hook 实现</li>
<li>Vue 的 frgments、hook 到 Vue3 才有，Vue 还有丰富的指令，过滤器</li>
</ul>
<p>都支持服务端渲染，都有虚拟 DOM，数据驱动，组件化开发，响应式，组件通信，生命周期，Diff，都有状态管理 Vuex&#x2F;Pinia、Redux&#x2F;Mobx，等等等等….</p>
<h3 id="白银级"><a href="#白银级" class="headerlink" title="白银级"></a>白银级</h3><p>1、可以加一些偏感受方面的，比如：<br>React 官方只关注底层，上层应用解决方案都交给社区，所以 React 生态体系丰富，社区强，而且每次更新改动小等 等，而 Vue 是由官方主导开发和维护，生态没那么丰富，虽然上手比 React 简单一些，但每次更新堪称破土重来，改的倒是潇洒得很，这就注定我们学习成本大大增加，并不能做到学习一次就可以一直使用这个框架，1.0 改版 2.0 需要重新学习一遍，2.0 改版 3.0 又要学习一遍，甚至 3.0 到 3.2 都要重学一部分，有些程序员到了 35 退休不是不想干，也是学不动了吧。像是需要记的 API，React 就那么几个，剩下的自己去写就行了，Vue 虽然在代码维护上有一定优势，可是它的 API 就多得多了，而且还分版本，比如 Vue2 有过滤器，Vue3 却没了，不仅要多记很多 API 和自定义指令，还需要对自己所学的 API 根据版本进行选择使用，感觉不怎么严谨</p>
<p>2、也可以将青铜级上面的某些点展开说一下细节，比如：</p>
<p><strong>组件化：</strong></p>
<ul>
<li>Vue2 组件说白了就是一个挂满一堆东西的 Vue 核心类，通过 new Vue() 拿到实例。就是说 Vue 组件的 script 导出的是一个挂满各种 options 的纯对象而已，所以 options API 的 this 指向 Vue 实例，这对我们开发者来说是不透明的，需要文档才能知道上面一堆 this.$xxx 是干嘛用的，而且 Vue 的插件也都是基于 Vue 原型类基础上的，Vue.install 挂到 Vue 实例上去嘛，以保证和第三方库的 Vue 调的是同一个 Vue 对象</li>
<li>而 React 则比较简单，直接定义 render 函数生成 vnode，里面通过四个组件类包装 vnode 而已，不同类型的 vnode 用相对应的组件类处理，就像责任划分一样，各自只负责自己的。而且 React 类组件都是继承于 React.Component 类，它的 this 指向我们自定义的类，可以说对我们开发者来说是透明的</li>
</ul>
<p><strong>hook</strong>：</p>
<ul>
<li>React hook 是根据调用顺序来确定下一次重新渲染时的 state 是来源于哪个，所以有一些限制，比如不能在循环&#x2F;条件判断&#x2F;嵌套函数里使用，而且必须在函数最顶层调用 hook 等<br>Vue3 hook 是基于响应式实现的，它是声明在 setup 里，一次组件实例化只调用一次 setup，而 React 每次重新渲染都要重新调用，性能上自然不言而喻，而且可以在循环&#x2F;条件判断&#x2F;嵌套函数里使用，并且正因为是基于响应式实现的，还自动实现了依赖收集，而 React 需要手动传入依赖等</li>
</ul>
<p>等等…</p>
<h3 id="黄金级"><a href="#黄金级" class="headerlink" title="黄金级"></a>黄金级</h3><p>起码得深入源码吧，比如：</p>
<p><strong>响应式：</strong></p>
<ul>
<li>Vue2 响应式的特点就是依赖收集，数据可变，自动派发更新，初始化时通过 Object.defineProperty 递归劫持 data 所有属性添加 getter&#x2F;setter，触发 getter 的时候进行依赖收集，修改时触发 setter 自动派发更新找到引用组件重新渲染</li>
<li>Vue3 响应式使用原生 Proxy 重构了响应式，一是 proxy 不存在 Vue2响应式存在的缺陷，二是性能更好，不仅支持更多的数据结构，而且不再一开始递归劫持对象属性，而是代理第一层对象本身。运行时才递归，用到才代理，用 effect 副作用来代替 Vue2 里的 watcher，用一个依赖管理中心 trackMap 来统一管理依赖代替 Vue2 中的 Dep，这样也不需要维护特别多的依赖关系，性能上取得很大进步</li>
<li>相比 Vue 的自动化，React 则是基于状态，单向数据流，数据不可变，需要手动 setState 来更新，而且当数据改变时会以组件根为目录，默认全部重新渲染整个组件树，只能额外用 pureComponent&#x2F;shouldComponentUpdate&#x2F;useMemo&#x2F;useCallback 等方法来进行控制，更新粒度更大一些</li>
</ul>
<p><strong>Diff 算法：</strong></p>
<ul>
<li>Vue2 是同层比较新老 vnode，新的不存在老的存在就删除，新的存在老的不存在就创建，子节点采用双指针头对尾两端对比的方式，全量diff，然后移动节点时通过 splice 进行数组操作</li>
<li>Vue3 是采用 Map 数据结构以及动静结合的方式，在编译阶段提前标记静态节点，Diff 过程中直接跳过有静态标记的节点，并且子节点对比会使用一个 source 数组来记录节点位置及最长递增子序列算法优化了对比流程，快速 Diff，需要处理的边际条件会更少</li>
<li>React 是递归同层比较，标识差异点保存到 Diff 队列保存，得到 patch 树，再统一操作批量更新 DOM。Diff 总共就是移动、删除、增加三个操作，如果结构发生改变就直接卸载重新创建，如果没有则将节点在新集合中的位置和老集合中的 lastIndex 进行比较是否需要移动，如果遍历过程中发现新集合没有，但老集合有就删除</li>
</ul>
<h3 id="钻石级"><a href="#钻石级" class="headerlink" title="钻石级"></a>钻石级</h3><p>这得要脱离代码层面，上升到更加宏观的层面吧，区别摆在那里是死的，固定的，就主要看人怎么说了，比如</p>
<p>1、以突出核心思想和设计理念开头：</p>
<p>我觉得最主要就是核心思想和设计理念上的区别，React 一开始定位的就是 UI 开发的新思路，这种思想说白了就是要改变开发者，我制定规则，你们都照我的来，因为背靠大公司(facebook)，所以不缺用户，而 Vue 是尽可能降低前端开发的门槛来适应不同的开发者，让开发者怎么爽怎么来，正是因为这种设计理念上的差别对后续设计也产生了一些不可逆的影响，或者说这两框架后续架构的变化都是围绕这个来的。</p>
<p>2、以突出数据管理开头：</p>
<p>我觉得这两最主要的区别是在数据管理方式上，虽然都是数据驱动，但 Vue 是响应式的，React 是手动 setState，可以说正是因为这个对后面架构的设计都产生了一些不可逆的影响，或者说这两框架后续架构的变化都是围绕这个来的。</p>
<p>主要体现在这些方面：</p>
<p>比如 Vue 是对数据进行劫持&#x2F;代理，它对监测数据的变化更加精准，动了多少数据就触发多少更新，更新粒度很小，而 React 推崇函数式，这是没办法感知数据变化的，就是说不知道什么时候应该刷新，而且即便是手动 setState 触发更新，它也也不知道哪些组件需要刷新，而是渲染整个 DOM，说白了就是无脑刷新嘛，这样就导致性能不好，所以后面只能不断通过其他办法来避免不必要的刷新，或者优化无脑刷新的性能。当然 Vue 也不是那么完美，它实现精准刷新也是有代价的，就是需要给每个组件配置监视器，管理依赖收集和派发更新，这同样是有消耗的。且不是说性能谁好吧，我们可以对比下这两框架版本迭代可以发现，React 迭代是增加了一个个避免刷新的钩子函数或者 API 还有采用 Fiber 的架构来做时间分片也是来优化渲染的性能。而 Vue1&#x2F;Vue2&#x2F;Vue3 每个版本虽然改的东西多，但核心都是围绕响应式来优化的，所以我觉得这是这两框架之间最重要的区别</p>
<p>比如正是这种设计上的区别，也直接影响了 hooks 的实现和表现，React hook 底层是基于链表实现的，每次组件被 render 的时候都会按顺序执行所有 hooks，而且正因为底层是链表，每个 hook 的 next 是指向下一个 hook 的，所以我们写代码是不能在不同的 hooks 调用里使用条件判断&#x2F;函数嵌套之类的，因为这会导致执行顺序不对，从而出错。而 Vue hook 只会被注册调用一次，因为它是声明在 setup 里，一次组件实例化只调用一次 setup，Vue 之所以能避开这些问题，主要还是得益于数据响应式，不需要链表对 hooks 进行记录，而是直接对数据代理观察，但它也有困扰的地方，就是不得不返回一个包装对象，通过 .value 获取。因为在 JS 里基础类型只有值，没有引用，或者说只存在栈里，使用完就回收了，无法追踪后续变化，自然做不到数据的代理和拦截，这算是这个设计的一个缺点吧</p>
<p>再比如编译优化的问题，Vue 能够做到数据劫持，再到 Vue3 动静结合的 Diff 思想也得益于它的模板语法实现了静态编译。就是能做到预编译优化，可以静态分析，在解析模板时能根据解析到的不同的标签、文本等分别执行对应的回调函数来构造 AST，而 React 虽然 JSX 语法更加灵活，可也正是因为这样导致可以优化的地方不足，重新渲染时就是一堆递归调用 React.createElement，无法从模板层面进行静态分析，也就做不到双向绑定，即使是很厉害的 fiber，也是因为伤害已经造成，所以通过时间分片的优化来弥补伤害吧，因为已经无法在编译阶段进行优化了，这也是这个设计所带来的问题吧</p>
<h3 id="王者级"><a href="#王者级" class="headerlink" title="王者级"></a>王者级</h3><p><strong>项目选型怎么考虑？怎么选择？</strong></p>
<p>从加载速度，运行时性能来说，我觉得这两个框架综合各种场景应该是没什么质的差别的。硬要说的话，Vue 在更新时性能优化方面需要的心智负担可能会少那么一点，特别是 Vue3，而 React 如果不注意，容易导致一些组件无用的 Diff，但其实实际项目中真正能遇到这种性能瓶颈的也是极少数，所以(这里有两种说法)：</p>
<p>(如果公司主要用 Vue 技术栈的话)：所以总的来说我觉得 Vue 性能上会更有优势一点，特别是 Vue3 更加灵活，有很好的可扩展性，同时有更快的渲染速度和更小的打包体积。从 mixins 到 HOC 到 render props 再到 hooks，React 基本已经废掉了过去很多基于组件的逻辑抽象模式，抹掉了 JSX 对比模板的一个优势，Vue3 中现在也都能做到，所以我会偏向 Vue3。</p>
<p>(如果公司主要用 React 技术栈的话)：所以总的来说我觉得要是一些不大的系统或者 H5 就用 Vue，因为不管是上手还是开发难度上都很简单，开发效率也高嘛，而且它有更小的打包体积，毕竟在移动端网络差异大的情况下，资源体积是非常重要的。但像是一些中后台系统，或者一些大点的项目，会越做越大的，多人协作开发的，就用 React，因为它的函数式编程有更加灵活的结构和可扩展性，丰富的生态圈和工具链，解决方案多，后期也更方便迭代与维护，还适用原生 APP，所以我会偏向 React。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>js倒计时</title>
    <url>/post/2fd5979576c4/</url>
    <content><![CDATA[<h2 id="JS-实现倒计时功能"><a href="#JS-实现倒计时功能" class="headerlink" title="JS 实现倒计时功能"></a>JS 实现倒计时功能</h2><p>html</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>30分钟倒计时<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;timer&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> oBox = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;timer&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> maxtime = <span class="number">30</span> * <span class="number">60</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">CountDown</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">if</span> (maxtime &gt;= <span class="number">0</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        minutes = <span class="title class_">Math</span>.<span class="title function_">floor</span>(maxtime / <span class="number">60</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        seconds = <span class="title class_">Math</span>.<span class="title function_">floor</span>(maxtime % <span class="number">60</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        msg = <span class="string">&quot;距离结束还有&quot;</span> + minutes + <span class="string">&quot;分&quot;</span> + seconds + <span class="string">&quot;秒&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        oBox.<span class="property">innerHTML</span> = msg;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">if</span> (maxtime == <span class="number">5</span> * <span class="number">60</span>) <span class="title function_">alert</span>(<span class="string">&quot;还剩5分钟&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        --maxtime;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="built_in">clearInterval</span>(timer);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">alert</span>(<span class="string">&quot;时间到，结束!&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    timer = <span class="built_in">setInterval</span>(<span class="string">&quot;CountDown()&quot;</span>, <span class="number">1000</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>vue</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//data中定义 minutes, seconds</span></span><br><span class="line"><span class="comment">//methods中的方法</span></span><br><span class="line"> <span class="title function_">madeTime</span>(<span class="params"></span>) &#123;</span><br><span class="line"> 	  <span class="comment">//let now = new Date().getTime();</span></span><br><span class="line">      <span class="comment">// 设置截止时间</span></span><br><span class="line">      <span class="comment">//let end = new Date(this.curStartTime).getTime();</span></span><br><span class="line">      <span class="comment">//let maxtime = end - now;</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> maxtime = <span class="number">30</span> * <span class="number">60</span>; <span class="comment">//30分钟(1800秒)</span></span><br><span class="line">      <span class="comment">// var minutes, seconds, msg;</span></span><br><span class="line">      <span class="keyword">var</span> _this = <span class="variable language_">this</span>;</span><br><span class="line">      <span class="keyword">var</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxtime &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          _this.<span class="property">minutes</span> = <span class="title class_">Math</span>.<span class="title function_">floor</span>(maxtime / <span class="number">60</span>)</span><br><span class="line">            .<span class="title function_">toString</span>()</span><br><span class="line">            .<span class="title function_">padStart</span>(<span class="number">2</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">          _this.<span class="property">seconds</span> = <span class="title class_">Math</span>.<span class="title function_">floor</span>(maxtime % <span class="number">60</span>)</span><br><span class="line">            .<span class="title function_">toString</span>()</span><br><span class="line">            .<span class="title function_">padStart</span>(<span class="number">2</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">          <span class="comment">// msg = &quot;距离结束还有&quot; + minutes + &quot;分&quot; + seconds + &quot;秒&quot;;</span></span><br><span class="line">          <span class="keyword">if</span> (maxtime == <span class="number">5</span> * <span class="number">60</span>) <span class="title function_">alert</span>(<span class="string">&quot;还剩5分钟&quot;</span>);</span><br><span class="line">          --maxtime;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">          <span class="title function_">alert</span>(<span class="string">&quot;时间到，结束!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>npm常用命令</title>
    <url>/post/01619847fe92/</url>
    <content><![CDATA[<h1 id="npm常用命令"><a href="#npm常用命令" class="headerlink" title="npm常用命令"></a>npm常用命令</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>npm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种：</p>
<ul>
<li>允许用户从npm服务器下载别人编写的第三方包到本地使用。</li>
<li>允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。</li>
<li>允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h4 id="检测是否安装及版本"><a href="#检测是否安装及版本" class="headerlink" title="检测是否安装及版本"></a>检测是否安装及版本</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm -v <span class="comment"># 显示版本号说明已经安装相应的版本</span></span><br></pre></td></tr></table></figure>

<h4 id="生成package-json文件"><a href="#生成package-json文件" class="headerlink" title="生成package.json文件"></a>生成package.json文件</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure>

<blockquote>
<p>package.json用来描述项目中用到的模块和其他信息</p>
</blockquote>
<h4 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install <span class="comment"># 安装package.json定义好的模块，简写 npm i</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装包指定模块</span></span><br><span class="line">npm i &lt;ModuleName&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局安装</span></span><br><span class="line">npm i &lt;ModuleName&gt; -g </span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装包的同时，将信息写入到package.json中的 dependencies 配置中</span></span><br><span class="line">npm i &lt;ModuleName&gt; --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装包的同时，将信息写入到package.json中的 devDependencies 配置中</span></span><br><span class="line">npm i &lt;ModuleName&gt; --save-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装多模块</span></span><br><span class="line">npm i &lt;ModuleName1&gt; &lt;ModuleName2&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装方式参数：</span></span><br><span class="line">-save <span class="comment"># 简写-S，加入到生产依赖中</span></span><br><span class="line">-save-dev <span class="comment"># 简写-D，加入到开发依赖中</span></span><br><span class="line">-g <span class="comment"># 全局安装 将安装包放在 /usr/local 下或者你 node 的安装目录</span></span><br></pre></td></tr></table></figure>

<h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看所有全局安装的包</span></span><br><span class="line">npm <span class="built_in">ls</span> -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看本地项目中安装的包</span></span><br><span class="line">npm <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看包的 package.json文件</span></span><br><span class="line">npm view &lt;ModuleName&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看包的依赖关系</span></span><br><span class="line">npm view &lt;ModuleName&gt; dependencies</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看包的源文件地址</span></span><br><span class="line">npm view &lt;ModuleName&gt; repository.url</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看包所依赖的node版本</span></span><br><span class="line">npm view &lt;ModuleName&gt; engines</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看帮助</span></span><br><span class="line">npm <span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<h4 id="更新模块"><a href="#更新模块" class="headerlink" title="更新模块"></a>更新模块</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新本地模块</span></span><br><span class="line">npm update &lt;ModuleName&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新全局模块</span></span><br><span class="line">npm update -g &lt;ModuleName&gt; <span class="comment"># 更新全局软件包。</span></span><br><span class="line">npm update -g <span class="comment"># 更新所有的全局软件包。</span></span><br><span class="line">npm outdated -g --depth=0 <span class="comment"># 找出需要更新的包。</span></span><br></pre></td></tr></table></figure>

<h4 id="卸载模块"><a href="#卸载模块" class="headerlink" title="卸载模块"></a>卸载模块</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 卸载本地模块</span></span><br><span class="line">npm uninstall &lt;ModuleName&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载全局模块</span></span><br><span class="line">npm uninstall -g &lt;ModuleName&gt; <span class="comment"># 卸载全局软件包。</span></span><br></pre></td></tr></table></figure>

<h4 id="清空缓存"><a href="#清空缓存" class="headerlink" title="清空缓存"></a>清空缓存</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 清空npm缓存</span></span><br><span class="line">npm cache clear</span><br></pre></td></tr></table></figure>

<h4 id="使用淘宝镜像"><a href="#使用淘宝镜像" class="headerlink" title="使用淘宝镜像"></a>使用淘宝镜像</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用淘宝镜像</span></span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更改包内容后进行重建</span></span><br><span class="line">npm rebuild &lt;ModuleName&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查包是否已经过时，此命令会列出所有已经过时的包，可以及时进行包的更新</span></span><br><span class="line">npm outdated</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问npm的json文件，此命令将会打开一个网页</span></span><br><span class="line">npm <span class="built_in">help</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发布一个包的时候，需要检验某个包名是否存在</span></span><br><span class="line">npm search &lt;ModuleName&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销自己发布过的某个版本代码</span></span><br><span class="line">npm unpublish &lt;package&gt; &lt;version&gt;</span><br></pre></td></tr></table></figure>



<h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><h4 id="多次安装不成功尝试先清除缓存"><a href="#多次安装不成功尝试先清除缓存" class="headerlink" title="多次安装不成功尝试先清除缓存"></a>多次安装不成功尝试先清除缓存</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm cache clean -f</span><br></pre></td></tr></table></figure>



<h4 id="查看已安装的依赖包版本号"><a href="#查看已安装的依赖包版本号" class="headerlink" title="查看已安装的依赖包版本号"></a>查看已安装的依赖包版本号</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm <span class="built_in">ls</span> &lt;ModuleName&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：用此方法才能准确的知道项目使用的版本号，查看package.json时，有“^” 符号表示大于此版本</p>
</blockquote>
<h2 id="npm发布包教程"><a href="#npm发布包教程" class="headerlink" title="npm发布包教程"></a>npm发布包教程</h2><p><a href="https://segmentfault.com/a/1190000017461666">npm发布包教程</a></p>
<h2 id="nrm的作用与使用"><a href="#nrm的作用与使用" class="headerlink" title="nrm的作用与使用"></a>nrm的作用与使用</h2><h4 id="nrm是什么？"><a href="#nrm是什么？" class="headerlink" title="nrm是什么？"></a>nrm是什么？</h4><p>nrm(npm registry manager )是npm的镜像源管理工具，有时候国外资源太慢，使用这个就可以快速地在 npm 源间切换</p>
<h4 id="nrm的安装"><a href="#nrm的安装" class="headerlink" title="nrm的安装"></a>nrm的安装</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install -g nrm</span><br></pre></td></tr></table></figure>



<h4 id="nrm命令"><a href="#nrm命令" class="headerlink" title="nrm命令"></a>nrm命令</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nrm <span class="built_in">ls</span>　<span class="comment">#查看可用的源（有*号的表示当前所使用的源,以下&lt;registry&gt;表示源的名称）</span></span><br><span class="line">nrm use &lt;registry&gt; <span class="comment"># 将npm下载源切换成指定的源</span></span><br><span class="line">nrm add &lt;registry&gt; &lt;url&gt; <span class="comment"># 添加源，url为源的路径</span></span><br><span class="line">nrm del &lt;registry&gt; <span class="comment"># 删除源</span></span><br><span class="line">nrm <span class="built_in">test</span> &lt;registry&gt; <span class="comment"># 测试源的响应时间，可以作为使用哪个源的参考</span></span><br><span class="line"></span><br><span class="line">nrm <span class="built_in">help</span>　<span class="comment"># 查看nrm帮助</span></span><br><span class="line">nrm home &lt;registry&gt;　<span class="comment"># 跳转到指定源的官网</span></span><br></pre></td></tr></table></figure>



<h4 id="nrm使用"><a href="#nrm使用" class="headerlink" title="nrm使用"></a>nrm使用</h4><p>如果在你的网络不太理想或者受到其他网络限制导致不能使用npm原本的源进行下载时，nrm就非常有用了，你只需要：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nrm <span class="built_in">ls</span> <span class="comment"># 查看可用的源</span></span><br><span class="line">nrm use &lt;registry&gt;　<span class="comment"># 切换到指定源</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>一份前端够用的 Linux 命令</title>
    <url>/post/50cfe4754950/</url>
    <content><![CDATA[<h2 id="一份前端够用的-Linux-命令"><a href="#一份前端够用的-Linux-命令" class="headerlink" title="一份前端够用的 Linux 命令"></a>一份前端够用的 Linux 命令</h2><p>我在建站的过程中，必不可少会用到 Linux 命令，所以此篇写一份基本够用的 Linux 命令，会涵盖博客搭建系列文章用到的各种命令，方便查询和学习使用。</p>
<h2 id="0-Owner、Group、Others、Root"><a href="#0-Owner、Group、Others、Root" class="headerlink" title="0. Owner、Group、Others、Root"></a>0. Owner、Group、Others、Root</h2><p>Linux 系统是一种多用户系统，它将文件访问者身份分为三种：</p>
<h3 id="文件所有者（Owner）"><a href="#文件所有者（Owner）" class="headerlink" title="文件所有者（Owner）"></a>文件所有者（Owner）</h3><p>当创建一个用户的时候，Linux 会为该用户创建一个主目录，路径为 <code>/home/&lt;username&gt;</code>，我们可以使用 <code>cd ~</code>，快捷进入主目录。如果你想放一个私密文件，就可以放在自己的主目录里，然后设置只能自己查看。</p>
<h3 id="群组（Group）"><a href="#群组（Group）" class="headerlink" title="群组（Group）"></a>群组（Group）</h3><p>每个用户都有一个用户组，方便多人操作的时候，为一群人分配权限。当创建用户的时候，会自动创建一个与它同名的用户组。</p>
<p>如果一个用户同时属于多个组，用户需要在用户组之间切换，才能具有其他用户组的权限。</p>
<h3 id="其他人（Others）"><a href="#其他人（Others）" class="headerlink" title="其他人（Others）"></a>其他人（Others）</h3><p>既不是文件所有者又不是文件所属群组成员的用户，就是其他人。</p>
<h3 id="超级用户（Root）"><a href="#超级用户（Root）" class="headerlink" title="超级用户（Root）"></a>超级用户（Root）</h3><p>Root 用户是一类特殊的用户，该用户可以访问所有文件。</p>
<h2 id="1-adduser-添加用户-和-passwd-更改密码"><a href="#1-adduser-添加用户-和-passwd-更改密码" class="headerlink" title="1. adduser 添加用户 和 passwd 更改密码"></a>1. adduser 添加用户 和 passwd 更改密码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 添加一个名为 git 的用户</span><br><span class="line">adduser git</span><br><span class="line"># 设置 git 用户的密码</span><br><span class="line">passed git</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是由于创建的用户权限较低，有的时候我们需要为用户提权，此时我们可以这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 会打开 sudoers 配置文件</span><br><span class="line">sudo visudo</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意同样是编辑 <code>sudoers</code> 配置文件，使用这个命令会比使用 <code>sudo vim /etc/ sudoers</code> 更安全， 除了对语法有校验，并且还会在多用户编辑的时候锁住文件。</p>
<p>打开 <code>sudoers</code> 配置文件后，我们添加这样一行配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Allow git to run any commands anywhere</span><br><span class="line">git ALL=(ALL:ALL) ALL</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>简单解释下这句话 <code>git ALL=(ALL:ALL) ALL</code>：</p>
<ul>
<li>git 表示规则应用的用户名</li>
<li>第一个 <code>ALL</code> 表示规则应用于所有 hosts</li>
<li>第二个 <code>ALL</code> 表示规则应用于所有 users</li>
<li>第三个 <code>ALL</code> 表示规则应用于所有 groups</li>
<li>第四个 <code>ALL</code> 表示规则应用于所有 commands</li>
</ul>
<p>我们保存退出后，<code>git</code> 用户就会获得 root 权限。</p>
<h2 id="2-ls-列出文件和目录"><a href="#2-ls-列出文件和目录" class="headerlink" title="2. ls 列出文件和目录"></a>2. ls 列出文件和目录</h2><ol>
<li><code>ls</code> 列出文件和目录</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@iZ2ze learn-typescript.git]# ls</span><br><span class="line">branches  config  description  HEAD  hooks  index  info  objects  refs</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><code>ls -la</code> 由 <code>-a</code> 显示所有文件和目录（包括隐藏）和 <code>-l</code> 显示详细列表组成：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@iZ2ze learn-typescript.git]# ls -la</span><br><span class="line">总用量 20</span><br><span class="line">drwxrwxr-x  7 git git  132 12月 15 12:33 .</span><br><span class="line">drwx------  3 git git  127 12月 15 14:51 ..</span><br><span class="line">drwxrwxr-x  2 git git    6 12月 15 12:21 branches</span><br><span class="line">-rw-rw-r--  1 git git   66 12月 15 12:21 config</span><br><span class="line">-rw-rw-r--  1 git git   73 12月 15 12:21 description</span><br><span class="line">-rw-rw-r--  1 git git   23 12月 15 12:21 HEAD</span><br><span class="line">drwxrwxr-x  2 git git 4096 12月 15 13:10 hooks</span><br><span class="line">-rw-rw-r--  1 git git  217 12月 15 12:33 index</span><br><span class="line">drwxrwxr-x  2 git git   21 12月 15 12:21 info</span><br><span class="line">drwxrwxr-x 10 git git   90 12月 15 12:33 objects</span><br><span class="line">drwxrwxr-x  4 git git   31 12月 15 12:21 refs</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>每一行都有 7 列，我们以 <code>branches</code> 为例讲解每列的含义：</p>
<table>
<thead>
<tr>
<th>drwxrwxr-x</th>
<th>2</th>
<th>git</th>
<th>git</th>
<th>6</th>
<th>12 月 15 12:21</th>
<th>branches</th>
</tr>
</thead>
<tbody><tr>
<td>文件类型和权限信息</td>
<td>链接数或者一级子目录数</td>
<td>所有者</td>
<td>所属组</td>
<td>文件大小，单位字节</td>
<td>最后修改时间</td>
<td>文件名</td>
</tr>
</tbody></table>
<p>重点看第 1 列的内容，以 <code>drwxrwxr-x</code> 为例，这里一共 10 位，第 1 位表示文件类型，其中 <code>-</code> 表示普通文件，<code>d</code> 表示目录文件。</p>
<p>第 2 到第 4 位，表示所有者权限，其中 <code>r</code> 表示读权限，<code>w</code> 表示写权限，<code>x</code> 表示可执行权限， <code>-</code>表示无权限，第 2 到 5 位为 <code>rwx</code>，表示所有者可读可写可执行。</p>
<p>第 5 到第 7 位，表示组用户权限，这里也是 <code>rwx</code>。</p>
<p>第 8 到第 10 位，表示其他用户权限，这里是 <code>r-x</code>，表示有可读可执行权限，无写入权限。</p>
<p>这里再额外补充一点：</p>
<p>像 <code>root</code> 用户创建文件夹的默认权限为 <code>rwxr-xr-x</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@iZ2ze www]# mkdir test</span><br><span class="line">[root@iZ2ze www]# ls -l</span><br><span class="line"></span><br><span class="line">drwxr-xr-x  2 root root  6 12月 17 23:53 test</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而创建文件的默认权限是 <code>rw-r--r--</code>，注意创建文件默认会去掉 <code>x</code> 权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@iZ2ze www]# touch index.html</span><br><span class="line">[root@iZ2ze www]# ls -l</span><br><span class="line"></span><br><span class="line">-rw-r--r--  1 root root  0 12月 17 23:54 index.html</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这就是为什么我们有的时候需要在创建文件后，又加上执行权限。</p>
<h2 id="3-chown-更改文件属主，也可以同时更改文件属组"><a href="#3-chown-更改文件属主，也可以同时更改文件属组" class="headerlink" title="3. chown 更改文件属主，也可以同时更改文件属组"></a>3. chown 更改文件属主，也可以同时更改文件属组</h2><p><strong>chown (change owner)</strong> 语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># -R：递归更改文件属组</span><br><span class="line">chown [–R] 属主名 文件名</span><br><span class="line">chown [-R] 属主名：属组名 文件名</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将 <code>index.html</code> 的所有者更改为 <code>git</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@iZ2ze www]# chown git index.html</span><br><span class="line">[root@iZ2ze www]# ls -</span><br><span class="line"></span><br><span class="line">-rw-r--r-- 1 git  root  0 12月 17 23:54 index.html</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将 <code>index.html</code> 的所有者和群组都改为 <code>git</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@iZ2ze www]# chown git:git index.html</span><br><span class="line">[root@iZ2ze www]# ls -l</span><br><span class="line"></span><br><span class="line">-rw-r--r-- 1 git  git   0 12月 17 23:54 index.html</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-chmod-更改文件权限"><a href="#4-chmod-更改文件权限" class="headerlink" title="4. chmod 更改文件权限"></a>4. chmod 更改文件权限</h2><p>权限除了用 <code>r</code> <code>w</code> <code>x</code> 这种方式表示，也可以用数字表示，数组与字母的对应关系为：</p>
<ul>
<li>r:4</li>
<li>w:2</li>
<li>x:1</li>
</ul>
<p>之所有如此对应关系，主要还是为了方便推导，比如我们希望一个文件可读可写，那我们可以方便的设置权限为 6（4 + 2），同样，如果我们知道一个权限为 3，我们也可以推导出权限为可写可执行，因为只有 2 + 1 才可能等于 3。</p>
<p>我们看下 <strong>chmod （change mode）</strong>的具体语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># -R：递归更改文件属组</span><br><span class="line">chmod [-R] xyz 文件或目录</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中 xyz 分别表示 Owner、Group、Others 的权限，如果我们这样设置一个文件的权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chomd 750 index.html</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以得知，Owner 的权限为 7，为可读可写可执行，Group 的权限为 5，为可读可执行，Others 的权限为 0，表示不可读写不可执行。对应字母为：<code>rwxr-x---</code>。</p>
<p>除了这种数字的方式，还有一种使用符号类型改变权限的方式：</p>
<p>在这种方式里，我们将三种身份 <code>Owner</code>、<code>Group</code>、<code>Others</code>，分别简写为 <code>u（User）</code>、<code>g</code>、<code>o</code>，用 <code>a</code> 表示所有身份，再使用 <code>+</code> <code>-</code> <code>=</code> 表示加入、去除、设定一个权限，<code>r</code> <code>w</code> <code>x</code> 则继续表示读，写，执行权限，举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chomd u+x,g-x,o-x index.html</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>意思就是 <code>Owner</code> 加上执行权限，<code>Group</code> 和 <code>Others</code> 去除执行权限。</p>
<p>当然我们也可以直接设定权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod u=rwx,g=rx,o=r index.html</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时文件的权限就相当于 <code>-rwxr-xr--</code>。</p>
<p>此外，我们还可以省略不写 <code>ugoa</code> 这类身份内容，直接写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x index.html</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时相当于使用了 <code>a</code>，会给所有身份添加执行权限。</p>
<h2 id="5-su-切换身份"><a href="#5-su-切换身份" class="headerlink" title="5. su 切换身份"></a>5. su 切换身份</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 切换为 git 用户</span><br><span class="line">su git</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-whoami-显示用户名"><a href="#6-whoami-显示用户名" class="headerlink" title="6. whoami 显示用户名"></a>6. whoami 显示用户名</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># whoami</span><br><span class="line">root</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7-pwd-显示当前目录"><a href="#7-pwd-显示当前目录" class="headerlink" title="7. pwd 显示当前目录"></a>7. pwd 显示当前目录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[git@iZ2ze www]$ pwd</span><br><span class="line">/home/www</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="9-cd-切换工作目录"><a href="#9-cd-切换工作目录" class="headerlink" title="9. cd 切换工作目录"></a>9. cd 切换工作目录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 进入 /home/www/</span><br><span class="line">cd /home/www</span><br><span class="line"></span><br><span class="line"># 进入自己的主目录</span><br><span class="line">cd ~</span><br><span class="line"></span><br><span class="line"># 进入当前目录的上上两层 :</span><br><span class="line">cd ../..</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="10-mkdir-创建目录"><a href="#10-mkdir-创建目录" class="headerlink" title="10. mkdir 创建目录"></a>10. mkdir 创建目录</h2><ol>
<li><code>mkdir</code> 创建目录：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir new_folder</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><code>mkdir -p</code> 递归创建目录：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p one/two/three</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="11-touch-创建文件"><a href="#11-touch-创建文件" class="headerlink" title="11. touch 创建文件"></a>11. touch 创建文件</h2><p>用于修改文件或者目录的时间属性，当文件不存在，系统会创建空白文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch new_file</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="12-echo-打印输出"><a href="#12-echo-打印输出" class="headerlink" title="12. echo 打印输出"></a>12. echo 打印输出</h2><p>echo 是 Shell 命令，用于打印输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 显示转义字符</span><br><span class="line">echo &quot;\&quot;test content\&quot;&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建或覆盖文件内容为 “test content”：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;test content&quot; &gt; index.html</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果是想追加内容，就用 <code>&gt;&gt;</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@iZ2ze www]# echo &quot;test content&quot; &gt; index.html</span><br><span class="line">[root@iZ2ze www]# cat index.html</span><br><span class="line">test content</span><br><span class="line">[root@iZ2ze www]# echo &quot;test content&quot; &gt;&gt; index.html</span><br><span class="line">[root@iZ2ze www]# cat index.html</span><br><span class="line">test content</span><br><span class="line">test content</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="13-cat-连接文件并打印输出"><a href="#13-cat-连接文件并打印输出" class="headerlink" title="13. cat 连接文件并打印输出"></a>13. cat 连接文件并打印输出</h2><p>查看文件内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>清空 index.html 内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /dev/null &gt; index.html</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>把 index.html 的内容写入 second.html：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat index.html &gt; second.html</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>把 index.html 的内容追加写入 second.html：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat index.html &gt;&gt; second.html</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>把 index.html 和 second.html 追加写入 third.html：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat index.html second.html &gt;&gt; third.html</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="14-cp-复制文件或目录"><a href="#14-cp-复制文件或目录" class="headerlink" title="14. cp 复制文件或目录"></a>14. cp 复制文件或目录</h2><p>将目录 website&#x2F; 下的所有文件复制到新目录 static 下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># -r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。</span><br><span class="line">cp –r website/ static</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="15-mv-移动并重命名"><a href="#15-mv-移动并重命名" class="headerlink" title="15. mv 移动并重命名"></a>15. mv 移动并重命名</h2><p>文件改名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv index.html index2.html</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>隐藏文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 文件名上加上 .</span><br><span class="line">mv index.html .index.html</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>移动文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 仅仅移动</span><br><span class="line">mv  /home/www/index.html   /home/static/</span><br><span class="line"># 移动又重命名</span><br><span class="line">mv /home/www/index.html   /home/static/index2.html</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>批量移动：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv  /home/www/website/*  /home/www/static</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="16-rm-删除一个文件或者目录"><a href="#16-rm-删除一个文件或者目录" class="headerlink" title="16. rm 删除一个文件或者目录"></a>16. rm 删除一个文件或者目录</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 系统会询问</span><br><span class="line">rm file</span><br><span class="line"></span><br><span class="line"># -f 表示直接删除</span><br><span class="line"># -r 表示目录下的所有文件删除</span><br><span class="line"></span><br><span class="line"># 删除当前目录下的所有文件及目录</span><br><span class="line">rm -r  *</span><br><span class="line"></span><br><span class="line"># 跑路</span><br><span class="line">rm -rf /*</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="17-vi-vim"><a href="#17-vi-vim" class="headerlink" title="17. vi&#x2F;vim"></a>17. vi&#x2F;vim</h2><p>Linux 内建 vi 文书编辑器，Vim 是从 vi 发展出来的一个文本编辑器。</p>
<p>基本上 vi&#x2F;vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，<strong>输入模式（Insert mode</strong>）和<strong>底线命令模式（Last line mode）</strong>。我们边操作边介绍这三种模式：我们执行 <code>vim index.html</code>，如果没有该文件，则会创建文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim index.html</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时界面为：</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>此时是<strong>命令模式</strong>，在命令模式下，输入的任何字符都会被视为命令，接下来几个常用的命令：</p>
<ul>
<li>i 切换到输入模式。</li>
<li>x 删除当前光标所在处的字符。</li>
<li>: 切换到底线命令模式。</li>
</ul>
<p>我们按下 <code>i</code>，便会进入<strong>输入模式</strong>：</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>输入模式下，左下角有 <code>-- INSERT --</code> 标志：</p>
<p>此时我们可以进行各种输入，当输入完毕后，按下 ESC 回到命令模式：</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>此时左下角的 INSERT 已经消失不见了，如果我们要保存退出，我们先输入 <code>:</code> ，进入<strong>底线命令模式</strong>：</p>
<p>在底线命令模式中，常见的命令有：</p>
<ul>
<li>w 保存文件</li>
<li>q 退出程序</li>
</ul>
<p>我们输入 <code>wq</code>，表示保存并退出，此时我们就会发现并创建了一个 HTML 文件。</p>
<h2 id="18-ssh-远程连接工具"><a href="#18-ssh-远程连接工具" class="headerlink" title="18. ssh 远程连接工具"></a>18. ssh 远程连接工具</h2><p>注意 ssh 监听是 22 端口。</p>
<p>其基本语法为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh [OPTIONS] [-p PORT] [USER@]HOSTNAME [COMMAND]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>监听端口示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -p 300 git@8.8.8.8</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打开调试模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># -v 冗详模式，打印关于运行情况的调试信息</span><br><span class="line">ssh -v git@8.8.8.8</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Linux-下安装-MySQL"><a href="#Linux-下安装-MySQL" class="headerlink" title="Linux 下安装 MySQL"></a>Linux 下安装 MySQL</h2><p>参考链接 <a href="https://blog.csdn.net/weixin_50367873/article/details/121975384?spm=1001.2014.3001.5501">Linux 下安装 Mysql（rpm 包安装）</a>。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>reduce的妙用</title>
    <url>/post/4a1f85f59803/</url>
    <content><![CDATA[<p><strong>reduce</strong> 函数可以根据需要进行累加、过滤、分组、映射等操作，是一个非常强大的数组方法。在数据处理时使用的非常频繁，很多复杂的逻辑如果用reduce去处理，都非常的简洁，在实际的开发工作过程中，积累了一些常见又超级好用的 reduce 技巧的代码片段，筛选了如下 10 个，以供大家参考</p>
<h3 id="reduce-介绍"><a href="#reduce-介绍" class="headerlink" title="reduce 介绍"></a>reduce 介绍</h3><p>reduce 是数组的方法，可以对数组中的每个元素依次执行一个回调函数，从左到右依次累积计算出一个最终的值。其语法为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</span><br></pre></td></tr></table></figure>

<p>其中，callback 是每个元素执行的回调函数，其包含 4 个参数：</p>
<ul>
<li>accumulator：累积器，即上一次回调函数执行的返回值。</li>
<li>currentValue：当前元素的值。</li>
<li>index：当前元素的下标。</li>
<li>array：原始数组。</li>
<li>initialValue 是可选的，表示累积器的初始值。</li>
</ul>
<p>reduce 函数的执行过程如下：</p>
<p>1、如果没有提供 initialValue，则将数组的第一个元素作为累积器的初始值，否则将 initialValue 作为累积器的初始值。</p>
<p>2、从数组的第二个元素开始，依次对数组中的每个元素执行回调函数。</p>
<p>3、回调函数的返回值作为下一次回调函数执行时的累积器的值。</p>
<p>4、对数组中的每个元素执行完回调函数后，reduce 函数返回最后一次回调函数的返回值，即最终的累积值。</p>
<h3 id="计算数组中每个元素出现的次数"><a href="#计算数组中每个元素出现的次数" class="headerlink" title="计算数组中每个元素出现的次数"></a>计算数组中每个元素出现的次数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> count = fruits.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> &#123;</span><br><span class="line">  accumulator[currentValue] = (accumulator[currentValue] || <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> accumulator;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count); <span class="comment">// Output: &#123; apple: 3, banana: 2, orange: 1 &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nestedArray = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]];</span><br><span class="line"><span class="keyword">const</span> flattenedArray = nestedArray.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> accumulator.<span class="title function_">concat</span>(currentValue), []);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(flattenedArray); <span class="comment">// Output: [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>
<h3 id="按条件分组"><a href="#按条件分组" class="headerlink" title="按条件分组"></a>按条件分组</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;Charlie&#x27;</span>, <span class="attr">age</span>: <span class="number">35</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;David&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;Emily&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> groupedPeople = people.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> key = currentValue.<span class="property">age</span>;</span><br><span class="line">  <span class="keyword">if</span> (!accumulator[key]) &#123;</span><br><span class="line">    accumulator[key] = [];</span><br><span class="line">  &#125;</span><br><span class="line">  accumulator[key].<span class="title function_">push</span>(currentValue);</span><br><span class="line">  <span class="keyword">return</span> accumulator;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(groupedPeople);</span><br><span class="line"><span class="comment">// Output: &#123;</span></span><br><span class="line"><span class="comment">//   25: [&#123; name: &#x27;Alice&#x27;, age: 25 &#125;, &#123; name: &#x27;David&#x27;, age: 25 &#125;],</span></span><br><span class="line"><span class="comment">//   30: [&#123; name: &#x27;Bob&#x27;, age: 30 &#125;, &#123; name: &#x27;Emily&#x27;, age: 30 &#125;],</span></span><br><span class="line"><span class="comment">//   35: [&#123; name: &#x27;Charlie&#x27;, age: 35 &#125;]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="将多个数组合并为一个对象"><a href="#将多个数组合并为一个对象" class="headerlink" title="将多个数组合并为一个对象"></a>将多个数组合并为一个对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> keys = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> values = [<span class="string">&#x27;Alice&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;female&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> person = keys.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue, index</span>) =&gt;</span> &#123;</span><br><span class="line">    accumulator[currentValue] = values[index];</span><br><span class="line">    <span class="keyword">return</span> accumulator;</span><br><span class="line">  &#125;, &#123;&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// Output: &#123; name: &#x27;Alice&#x27;, age: 25, gender: &#x27;female&#x27; &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="将字符串转换为对象"><a href="#将字符串转换为对象" class="headerlink" title="将字符串转换为对象"></a>将字符串转换为对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;key1=value1&amp;key2=value2&amp;key3=value3&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> obj = str.<span class="title function_">split</span>(<span class="string">&#x27;&amp;&#x27;</span>).<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [key, value] = currentValue.<span class="title function_">split</span>(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">  accumulator[key] = value;</span><br><span class="line">  <span class="keyword">return</span> accumulator;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); </span><br><span class="line"><span class="comment">// Output: &#123; key1: &#x27;value1&#x27;, key2: &#x27;value2&#x27;, key3: &#x27;value3&#x27; &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="将对象转换为查询字符串"><a href="#将对象转换为查询字符串" class="headerlink" title="将对象转换为查询字符串"></a>将对象转换为查询字符串</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> params = &#123; <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> queryString = <span class="title class_">Object</span>.<span class="title function_">entries</span>(params).<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, [key, value]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;acc&#125;</span><span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;value&#125;</span>&amp;`</span>;</span><br><span class="line">&#125;, <span class="string">&quot;?&quot;</span>).<span class="title function_">slice</span>(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queryString); <span class="comment">// &quot;?foo=bar&amp;baz=42&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="打印斐波那契数列"><a href="#打印斐波那契数列" class="headerlink" title="打印斐波那契数列"></a>打印斐波那契数列</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fibonacci</span> = n =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> [...<span class="title class_">Array</span>(n)].<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      accumulator.<span class="title function_">push</span>(index);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      accumulator.<span class="title function_">push</span>(accumulator[index - <span class="number">1</span>] + accumulator[index - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> accumulator;</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fibonacci</span>(<span class="number">10</span>)); <span class="comment">// Output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</span></span><br></pre></td></tr></table></figure>
<h3 id="检查字符串是否是回文字符串"><a href="#检查字符串是否是回文字符串" class="headerlink" title="检查字符串是否是回文字符串"></a>检查字符串是否是回文字符串</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;racecar&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> isPalindrome = str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> accumulator &amp;&amp; currentValue === array[array.<span class="property">length</span> - index - <span class="number">1</span>];</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(isPalindrome); <span class="comment">// Output: true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="检查括号是否匹配"><a href="#检查括号是否匹配" class="headerlink" title="检查括号是否匹配"></a>检查括号是否匹配</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;(()()())&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> balanced = str.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (cur === <span class="string">&quot;(&quot;</span>) &#123;</span><br><span class="line">    acc++;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur === <span class="string">&quot;)&quot;</span>) &#123;</span><br><span class="line">    acc--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> acc;</span><br><span class="line">&#125;, <span class="number">0</span>) === <span class="number">0</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(balanced); <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="递归获取对象属性"><a href="#递归获取对象属性" class="headerlink" title="递归获取对象属性"></a>递归获取对象属性</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">info</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Jason&quot;</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123; <span class="attr">home</span>: <span class="string">&quot;Shaanxi&quot;</span>, <span class="attr">company</span>: <span class="string">&quot;Xian&quot;</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">config, path, defaultVal</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> path.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_">reduce</span>(<span class="function">(<span class="params">config, name</span>) =&gt;</span> config[name], config) || defaultVal;</span><br><span class="line">  <span class="keyword">return</span> fallback;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">get</span>(user, <span class="string">&quot;info.name&quot;</span>); <span class="comment">// Jason</span></span><br><span class="line"><span class="title function_">get</span>(user, <span class="string">&quot;info.address.home&quot;</span>); <span class="comment">// Shaanxi</span></span><br><span class="line"><span class="title function_">get</span>(user, <span class="string">&quot;info.address.company&quot;</span>); <span class="comment">// Xian</span></span><br><span class="line"><span class="title function_">get</span>(user, <span class="string">&quot;info.address.abc&quot;</span>, <span class="string">&quot;default&quot;</span>); <span class="comment">// default</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="手写-reduce"><a href="#手写-reduce" class="headerlink" title="手写 reduce"></a>手写 reduce</h3><p>可以通过手写一个简单的 reduce 函数来更好地理解它的实现原理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myReduce</span>(<span class="params">arr, callback, initialValue</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> accumulator = initialValue === <span class="literal">undefined</span> ? arr[<span class="number">0</span>] : initialValue;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = initialValue === <span class="literal">undefined</span> ? <span class="number">1</span> : <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    accumulator = <span class="title function_">callback</span>(accumulator, arr[i], i, arr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> accumulator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，myReduce 函数接受 3 个参数：要执行 reduce 操作的数组 arr、回调函数 callback 和累积器的初始值 initialValue。如果没有提供初始值，则将数组的第一个元素作为累积器的初始值。</p>
<p>接下来，在循环中，如果有 initialValue，则从第一个元素开始遍历 callback，此时 callabck 的第二个参数是从数组的第一项开始的；如果没有 initialValue，则从第二个元素开始遍历 callback，此时 callback 的第二个参数是从数组的第二项开始的从数组的第二个元素开始，依次对数组中的每个元素执行回调函数，并将返回值作为下一次回调函数执行时的累积器的值。</p>
<p>最后，myReduce 函数返回最后一次回调函数的返回值，即最终的累积值。</p>
<p>这个简易的 reduce 函数并没有考虑很多边界情况和复杂的应用场景，但是可以帮助我们更好地理解 reduce 函数的实现原理。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/post/04e670a1063e/</url>
    <content><![CDATA[<h2 id="博客目录"><a href="#博客目录" class="headerlink" title="博客目录"></a>博客目录</h2><p>打造一系列前端进阶的优质文章，博客将侧重于原生JS、 React、ReactNative和Webpack等入门与底层原理分析，只有在自己实践和深入理解后，才会输出相关博文，以确保博文内容的准确性。</p>
<p>微信公众号:</p>
<p><img src="https://i.loli.net/2020/02/27/fg2FYebTAR5hjUt.jpg"></p>
<p>欢迎关注本人的博文:</p>
<ul>
<li><h4 id="segmentFault"><a href="#segmentFault" class="headerlink" title="segmentFault"></a><a href="https://segmentfault.com/u/liuyan666/articles">segmentFault</a></h4></li>
<li><h4 id="掘金"><a href="#掘金" class="headerlink" title="掘金"></a><a href="https://juejin.im/user/5c6256596fb9a049bd42c770/posts">掘金</a></h4></li>
</ul>
<blockquote>
<h2 id="面试系列"><a href="#面试系列" class="headerlink" title="面试系列"></a>面试系列</h2></blockquote>
<ol>
<li><a href="https://github.com/YvetteLau/Blog/issues/7">【面试篇】寒冬求职季之你必须要懂的原生JS(上)</a></li>
<li><a href="https://github.com/YvetteLau/Blog/issues/28">【面试篇】寒冬求职季之你必须要懂的原生JS(中)</a></li>
<li><a href="https://github.com/YvetteLau/Blog/issues/29">【面试篇】寒冬求职之你必须要懂的Web安全</a></li>
<li><a href="https://github.com/YvetteLau/Blog/issues/35">这儿有20道大厂面试题等你查收</a></li>
</ol>
<blockquote>
<h2 id="Step-By-Step"><a href="#Step-By-Step" class="headerlink" title="Step-By-Step"></a>Step-By-Step</h2></blockquote>
<ol>
<li><a href="https://github.com/YvetteLau/Blog/issues/31">【Step-By-Step】高频面试题深入解析 &#x2F; 周刊 01</a></li>
<li><a href="https://github.com/YvetteLau/Blog/issues/32">【Step-By-Step】高频面试题深入解析&#x2F; 周刊 02</a></li>
<li><a href="https://github.com/YvetteLau/Blog/issues/33">【Step-By-Step】高频面试题深入解析&#x2F; 周刊 03</a></li>
<li><a href="https://github.com/YvetteLau/Blog/issues/34">【Step-By-Step】高频面试题深入解析&#x2F; 周刊 04</a></li>
<li><a href="https://github.com/YvetteLau/Blog/issues/36">【Step-By-Step】高频面试题深入解析&#x2F; 周刊 05</a></li>
<li><a href="https://github.com/YvetteLau/Blog/issues/37">【Step-By-Step】高频面试题深入解析&#x2F; 周刊 06</a></li>
<li><a href="https://github.com/YvetteLau/Blog/issues/38">【Step-By-Step】高频面试题深入解析&#x2F; 周刊 07</a></li>
</ol>
<blockquote>
<h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h2></blockquote>
<ol>
<li><a href="https://github.com/YvetteLau/Blog/issues/2">Promise的源码实现(完美符合PromiseA+规范)</a></li>
<li><a href="https://github.com/YvetteLau/Blog/issues/4">彻底搞懂浏览器Event-loop</a></li>
<li><a href="https://github.com/YvetteLau/Blog/issues/6">嗨，你真的懂this吗？</a></li>
<li><a href="https://github.com/YvetteLau/Blog/issues/30">细说JS异步发展历程</a></li>
<li><a href="https://github.com/YvetteLau/Blog/issues/39">【中高级前端必备】手摸手教你撸一个脚手架</a></li>
<li><a href="https://github.com/YvetteLau/Blog/issues/40">Proxy及其优点</a></li>
<li><a href="https://github.com/YvetteLau/Blog/issues/41">深入理解全能的 Reducer</a></li>
</ol>
<blockquote>
<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2></blockquote>
<ol>
<li><a href="https://github.com/YvetteLau/Blog/issues/3">React新旧生命周期一览</a></li>
<li><a href="https://github.com/YvetteLau/Blog/issues/42">可靠React组件设计的7个准则之SRP</a></li>
<li><a href="https://github.com/YvetteLau/Blog/issues/43">可靠React组件设计的7个准则之封装</a></li>
<li><a href="https://github.com/YvetteLau/Blog/issues/50">React中组件逻辑复用的那些事儿</a></li>
</ol>
<blockquote>
<h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2></blockquote>
<ol>
<li><a href="https://github.com/YvetteLau/Blog/issues/1">从零开始配置webpack(基于babel 7版本)</a></li>
</ol>
<blockquote>
<h2 id="移动web"><a href="#移动web" class="headerlink" title="移动web"></a>移动web</h2></blockquote>
<ol>
<li><a href="https://github.com/YvetteLau/Blog/issues/5">9102了，你还不会移动端真机调试？</a></li>
</ol>
<h2 id="html中的空格"><a href="#html中的空格" class="headerlink" title="html中的空格"></a>html中的空格</h2><p><img src="/../images/other/image.png" alt="xxx"></p>
]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>js window 页面事件</title>
    <url>/post/e4bbf6d75a10/</url>
    <content><![CDATA[<h2 id="js-window-页面事件"><a href="#js-window-页面事件" class="headerlink" title="js window 页面事件"></a>js window 页面事件</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;load&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;resize&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resize&quot;</span>, <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">offsetWidth</span>);</span><br><span class="line">  <span class="comment">// console.log(&quot;clientWidth&quot;, document.body.clientWidth);</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;scroll&quot;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;scroll&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;pageshow&quot;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;pageshow&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;pagehide&quot;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">// 页面隐藏的时候执行事件</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;pagehide&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;visibilitychange&quot;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;visibilitychange&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;unload&quot;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">// 当用户离开页面时触发了事件</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onunload&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onbeforeunload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 页面跳转之前执行了事件</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onbeforeunload&quot;</span>);</span><br><span class="line">  <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;onbeforeunload&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>window</tag>
      </tags>
  </entry>
  <entry>
    <title>yaml语言教程</title>
    <url>/post/a40879d345a9/</url>
    <content><![CDATA[<h1 id="yaml语言教程"><a href="#yaml语言教程" class="headerlink" title="yaml语言教程"></a>yaml语言教程</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>YAML 是 “YAML Ain’t a Markup Language”（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言）。</p>
<p>YAML 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别<strong>适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲</strong>（例如：许多电子邮件标题格式和YAML非常接近）。</p>
<p>YAML 的配置文件后缀为 <strong>.yml</strong>，如：<strong>runoob.yml</strong> 。</p>
<blockquote>
<p>yaml常用来用作配置文件，和json类似</p>
</blockquote>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul>
<li><p>大小写敏感</p>
</li>
<li><p>使用缩进表示层级关系</p>
</li>
<li><p>缩进不允许使用tab，只允许空格</p>
</li>
<li><p>缩进的空格数不重要，只要相同层级的元素左对齐即可</p>
</li>
<li><p>‘#’表示注释</p>
</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>YAML 支持以下几种数据类型：</p>
<ul>
<li><strong>对象</strong>：键值对的集合，又称为映射（mapping）&#x2F; 哈希（hashes） &#x2F; 字典（dictionary）</li>
<li><strong>数组</strong>：一组按次序排列的值，又称为序列（sequence） &#x2F; 列表（list）</li>
<li><strong>纯量</strong>（scalars）：单个的、不可再分的值</li>
</ul>
<h2 id="YAML-对象"><a href="#YAML-对象" class="headerlink" title="YAML 对象"></a>YAML 对象</h2><p>对象的几种表示形式：</p>
<p>1、对象键值对使用冒号结构表示 <strong>key: value</strong>，冒号后面要加一个空格。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">key:</span> <span class="string">value</span></span><br></pre></td></tr></table></figure>



<p>2、也可以使用 **key:{key1: value1, key2: value2, …}**。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">key:&#123;child-key1:value1,child-key2:value2&#125;</span></span><br></pre></td></tr></table></figure>



<p>3、还可以使用缩进表示层级关系；</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">key:</span> </span><br><span class="line">    <span class="attr">child-key1:</span> <span class="string">value1</span></span><br><span class="line">    <span class="attr">child-key2:</span> <span class="string">value2</span></span><br></pre></td></tr></table></figure>

<p>同2，只是表示形式不同。</p>
<p>4、较为复杂的对象格式，可以使用问号加一个空格代表一个复杂的 key，配合一个冒号加一个空格代表一个 value：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">?</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">complexkey1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">complexkey2</span></span><br><span class="line"><span class="string">:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">complexvalue1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">complexvalue2</span></span><br></pre></td></tr></table></figure>

<p>意思即对象的属性是一个数组 [complexkey1,complexkey2]，对应的值也是一个数组 [complexvalue1,complexvalue2]</p>
<h2 id="YAML-数组"><a href="#YAML-数组" class="headerlink" title="YAML 数组"></a>YAML 数组</h2><p>以 <strong>-</strong> 开头的行表示构成一个数组：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">A</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">B</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">C</span></span><br></pre></td></tr></table></figure>

<p>YAML 支持多维数组，可以使用行内表示：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">key:</span> [<span class="string">value1</span>, <span class="string">value2</span>, <span class="string">...</span>]</span><br></pre></td></tr></table></figure>

<p>数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">A</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">B</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">C</span></span><br></pre></td></tr></table></figure>

<p>一个相对复杂的例子：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">companies:</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="attr">id:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">company1</span></span><br><span class="line">        <span class="attr">price:</span> <span class="string">200W</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="attr">id:</span> <span class="number">2</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">company2</span></span><br><span class="line">        <span class="attr">price:</span> <span class="string">500W</span></span><br></pre></td></tr></table></figure>

<p>意思是 companies 属性是一个数组，每一个数组元素又是由 id、name、price 三个属性构成。</p>
<p>数组也可以使用流式(flow)的方式表示：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">companies:</span> [&#123;<span class="attr">id:</span> <span class="number">1</span>,<span class="attr">name:</span> <span class="string">company1</span>,<span class="attr">price:</span> <span class="string">200W</span>&#125;,&#123;<span class="attr">id:</span> <span class="number">2</span>,<span class="attr">name:</span> <span class="string">company2</span>,<span class="attr">price:</span> <span class="string">500W</span>&#125;]</span><br></pre></td></tr></table></figure>



<h2 id="复合结构（对象和数组组合）"><a href="#复合结构（对象和数组组合）" class="headerlink" title="复合结构（对象和数组组合）"></a>复合结构（对象和数组组合）</h2><p>数组和对象可以构成复合结构，例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">languages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Ruby</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Perl</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Python</span> </span><br><span class="line"><span class="attr">websites:</span></span><br><span class="line">  <span class="attr">YAML:</span> <span class="string">yaml.org</span> </span><br><span class="line">  <span class="attr">Ruby:</span> <span class="string">ruby-lang.org</span> </span><br><span class="line">  <span class="attr">Python:</span> <span class="string">python.org</span> </span><br><span class="line">  <span class="attr">Perl:</span> <span class="string">use.perl.org</span></span><br></pre></td></tr></table></figure>

<p>转换为 js 为：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  <span class="attr">languages:</span> [ <span class="string">&#x27;Ruby&#x27;</span>, <span class="string">&#x27;Perl&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>],</span><br><span class="line">  <span class="attr">websites:</span> &#123;</span><br><span class="line">    <span class="attr">YAML:</span> <span class="string">&#x27;yaml.org&#x27;</span>,</span><br><span class="line">    <span class="attr">Ruby:</span> <span class="string">&#x27;ruby-lang.org&#x27;</span>,</span><br><span class="line">    <span class="attr">Python:</span> <span class="string">&#x27;python.org&#x27;</span>,</span><br><span class="line">    <span class="attr">Perl:</span> <span class="string">&#x27;use.perl.org&#x27;</span> </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="纯量"><a href="#纯量" class="headerlink" title="纯量"></a>纯量</h2><p>纯量是最基本的，不可再分的值，包括：</p>
<ul>
<li>字符串</li>
<li>布尔值</li>
<li>整数</li>
<li>浮点数</li>
<li>Null</li>
<li>时间</li>
<li>日期</li>
</ul>
<p>使用一个例子来快速了解纯量的基本使用：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">boolean:</span> <span class="comment"># 布尔值</span></span><br><span class="line">    <span class="bullet">-</span> <span class="literal">TRUE</span>  <span class="comment">#true,True都可以</span></span><br><span class="line">    <span class="bullet">-</span> <span class="literal">FALSE</span>  <span class="comment">#false，False都可以</span></span><br><span class="line"><span class="attr">float:</span> <span class="comment"># 浮点数</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">3.14</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">6.8523015e+5</span>  <span class="comment">#可以使用科学计数法</span></span><br><span class="line"><span class="attr">int:</span> <span class="comment"># 整数</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">123</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">0b1010_0111_0100_1010_1110</span>    <span class="comment">#二进制表示</span></span><br><span class="line"><span class="attr">null:</span> <span class="comment"># Null</span></span><br><span class="line">    <span class="attr">nodeName:</span> <span class="string">&#x27;node&#x27;</span></span><br><span class="line">    <span class="attr">parent:</span> <span class="string">~</span>  <span class="comment">#使用~表示null</span></span><br><span class="line"><span class="attr">string:</span> <span class="comment"># 字符串</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">哈哈</span> <span class="comment"># 字符串默认不使用引号表示</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;Hello world&#x27;</span>  <span class="comment">#可以使用双引号或者单引号包裹特殊字符</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">newline</span></span><br><span class="line">      <span class="string">newline2</span>    <span class="comment">#字符串可以拆成多行，每一行会被转化成一个空格</span></span><br><span class="line"><span class="attr">date:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">2018-02-17</span>    <span class="comment">#日期必须使用ISO 8601格式，即yyyy-MM-dd</span></span><br><span class="line"><span class="attr">datetime:</span> </span><br><span class="line">    <span class="bullet">-</span>  <span class="number">2018-02-17T15:02:31+08:00</span>    <span class="comment">#时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区</span></span><br></pre></td></tr></table></figure>



<p> 多行字符串可以使用<code>|</code>保留换行符，也可以使用<code>&gt;</code>折叠换行。 </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">this:</span> <span class="string">|</span></span><br><span class="line"><span class="string">  Foo</span></span><br><span class="line"><span class="string">  Bar</span></span><br><span class="line"><span class="string"></span><span class="attr">that:</span> <span class="string">&gt;</span></span><br><span class="line"><span class="string">  Foo</span></span><br><span class="line"><span class="string">  Bar</span></span><br></pre></td></tr></table></figure>

<p> 转为js代码如下。 </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> this<span class="punctuation">:</span> &#x27;Foo\nBar\n&#x27;<span class="punctuation">,</span> that<span class="punctuation">:</span> &#x27;Foo Bar\n&#x27; <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p> <code>+</code>表示保留文字块末尾的换行，<code>-</code>表示删除字符串末尾的换行。 </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">s1:</span> <span class="string">|</span></span><br><span class="line"><span class="string">  Foo</span></span><br><span class="line"><span class="string"></span> </span><br><span class="line"><span class="attr">s2:</span> <span class="string">|+</span></span><br><span class="line"><span class="string">  Foo</span></span><br><span class="line"><span class="string"></span> </span><br><span class="line"> </span><br><span class="line"><span class="attr">s3:</span> <span class="string">|-</span></span><br><span class="line">  <span class="string">Foo</span></span><br></pre></td></tr></table></figure>

<p> 转为json代码如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> s1<span class="punctuation">:</span> &#x27;Foo\n&#x27;<span class="punctuation">,</span> s2<span class="punctuation">:</span> &#x27;Foo\n\n\n&#x27;<span class="punctuation">,</span> s3<span class="punctuation">:</span> &#x27;Foo&#x27; <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<p> 字符串之中可以插入 HTML 标记。 </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">message:</span> <span class="string">|</span></span><br><span class="line"><span class="string">  &lt;p style=&quot;color: red&quot;&gt;</span></span><br><span class="line"><span class="string">    段落</span></span><br><span class="line"><span class="string">  &lt;/p&gt;</span></span><br></pre></td></tr></table></figure>







<h2 id="转换数据格式"><a href="#转换数据格式" class="headerlink" title="转换数据格式"></a>转换数据格式</h2><p> 允许使用两个感叹号，强制转换数据类型。 </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">e:</span> <span class="type">!!str</span> <span class="number">123</span></span><br><span class="line"><span class="attr">f:</span> <span class="type">!!str</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>转换js结果同：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> e<span class="punctuation">:</span> &#x27;<span class="number">123</span>&#x27;<span class="punctuation">,</span> f<span class="punctuation">:</span> &#x27;<span class="literal"><span class="keyword">true</span></span>&#x27; <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>





<h2 id="锚点引用"><a href="#锚点引用" class="headerlink" title="锚点引用"></a>锚点引用</h2><p><strong>&amp;</strong> 锚点和&lt; span class&#x3D;”marked”&gt;* 别名，可以用来引用:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">defaults:</span> <span class="string">&amp;defaults</span> <span class="comment"># 添加锚点</span></span><br><span class="line">  <span class="attr">adapter:</span>  <span class="string">postgres</span></span><br><span class="line">  <span class="attr">host:</span>     <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">development:</span></span><br><span class="line">  <span class="attr">database:</span> <span class="string">myapp_development</span></span><br><span class="line">  <span class="string">&lt;&lt;:</span> <span class="string">*defaults</span> <span class="comment"># &lt;&lt;表示合并，*引用锚点</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">database:</span> <span class="string">myapp_test</span></span><br><span class="line">  <span class="string">&lt;&lt;:</span> <span class="string">*defaults</span> <span class="comment"># &lt;&lt;表示合并，*引用锚点</span></span><br></pre></td></tr></table></figure>

<p>相当于:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">defaults:</span></span><br><span class="line">  <span class="attr">adapter:</span>  <span class="string">postgres</span></span><br><span class="line">  <span class="attr">host:</span>     <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">development:</span></span><br><span class="line">  <span class="attr">database:</span> <span class="string">myapp_development</span></span><br><span class="line">  <span class="attr">adapter:</span>  <span class="string">postgres</span></span><br><span class="line">  <span class="attr">host:</span>     <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">database:</span> <span class="string">myapp_test</span></span><br><span class="line">  <span class="attr">adapter:</span>  <span class="string">postgres</span></span><br><span class="line">  <span class="attr">host:</span>     <span class="string">localhost</span></span><br></pre></td></tr></table></figure>

<p><strong>&amp;</strong> 用来建立锚点（defaults），**&lt;&lt;** 表示合并到当前数据，***** 用来引用锚点。</p>
<p>下面是另一个例子:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">&amp;showell</span> <span class="string">Steve</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">Clark</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">Brian</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">Oren</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">*showell</span> </span><br></pre></td></tr></table></figure>

<p>转为js代码如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">[ <span class="string">&#x27;Steve&#x27;</span>, <span class="string">&#x27;Clark&#x27;</span>, <span class="string">&#x27;Brian&#x27;</span>, <span class="string">&#x27;Oren&#x27;</span>, <span class="string">&#x27;Steve&#x27;</span> ]</span><br></pre></td></tr></table></figure>



<blockquote>
<p>参考：</p>
<ul>
<li>yaml官网：<a href="https://yaml.org/">https://yaml.org/</a></li>
<li>yaml与js的转换demo：<a href="http://nodeca.github.io/js-yaml/">http://nodeca.github.io/js-yaml/</a></li>
<li>菜鸟教程：<a href="https://www.ruanyifeng.com/blog/2016/07/yaml.html">https://www.ruanyifeng.com/blog/2016/07/yaml.html</a></li>
</ul>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>我的GitHub首页</title>
    <url>/post/8c8036cddf97/</url>
    <content><![CDATA[<p><a href="https://github.com/ytking"><img src="https://img.shields.io/badge/github-ytking-brightgreen.svg" alt="github"></a></p>
<h1>JavaScript Learning...</h1> 

<h2 id="阮一峰老师的-ES6-入门教程"><a href="#阮一峰老师的-ES6-入门教程" class="headerlink" title="阮一峰老师的 ES6 入门教程"></a>阮一峰老师的 <a href="http://es6.ruanyifeng.com/">ES6 入门教程</a></h2><table>
<thead>
<tr>
<th>ES6 入门教程</th>
<th align="left">&#x3D;&#x3D;&gt;</th>
<th><a href="https://github.com/ytking/ytking/blob/master/docs/ES6%20%E6%95%99%E7%A8%8B%2F33.ES6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.md">学习总结</a></th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://github.com/ytking/ytking/blob/master/docs/ES6%20%E6%95%99%E7%A8%8B/01.ECMAScript%206%20%E7%AE%80%E4%BB%8B.md">ES6 简介</a></td>
<td align="left"><a href="https://github.com/ytking/ytking/blob/master/docs/ES6%20%E6%95%99%E7%A8%8B/34.%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5.md">参考链接</a></td>
<td><a href="https://github.com/ytking/ytking/blob/master/docs/ES6%20%E6%95%99%E7%A8%8B/29.%E6%9C%80%E6%96%B0%E6%8F%90%E6%A1%88.md">最新提案</a></td>
</tr>
<tr>
<td><a href="https://github.com/ytking/ytking/blob/master/docs/ES6%20%E6%95%99%E7%A8%8B/02.let%20%E5%92%8C%20const%20%E5%91%BD%E4%BB%A4.md">let 和 const 简介</a></td>
<td align="left"><a href="https://github.com/ytking/ytking/blob/master/docs/ES6%20%E6%95%99%E7%A8%8B/03.%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC.md">变量的解构赋值</a></td>
<td><a href="https://github.com/ytking/ytking/blob/master/docs/ES6%20%E6%95%99%E7%A8%8B/04.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95.md">字符串的扩展</a></td>
</tr>
<tr>
<td><a href="https://github.com/ytking/ytking/blob/master/docs/ES6%20%E6%95%99%E7%A8%8B/05.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95.md">字符串的新增方法</a></td>
<td align="left"><a href="https://github.com/ytking/ytking/blob/master/docs/ES6%20%E6%95%99%E7%A8%8B/06.%E6%AD%A3%E5%88%99%E7%9A%84%E6%89%A9%E5%B1%95.md">正则的扩展</a></td>
<td><a href="https://github.com/ytking/ytking/blob/master/docs/ES6%20%E6%95%99%E7%A8%8B/07.%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95.md">数值的扩展</a></td>
</tr>
<tr>
<td><a href="https://github.com/ytking/ytking/blob/master/docs/ES6%20%E6%95%99%E7%A8%8B/08.%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95.md">函数的扩展</a></td>
<td align="left"><a href="https://github.com/ytking/ytking/blob/master/docs/ES6%20%E6%95%99%E7%A8%8B/09.%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95.md">数组的扩展</a></td>
<td><a href="https://github.com/ytking/ytking/blob/master/docs/ES6%20%E6%95%99%E7%A8%8B/10.%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95.md">对象的扩展</a></td>
</tr>
<tr>
<td><a href="https://github.com/ytking/ytking/blob/master/docs/ES6%20%E6%95%99%E7%A8%8B/11.%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95.md">对象的新增方法</a></td>
<td align="left"><a href="https://github.com/ytking/ytking/blob/master/docs/ES6%20%E6%95%99%E7%A8%8B/12.Symbol.md">Symbol</a></td>
<td><a href="https://github.com/ytking/ytking/blob/master/docs/ES6%20%E6%95%99%E7%A8%8B/13.Set%20%E5%92%8C%20Map%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.md">Set 和 Map 数据结构</a></td>
</tr>
<tr>
<td><a href="https://github.com/ytking/ytking/blob/master/docs/ES6%20%E6%95%99%E7%A8%8B/14.Proxy.md">Proxy</a></td>
<td align="left"><a href="https://github.com/ytking/ytking/blob/master/docs/ES6%20%E6%95%99%E7%A8%8B/15.Reflect.md">Reflect</a></td>
<td><a href="https://github.com/ytking/ytking/blob/master/docs/ES6%20%E6%95%99%E7%A8%8B/16.Promise%20%E5%AF%B9%E8%B1%A1.md">Promise 对象</a></td>
</tr>
<tr>
<td><a href="https://github.com/ytking/ytking/blob/master/docs/ES6%20%E6%95%99%E7%A8%8B/20.async%20%E5%87%BD%E6%95%B0.md">async 函数</a></td>
<td align="left"><a href="https://github.com/ytking/ytking/blob/master/docs/ES6%20%E6%95%99%E7%A8%8B/18.Generator%20%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95.md">Generator 函数的语法</a></td>
<td><a href="https://github.com/ytking/ytking/blob/master/docs/ES6%20%E6%95%99%E7%A8%8B/19.Generator%20%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E6%AD%A5%E5%BA%94%E7%94%A8.md">Generator 函数的异步应用</a></td>
</tr>
<tr>
<td><a href="https://github.com/ytking/ytking/blob/master/docs/ES6%20%E6%95%99%E7%A8%8B/17.Iterator%20%E5%92%8C%20for-of%20%E5%BE%AA%E7%8E%AF.md">Iterator 和 for…of 循环</a></td>
<td align="left"><a href="https://github.com/ytking/ytking/blob/master/docs/ES6%20%E6%95%99%E7%A8%8B/21.Class%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95.md">Class 的基本语法</a></td>
<td><a href="https://github.com/ytking/ytking/blob/master/docs/ES6%20%E6%95%99%E7%A8%8B/22.Class%20%E7%9A%84%E7%BB%A7%E6%89%BF.md">Class 的继承</a></td>
</tr>
<tr>
<td><a href="https://github.com/ytking/ytking/blob/master/docs/ES6%20%E6%95%99%E7%A8%8B/23.Module%20%E7%9A%84%E8%AF%AD%E6%B3%95.md">Module 的语法</a></td>
<td align="left"><a href="https://github.com/ytking/ytking/blob/master/docs/ES6%20%E6%95%99%E7%A8%8B/24.Module%20%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0.md">Module 的加载实现</a></td>
<td><a href="https://github.com/ytking/ytking/blob/master/docs/ES6%20%E6%95%99%E7%A8%8B/25.%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC.md">编程风格</a></td>
</tr>
<tr>
<td><a href="https://github.com/ytking/ytking/blob/master/docs/ES6%20%E6%95%99%E7%A8%8B/26.%E8%AF%BB%E6%87%82%20ECMAScript%20%E8%A7%84%E6%A0%BC.md">读懂 ECMAScript 规格</a></td>
<td align="left"><a href="https://github.com/ytking/ytking/blob/master/docs/ES6%20%E6%95%99%E7%A8%8B/27.%E5%BC%82%E6%AD%A5%E9%81%8D%E5%8E%86%E5%99%A8.md">异步遍历器</a></td>
<td><a href="https://github.com/ytking/ytking/blob/master/docs/ES6%20%E6%95%99%E7%A8%8B/28.ArrayBuffer.md">ArrayBuffer</a></td>
</tr>
<tr>
<td><a href="https://github.com/ytking/ytking/blob/master/docs/ES6%20%E6%95%99%E7%A8%8B/30.%E8%A3%85%E9%A5%B0%E5%99%A8.md">装饰器</a></td>
<td align="left"><a href="https://github.com/ytking/ytking/blob/master/docs/ES6%20%E6%95%99%E7%A8%8B/31.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.md">函数式编程</a></td>
<td><a href="https://github.com/ytking/ytking/blob/master/docs/ES6%20%E6%95%99%E7%A8%8B/32.Mixin.md">Mixin</a></td>
</tr>
</tbody></table>
<!-- |a|a|a| -->

<h2 id="面试系列"><a href="#面试系列" class="headerlink" title="面试系列"></a>面试系列</h2><ul>
<li><a href="https://github.com/ytking/ytking/issues/35">面试问题锦集</a></li>
<li><a href="https://github.com/ytking/ytking/issues/23">什么是进程？什么的线程？有什么区别</a></li>
<li><a href="https://github.com/ytking/ytking/issues/22">说说你对 shell 的理解？常见的命令？</a></li>
<li><a href="https://github.com/ytking/ytking/issues/20">call和apply、bind的理解及模拟实现</a></li>
<li><a href="https://github.com/ytking/ytking/issues/5">JavaScript从原型到原型链</a></li>
<li><a href="https://github.com/ytking/ytking/issues/4">JavaScript之深浅拷贝</a></li>
<li><a href="https://github.com/ytking/ytking/issues/37">20道大厂前端面试题</a></li>
<li><a href="https://github.com/ytking/ytking/issues/38">大厂JS必考手写题</a></li>
<li><a href="https://github.com/ytking/ytking/issues/39">ES6面试理论知识点汇总</a></li>
<li><a href="https://github.com/ytking/ytking/issues/40">ES6来简化代码,你都用过哪些</a></li>
<li><a href="https://github.com/ytking/ytking/issues/41">60个JS实用的代码小技巧</a></li>
<li><a href="https://github.com/ytking/ytking/issues/42">前端项目性能优化方案</a></li>
<li><a href="https://github.com/ytking/ytking/issues/43">JS 前端常用工具函数</a></li>
</ul>
<h2 id="Vue系列"><a href="#Vue系列" class="headerlink" title="Vue系列"></a>Vue系列</h2><h2 id="React系列"><a href="#React系列" class="headerlink" title="React系列"></a>React系列</h2>]]></content>
  </entry>
  <entry>
    <title>什么是全局数据共享</title>
    <url>/post/e983b3ec89b6/</url>
    <content><![CDATA[<h2 id="wx-小程序中的全局数据共享方案-MonX"><a href="#wx-小程序中的全局数据共享方案-MonX" class="headerlink" title="wx 小程序中的全局数据共享方案 MonX"></a>wx 小程序中的全局数据共享方案 MonX</h2><p>什么是全局数据共享<br>全局数据共享（又叫做：状态管理）是为了解决组件之间数据共享的问题。<br>开发中常用的全局数据共享方案有： Vuex 、 Redux 、 MobX 等。 2. 小程序中的全局数据共享方案<br>在小程序中，可使用 mobx-miniprogram 配合 mobx-miniprogram-bindings 实现全局数据共享。其<br>中：<br>mobx-miniprogram 用来创建 Store 实例对象<br>mobx-miniprogram-bindings 用来把 Store 中的共享数据或方法，绑定到组件或页面中使用</p>
<p>在项目中运行如下的命令，安装 MobX 相关的包：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install --save mobx-miniprogram@<span class="number">4.13</span><span class="number">.2</span> mobx-miniprogram-bindings@<span class="number">1.2</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>

<p>注意： MobX 相关的包安装完毕之后，记得删除 miniprogram_npm 目录后，重新构建 npm 。</p>
<p><strong>创建 MobX 的 Store 实例</strong><br>在项目根目录下新建 store 文件夹，并且新建 store.js 文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按需导入第三方包的方法observable, action</span></span><br><span class="line"><span class="keyword">import</span> &#123; observable, action &#125; <span class="keyword">from</span> <span class="string">&quot;mobx-miniprogram&quot;</span>;</span><br><span class="line"><span class="comment">// 创建 Store实例对象,并将其导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = <span class="title function_">observable</span>(&#123;</span><br><span class="line">  <span class="comment">// 数据字段</span></span><br><span class="line">  <span class="attr">numA</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">numB</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="comment">// 计算属性</span></span><br><span class="line">  <span class="comment">// 在计算属性的方法前，必须加 get修饰符，代表sum的值是只读的，无法进行修改</span></span><br><span class="line">  <span class="comment">// 计算属性sum 依赖于numA和numB的值，因此sum函数的返回值就是最终的值</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">sum</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">numA</span> + <span class="variable language_">this</span>.<span class="property">numB</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 定义actions方法, 用来修改 store中的数据</span></span><br><span class="line">  <span class="attr">updateNum1</span>: <span class="title function_">action</span>(<span class="keyword">function</span> (<span class="params">step</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">numA</span> += step;</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">updateNum2</span>: <span class="title function_">action</span>(<span class="keyword">function</span> (<span class="params">step</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">numB</span> += step;</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在页面中使用:<br>页面的 js 文件中:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.首先 导入第三方包，将数据绑定到页面</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStoreBindings &#125; <span class="keyword">from</span> <span class="string">&quot;mobx-miniprogram-bindings&quot;</span>;</span><br><span class="line"><span class="comment">// 2.其次 在页面的js文件的头部区域导入容器的数据</span></span><br><span class="line"><span class="keyword">import</span> &#123; store &#125; <span class="keyword">from</span> <span class="string">&quot;../../store/store&quot;</span>;</span><br><span class="line"><span class="comment">// 3. 绑定操作：将仓库的东西绑定到当前的页面中，在页面的js文件的Page方法中</span></span><br><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="comment">// 上面周期函数--监听页面的加载</span></span><br><span class="line">  <span class="attr">onLoad</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 调用createStoreBindings方法</span></span><br><span class="line">    <span class="comment">// 参数1： 绑定给谁：当前页面this</span></span><br><span class="line">    <span class="comment">// 参数2： 对象&#123; store(容器)， fields(数据)， actions(修改方法)</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">storeBindings</span> = <span class="title function_">createStoreBindings</span>(<span class="variable language_">this</span>, &#123;</span><br><span class="line">      <span class="comment">// 映射容器的实例</span></span><br><span class="line">      store,</span><br><span class="line">      <span class="comment">// 映射容器的数据字段</span></span><br><span class="line">      <span class="attr">fields</span>: [<span class="string">&quot;numA&quot;</span>, <span class="string">&quot;numB&quot;</span>, <span class="string">&quot;sum&quot;</span>],</span><br><span class="line">      <span class="comment">// 映射容器修改的方法</span></span><br><span class="line">      <span class="attr">actions</span>: [<span class="string">&quot;updateNum1&quot;</span>],</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 生命周期函数--监听页面的卸载</span></span><br><span class="line">  <span class="attr">onUnload</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 使用this.storeBindings，得到调用createStoreBindings方法的返回值</span></span><br><span class="line">    <span class="comment">//调用destroyStoreBindings 方法，进行清理销毁的工作</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">storeBindings</span>.<span class="title function_">destroyStoreBindings</span>();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>页面的 wxml 文件中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 使用仓库中的数据 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123;numA&#125;&#125; + &#123;&#123;numB&#125;&#125; = &#123;&#123;sum&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">van-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;btnHnadler1&quot;</span>&gt;</span>numA+1<span class="tag">&lt;/<span class="name">van-button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>监听函数 btnHandler1 的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 页面的js文件中的 tap事件处理函数</span></span><br><span class="line">btnHnadler1 (e) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">  <span class="comment">// 使用仓库中的方法，并传递数据</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">updateNum1</span>(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在组件中使用<br>准备工作<br>新建组件文件夹以及组件文件 numbers<br>全局注册这个组件<br>在 message 页面中使用子组件<br>组件的 js 文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">按需导入容器成员</span><br><span class="line"><span class="number">2.</span> 在组件的behaviors节点 实现自动绑定</span><br><span class="line"><span class="number">3.</span> 在storeBindings节点指定要绑定的store和要绑定的数据以及方法</span><br><span class="line"><span class="keyword">import</span> &#123; storeBindingsBehavior &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx-miniprogram-bindings&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; store &#125; <span class="keyword">from</span> <span class="string">&#x27;../../store/store&#x27;</span></span><br><span class="line"><span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="comment">// 通过storeBindingsBehavior 来实现自动绑定</span></span><br><span class="line">  <span class="attr">behaviors</span>: [storeBindingsBehavior],</span><br><span class="line">  <span class="attr">storeBindings</span>: &#123;</span><br><span class="line">    store, <span class="comment">// 指定要绑定的store</span></span><br><span class="line"> <span class="attr">fields</span>: &#123; <span class="comment">// 指定要绑定的数据字段或计算属性</span></span><br><span class="line"><span class="attr">numA</span>: <span class="function">() =&gt;</span> store.<span class="property">numA</span>, <span class="comment">// 绑定字段的方式1：</span></span><br><span class="line">      <span class="attr">numB</span>: <span class="function"><span class="params">store</span> =&gt;</span> store.<span class="property">numB</span>, <span class="comment">// 绑定字段的方式2</span></span><br><span class="line">      <span class="attr">sum</span>: <span class="string">&#x27;sum&#x27;</span> <span class="comment">// 绑定字段的方式3</span></span><br><span class="line">   &#125;,</span><br><span class="line">    <span class="attr">actions</span>: &#123; <span class="comment">// 指定要绑定的方法</span></span><br><span class="line">      <span class="attr">updateNum2</span>: <span class="string">&#x27;updateNum2&#x27;</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br><span class="line">注意： fields中前面是在组件中的名称，可自定义，后面是容器中的名称，必须和仓库一致</span><br></pre></td></tr></table></figure>

<p>组件的 wxml 文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 组件的 .<span class="property">wxml</span>结构 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123;numA&#125;&#125; + &#123;&#123;numB&#125;&#125; = &#123;&#123;sum&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">van-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;btnHnadler2&quot;</span>&gt;</span>numB+1<span class="tag">&lt;/<span class="name">van-button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>事件处理函数 btnHandler2</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Compoonent</span>(&#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">btnHnadler2</span>(<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="comment">// 直接使用this调用仓库中的方法</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">updateNum2</span>(<span class="number">20</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>结论: 无论是在页面中使用仓库中的东西, 还是在组件中使用仓库中的东西, 在绑定成功之后, 就可以像使<br>用自身数据和调用自身方法一样的对仓库的数据和方法进行操作。</p>
<h2 id="实现-wx-小程序-API-的-Promise-化"><a href="#实现-wx-小程序-API-的-Promise-化" class="headerlink" title="实现 wx 小程序 API 的 Promise 化"></a>实现 wx 小程序 API 的 Promise 化</h2><ol>
<li><p>基于回调函数的异步 API 的缺点<br>默认情况下，小程序官方提供的异步 API 都是基于回调函数实现的，例如，网络请求的 API 需要按照<br>如下的方式调用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wx.<span class="title function_">request</span>(&#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">success</span>: <span class="function">() =&gt;</span> &#123;&#125;, <span class="comment">// 成功的回调</span></span><br><span class="line">  <span class="attr">complate</span>: <span class="function">() =&gt;</span> &#123;&#125;, <span class="comment">// 无论成功与否都会执行的回调</span></span><br><span class="line">  <span class="attr">fail</span>: <span class="function">() =&gt;</span> &#123;&#125;, <span class="comment">// 失败的回调</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>​</p>
<p>这种代码的缺点是显而易见的, 容易造成回调地狱的问题，代码的可读性、维护性差！而我们就想将这</p>
<p>种类型的代码使用 API Promise 化进行改造。</p>
</li>
<li><p>什么是 API Promise 化<br>API Promise 化，指的是通过额外的配置，将官方提供的、基于回调函数的异步 API ，升级改造为基<br>于 Promise 的异步 API ，从而提高代码的可读性、维护性，避免回调地狱的问题。</p>
</li>
<li><p>实现 API Promise 化<br>在小程序中，实现 API Promise 化主要依赖于 miniprogram-api-promise 这个第三方的 npm 包。<br>它的安装和使用步骤如下:</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i --save miniprogram-api-promise@<span class="number">1.0</span><span class="number">.4</span></span><br><span class="line">- 下载完成，我们不能直接使用，而是需要再次重新构建npm包</span><br><span class="line">- 建议在构建前先删除原有的miniprogram_npm</span><br><span class="line">- 然后再点击工具，构建npm</span><br></pre></td></tr></table></figure>

<p>导入并执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在小程序入口文件中（app.js),只需要调用一次 promisifyAll()方法</span></span><br><span class="line"><span class="comment">// 即可实现异步API 的Promise化</span></span><br><span class="line"><span class="comment">// 按需导入一个方法</span></span><br><span class="line"><span class="keyword">import</span> &#123; promisifyAll &#125; <span class="keyword">from</span> <span class="string">&quot;miniprogram-api-promise&quot;</span>;</span><br><span class="line"><span class="comment">// 声明一个常量，为一个空对象，</span></span><br><span class="line"><span class="comment">// 并在wx顶级对象下添加一个属性p也指向该空对象，使所有成员都可以使用该对象</span></span><br><span class="line"><span class="keyword">const</span> wxp = (wx.<span class="property">p</span> = &#123;&#125;);</span><br><span class="line"><span class="comment">// promisify all wx&#x27;s api</span></span><br><span class="line"><span class="comment">// 参数1： wx顶级对象</span></span><br><span class="line"><span class="comment">// 参数2： wxp指向一个空对象</span></span><br><span class="line"><span class="title function_">promisifyAll</span>(wx, wxp);</span><br></pre></td></tr></table></figure>

<p>解释上述代码:<br>promisifyAll : 做的事就是将 wx 拥有的属性方法都 copy 并改造了一份给了 wxp 这个对象。<br>然而, wxp 只是当前 js 文件的一个常量，只能在当前文件使用。<br>因此：我们在 wx 上挂载一个属性 p 让他和 wxp 指向同一个空对象。<br>在其他页面或者组件就可以通过全局对象 wx 点出 p 来访问到 wxp。<br>此时 wx.p 发起异步的请求时，得到的是一个 promise 对象。<br>那么我们就可以使用 async&#x2F;await 简化 Promise 语法。</p>
<p>在原生开发小程序的过程中，发现有多个页面都使用了几乎完全一样的逻辑。由于小程序官方并没有提供 Mixins 这种代码复用机制，所以只能采用非常不优雅的复制粘贴的方式去“复用”代码。随着功能越来越复杂，靠复制粘贴来维护代码显然不科学，于是便寻思着如何在小程序里面实现 Mixins。</p>
<h2 id="在小程序中实现-Mixins-方案"><a href="#在小程序中实现-Mixins-方案" class="headerlink" title="在小程序中实现 Mixins 方案"></a>在小程序中实现 Mixins 方案</h2><h3 id="什么是-Mixins"><a href="#什么是-Mixins" class="headerlink" title="什么是 Mixins"></a>什么是 Mixins</h3><p>Mixins 直译过来是“混入”的意思，顾名思义就是把可复用的代码混入当前的代码里面。熟悉 VueJS 的同学应该清楚，它提供了更强大了代码复用能力，解耦了重复的模块，让系统维护更加方便优雅。</p>
<p>先看看在 VueJS 中是怎么使用 Mixins 的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// define a mixin object</span></span><br><span class="line"><span class="keyword">var</span> myMixin = &#123;</span><br><span class="line">  <span class="attr">created</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">hello</span>();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="attr">hello</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello from mixin!&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define a component that uses this mixin</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Component</span> = <span class="title class_">Vue</span>.<span class="title function_">extend</span>(&#123;</span><br><span class="line">  <span class="attr">mixins</span>: [myMixin],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> component = <span class="keyword">new</span> <span class="title class_">Component</span>(); <span class="comment">// =&gt; &quot;hello from mixin!&quot;</span></span><br><span class="line"><span class="number">123456789101112131415161718</span>;</span><br></pre></td></tr></table></figure>

<p>在上述的代码中，首先定义了一个名为 myMixin 的对象，里面定义了一些生命周期函数和方法。接着在一个新建的组件里面直接通过 mixins: [myMixin] 的方式注入，此时新建的组件便获得了来自 myMixin 的方法了。</p>
<p>明白了什么是 Mixins 以后，便可开始着手在小程序里面实现了。</p>
<h3 id="Mixins-的机制"><a href="#Mixins-的机制" class="headerlink" title="Mixins 的机制"></a>Mixins 的机制</h3><p>Mixins 也有一些小小的细节需要注意的，就是关于生命周期事件的执行顺序。在上一节的例子中，我们在 myMixin 里定义了一个 created() 方法，这是 VueJS 里面的一个生命周期事件。如果我们在新建组件 Component 里面也定义一个 created() 方法，那么执行结果会是如何呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Component</span> = <span class="title class_">Vue</span>.<span class="title function_">extend</span>(&#123;</span><br><span class="line">  <span class="attr">mixins</span>: [myMixin],</span><br><span class="line">  <span class="attr">created</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello from Component!&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> component = <span class="keyword">new</span> <span class="title class_">Component</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt;</span></span><br><span class="line"><span class="comment">// Hello from mixin!</span></span><br><span class="line"><span class="comment">// Hello from Component!</span></span><br><span class="line"><span class="number">123456789101112</span>;</span><br></pre></td></tr></table></figure>

<p>可以看运行结果是先输出了来自 Mixin 的 log，再输出来自组件的 log。</p>
<p>除了生命周期函数以外，再看看对象属性的混入结果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// define a mixin object</span></span><br><span class="line"><span class="keyword">const</span> myMixin = &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">mixinData</span>: <span class="string">&quot;data from mixin&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define a component that uses this mixin</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Component</span> = <span class="title class_">Vue</span>.<span class="title function_">extend</span>(&#123;</span><br><span class="line">  <span class="attr">mixins</span>: [myMixin],</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">componentData</span>: <span class="string">&quot;data from component&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$data</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> component = <span class="keyword">new</span> <span class="title class_">Component</span>();</span><br><span class="line"><span class="number">1234567891011121314151617181920212223</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/95cba679a72a4f98a6d5e451d6d0bbad.png" alt="在这里插入图片描述"><br>在 VueJS 中，会把来自 Mixins 和组件的对象属性当中的内容（如 data, methods 等）混合，以确保两边的数据都同时存在。</p>
<p>经过上述的验证，我们可以得到 VueJS 中关于 Mixins 运行机制的结论：</p>
<p>生命周期属性，会优先执行来自 Mixins 当中的，后执行来自组件当中的。<br>对象类型属性，来自 Mixins 和来自组件中的会共存。<br>但是在小程序中，这套机制会和 VueJS 的有一点区别。在小程序中，自定义的方法是直接定义在 Page 的属性当中的，既不属于生命周期类型属性，也不属于对象类型属性。为了不引入奇怪的问题，我们为小程序的 Mixins 运行机制多加一条：</p>
<p>小程序中的自定义方法，优先级为 Page &gt; Mixins，即 Page 中的自定义方法会覆盖 Mixins 当中的。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>在小程序中，每个页面都由 Page(options) 函数定义，而 Mixins 则作用于这个函数当中的 options 对象。因此我们实现 Mixins 的思路就有了——劫持并改写 Page 函数，最后再重新把它释放出来。</p>
<p>新建一个 mixins.js 文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存原生的 Page 函数</span></span><br><span class="line"><span class="keyword">const</span> originPage = <span class="title class_">Page</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Page</span> = <span class="function">(<span class="params">options</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> mixins = options.<span class="property">mixins</span>;</span><br><span class="line">  <span class="comment">// mixins 必须为数组</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(mixins)) &#123;</span><br><span class="line">    <span class="keyword">delete</span> options.<span class="property">mixins</span>;</span><br><span class="line">    <span class="comment">// mixins 注入并执行相应逻辑</span></span><br><span class="line">    options = <span class="title function_">merge</span>(mixins, options);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 释放原生 Page 函数</span></span><br><span class="line">  <span class="title function_">originPage</span>(options);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">1234567891011121314</span>;</span><br></pre></td></tr></table></figure>

<p>原理很简单，关键的地方在于 merge() 函数。merge 函数即为小程序 Mixins 运行机制的具体实现，完全按照上一节总结的三条结论来进行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义小程序内置的属性/方法</span></span><br><span class="line"><span class="keyword">const</span> originProperties = [<span class="string">&quot;data&quot;</span>, <span class="string">&quot;properties&quot;</span>, <span class="string">&quot;options&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> originMethods = [</span><br><span class="line">  <span class="string">&quot;onLoad&quot;</span>,</span><br><span class="line">  <span class="string">&quot;onReady&quot;</span>,</span><br><span class="line">  <span class="string">&quot;onShow&quot;</span>,</span><br><span class="line">  <span class="string">&quot;onHide&quot;</span>,</span><br><span class="line">  <span class="string">&quot;onUnload&quot;</span>,</span><br><span class="line">  <span class="string">&quot;onPullDownRefresh&quot;</span>,</span><br><span class="line">  <span class="string">&quot;onReachBottom&quot;</span>,</span><br><span class="line">  <span class="string">&quot;onShareAppMessage&quot;</span>,</span><br><span class="line">  <span class="string">&quot;onPageScroll&quot;</span>,</span><br><span class="line">  <span class="string">&quot;onTabItemTap&quot;</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">mixins, options</span>) &#123;</span><br><span class="line">  mixins.<span class="title function_">forEach</span>(<span class="function">(<span class="params">mixin</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(mixin) !== <span class="string">&quot;[object Object]&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;mixin 类型必须为对象！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历 mixin 里面的所有属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(mixin)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (originProperties.<span class="title function_">includes</span>(key)) &#123;</span><br><span class="line">        <span class="comment">// 内置对象属性混入</span></span><br><span class="line">        options[key] = &#123; ...value, ...options[key] &#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (originMethods.<span class="title function_">includes</span>(key)) &#123;</span><br><span class="line">        <span class="comment">// 内置方法属性混入，优先执行混入的部分</span></span><br><span class="line">        <span class="keyword">const</span> originFunc = options[key];</span><br><span class="line">        options[key] = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">          value.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args);</span><br><span class="line">          <span class="keyword">return</span> originFunc &amp;&amp; originFunc.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args);</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义方法混入</span></span><br><span class="line">        options = &#123; ...mixin, ...options &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> options;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Mixins-使用"><a href="#Mixins-使用" class="headerlink" title="Mixins 使用"></a>Mixins 使用</h3><p>1、在小程序的 app.js 里引入 mixins.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;./mixins.js&quot;</span>);</span><br><span class="line"><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>2、撰写一个 myMixin.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">data</span>: &#123; <span class="attr">someData</span>: <span class="string">&quot;myMixin&quot;</span> &#125;,</span><br><span class="line">  <span class="title function_">onShow</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Log from mixin!&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、在 page&#x2F;index&#x2F;index.js 中使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="attr">mixins</span>: [<span class="built_in">require</span>(<span class="string">&quot;../../myMixin.js&quot;</span>)],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是进程?什么的线程?</title>
    <url>/post/ae7d37d3307a/</url>
    <content><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>操作系统中最核心的概念就是进程，进程是对正在运行中的程序的一个抽象，是系统进行资源分配和调度的基本单位</p>
<p>操作系统的其他所有内容都是围绕着进程展开的，负责执行这些任务的是 CPU</p>
<p>进程是一种抽象的概念，从来没有统一的标准定义看，一般由程序、数据集合和进程控制块三部分组成：</p>
<ul>
<li><p>程序用于描述进程要完成的功能，是控制进程执行的指令集</p>
</li>
<li><p>数据集合是程序在执行时所需要的数据和工作区</p>
</li>
<li><p>程序控制块，包含进程的描述信息和控制信息，是进程存在的唯一标志</p>
</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程（thread）是操作系统能够进行运算调度的最小单位，其是进程中的一个执行任务（控制单元），负责当前进程中程序的执行</p>
<p>一个进程至少有一个线程，一个进程可以运行多个线程，这些线程共享同一块内存，线程之间可以共享对象、资源，如果有冲突或需要协同，还可以随时沟通以解决冲突或保持同步</p>
<p>举个例子，假设你经营着一家物业管理公司。最初，业务量很小，事事都需要你亲力亲为。给老张家修完暖气管道，立马再去老李家换电灯泡—这叫单线程，所有的工作都得顺序执行</p>
<p>后来业务拓展了，你雇佣了几个工人，这样，你的物业公司就可以同时为多户人家提供服务了—这叫多线程，你是主线程。但实际上，并不是线程越多，进程的工作效率越高，这是因为在一个进程内，不管你创建了多少线程，它们总是被限定在一颗 CPU内，或者多核 CPU的一个核内</p>
<p>这意味着，多线程在宏观上是并行的，在微观上则是分时切换串行的，多线程编程无法充分发挥多核计算资源的优势</p>
<p>这导致使用多线程做任务并行处理时，线程数量超过一定数值后，线程越多速度反倒越慢的原因</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li><p>本质区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位</p>
</li>
<li><p>在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小</p>
</li>
<li><p>所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</p>
</li>
<li><p>内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源</p>
</li>
<li><p>包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程</p>
</li>
</ul>
<p>举个例子：进程＝火车，线程＝车厢</p>
<ul>
<li><p>线程在进程下行进（单纯的车厢无法运行）</p>
</li>
<li><p>一个进程可以包含多个线程（一辆火车可以有多个车厢）</p>
</li>
<li><p>不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）</p>
</li>
<li><p>同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）</p>
</li>
<li><p>进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）</p>
</li>
<li><p>进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>中文转拼音函数</title>
    <url>/post/47639946b6d6/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 所有的拼音转码</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">PinYin</span> = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="string">&#x27;\u554a\u963f\u9515&#x27;</span>,</span><br><span class="line">  <span class="attr">ai</span>:</span><br><span class="line">    <span class="string">&#x27;\u57c3\u6328\u54ce\u5509\u54c0\u7691\u764c\u853c\u77ee\u827e\u788d\u7231\u9698\u8bf6\u6371\u55f3\u55cc\u5ad2\u7477\u66a7\u7839\u953f\u972d&#x27;</span>,</span><br><span class="line">  <span class="attr">an</span>:</span><br><span class="line">    <span class="string">&#x27;\u978d\u6c28\u5b89\u4ffa\u6309\u6697\u5cb8\u80fa\u6848\u8c19\u57ef\u63de\u72b4\u5eb5\u6849\u94f5\u9e4c\u9878\u9eef&#x27;</span>,</span><br><span class="line">  <span class="attr">ang</span>: <span class="string">&#x27;\u80ae\u6602\u76ce&#x27;</span>,</span><br><span class="line">  <span class="attr">ao</span>:</span><br><span class="line">    <span class="string">&#x27;\u51f9\u6556\u71ac\u7ff1\u8884\u50b2\u5965\u61ca\u6fb3\u5773\u62d7\u55f7\u5662\u5c99\u5ed2\u9068\u5aaa\u9a9c\u8071\u87af\u93ca\u9ccc\u93d6&#x27;</span>,</span><br><span class="line">  <span class="attr">ba</span>:</span><br><span class="line">    <span class="string">&#x27;\u82ad\u634c\u6252\u53ed\u5427\u7b06\u516b\u75a4\u5df4\u62d4\u8dcb\u9776\u628a\u8019\u575d\u9738\u7f62\u7238\u8307\u83dd\u8406\u636d\u5c9c\u705e\u6777\u94af\u7c91\u9c85\u9b43&#x27;</span>,</span><br><span class="line">  <span class="attr">bai</span>: <span class="string">&#x27;\u767d\u67cf\u767e\u6446\u4f70\u8d25\u62dc\u7a17\u859c\u63b0\u97b4&#x27;</span>,</span><br><span class="line">  <span class="attr">ban</span>:</span><br><span class="line">    <span class="string">&#x27;\u6591\u73ed\u642c\u6273\u822c\u9881\u677f\u7248\u626e\u62cc\u4f34\u74e3\u534a\u529e\u7eca\u962a\u5742\u8c73\u94a3\u7622\u764d\u8228&#x27;</span>,</span><br><span class="line">  <span class="attr">bang</span>:</span><br><span class="line">    <span class="string">&#x27;\u90a6\u5e2e\u6886\u699c\u8180\u7ed1\u68d2\u78c5\u868c\u9551\u508d\u8c24\u84a1\u8783&#x27;</span>,</span><br><span class="line">  <span class="attr">bao</span>:</span><br><span class="line">    <span class="string">&#x27;\u82de\u80de\u5305\u8912\u96f9\u4fdd\u5821\u9971\u5b9d\u62b1\u62a5\u66b4\u8c79\u9c8d\u7206\u52f9\u8446\u5b80\u5b62\u7172\u9e28\u8913\u8db5\u9f85&#x27;</span>,</span><br><span class="line">  <span class="attr">bo</span>:</span><br><span class="line">    <span class="string">&#x27;\u5265\u8584\u73bb\u83e0\u64ad\u62e8\u94b5\u6ce2\u535a\u52c3\u640f\u94c2\u7b94\u4f2f\u5e1b\u8236\u8116\u818a\u6e24\u6cca\u9a73\u4eb3\u8543\u5575\u997d\u6a97\u64d8\u7934\u94b9\u9e41\u7c38\u8ddb&#x27;</span>,</span><br><span class="line">  <span class="attr">bei</span>:</span><br><span class="line">    <span class="string">&#x27;\u676f\u7891\u60b2\u5351\u5317\u8f88\u80cc\u8d1d\u94a1\u500d\u72c8\u5907\u60eb\u7119\u88ab\u5b5b\u9642\u90b6\u57e4\u84d3\u5457\u602b\u6096\u789a\u9e4e\u8919\u943e&#x27;</span>,</span><br><span class="line">  <span class="attr">ben</span>: <span class="string">&#x27;\u5954\u82ef\u672c\u7b28\u755a\u574c\u951b&#x27;</span>,</span><br><span class="line">  <span class="attr">beng</span>: <span class="string">&#x27;\u5d29\u7ef7\u752d\u6cf5\u8e66\u8ff8\u552a\u5623\u750f&#x27;</span>,</span><br><span class="line">  <span class="attr">bi</span>:</span><br><span class="line">    <span class="string">&#x27;\u903c\u9f3b\u6bd4\u9119\u7b14\u5f7c\u78a7\u84d6\u853d\u6bd5\u6bd9\u6bd6\u5e01\u5e87\u75f9\u95ed\u655d\u5f0a\u5fc5\u8f9f\u58c1\u81c2\u907f\u965b\u5315\u4ef3\u4ffe\u8298\u835c\u8378\u5421\u54d4\u72f4\u5eb3\u610e\u6ed7\u6fde\u5f3c\u59a3\u5a62\u5b16\u74a7\u8d32\u7540\u94cb\u79d5\u88e8\u7b5a\u7b85\u7be6\u822d\u895e\u8df8\u9ac0&#x27;</span>,</span><br><span class="line">  <span class="attr">bian</span>:</span><br><span class="line">    <span class="string">&#x27;\u97ad\u8fb9\u7f16\u8d2c\u6241\u4fbf\u53d8\u535e\u8fa8\u8fa9\u8fab\u904d\u533e\u5f01\u82c4\u5fed\u6c74\u7f0f\u7178\u782d\u78a5\u7a39\u7a86\u8759\u7b3e\u9cca&#x27;</span>,</span><br><span class="line">  <span class="attr">biao</span>:</span><br><span class="line">    <span class="string">&#x27;\u6807\u5f6a\u8198\u8868\u5a4a\u9aa0\u98d1\u98d9\u98da\u706c\u9556\u9573\u762d\u88f1\u9cd4&#x27;</span>,</span><br><span class="line">  <span class="attr">bie</span>: <span class="string">&#x27;\u9cd6\u618b\u522b\u762a\u8e69\u9cd8&#x27;</span>,</span><br><span class="line">  <span class="attr">bin</span>:</span><br><span class="line">    <span class="string">&#x27;\u5f6c\u658c\u6fd2\u6ee8\u5bbe\u6448\u50a7\u6d5c\u7f24\u73a2\u6ba1\u8191\u9554\u9acc\u9b13&#x27;</span>,</span><br><span class="line">  <span class="attr">bing</span>:</span><br><span class="line">    <span class="string">&#x27;\u5175\u51b0\u67c4\u4e19\u79c9\u997c\u70b3\u75c5\u5e76\u7980\u90b4\u6452\u7ee0\u678b\u69df\u71f9&#x27;</span>,</span><br><span class="line">  <span class="attr">bu</span>:</span><br><span class="line">    <span class="string">&#x27;\u6355\u535c\u54fa\u8865\u57e0\u4e0d\u5e03\u6b65\u7c3f\u90e8\u6016\u62ca\u535f\u900b\u74ff\u6661\u949a\u91ad&#x27;</span>,</span><br><span class="line">  <span class="attr">ca</span>: <span class="string">&#x27;\u64e6\u5693\u7924&#x27;</span>,</span><br><span class="line">  <span class="attr">cai</span>: <span class="string">&#x27;\u731c\u88c1\u6750\u624d\u8d22\u776c\u8e29\u91c7\u5f69\u83dc\u8521&#x27;</span>,</span><br><span class="line">  <span class="attr">can</span>: <span class="string">&#x27;\u9910\u53c2\u8695\u6b8b\u60ed\u60e8\u707f\u9a96\u74a8\u7cb2\u9eea&#x27;</span>,</span><br><span class="line">  <span class="attr">cang</span>: <span class="string">&#x27;\u82cd\u8231\u4ed3\u6ca7\u85cf\u4f27&#x27;</span>,</span><br><span class="line">  <span class="attr">cao</span>: <span class="string">&#x27;\u64cd\u7cd9\u69fd\u66f9\u8349\u8279\u5608\u6f15\u87ac\u825a&#x27;</span>,</span><br><span class="line">  <span class="attr">ce</span>: <span class="string">&#x27;\u5395\u7b56\u4fa7\u518c\u6d4b\u5202\u5e3b\u607b&#x27;</span>,</span><br><span class="line">  <span class="attr">ceng</span>: <span class="string">&#x27;\u5c42\u8e6d\u564c&#x27;</span>,</span><br><span class="line">  <span class="attr">cha</span>:</span><br><span class="line">    <span class="string">&#x27;\u63d2\u53c9\u832c\u8336\u67e5\u78b4\u643d\u5bdf\u5c94\u5dee\u8be7\u7339\u9987\u6c4a\u59f9\u6748\u6942\u69ce\u6aab\u9497\u9538\u9572\u8869&#x27;</span>,</span><br><span class="line">  <span class="attr">chai</span>: <span class="string">&#x27;\u62c6\u67f4\u8c7a\u4faa\u8308\u7625\u867f\u9f87&#x27;</span>,</span><br><span class="line">  <span class="attr">chan</span>:</span><br><span class="line">    <span class="string">&#x27;\u6400\u63ba\u8749\u998b\u8c17\u7f20\u94f2\u4ea7\u9610\u98a4\u5181\u8c04\u8c36\u8487\u5edb\u5fcf\u6f7a\u6fb6\u5b71\u7fbc\u5a75\u5b17\u9aa3\u89c7\u7985\u9561\u88e3\u87fe\u8e94&#x27;</span>,</span><br><span class="line">  <span class="attr">chang</span>:</span><br><span class="line">    <span class="string">&#x27;\u660c\u7316\u573a\u5c1d\u5e38\u957f\u507f\u80a0\u5382\u655e\u7545\u5531\u5021\u4f25\u9b2f\u82cc\u83d6\u5f9c\u6005\u60dd\u960a\u5a3c\u5ae6\u6636\u6c05\u9cb3&#x27;</span>,</span><br><span class="line">  <span class="attr">chao</span>:</span><br><span class="line">    <span class="string">&#x27;\u8d85\u6284\u949e\u671d\u5632\u6f6e\u5de2\u5435\u7092\u600a\u7ec9\u6641\u8016&#x27;</span>,</span><br><span class="line">  <span class="attr">che</span>: <span class="string">&#x27;\u8f66\u626f\u64a4\u63a3\u5f7b\u6f88\u577c\u5c6e\u7817&#x27;</span>,</span><br><span class="line">  <span class="attr">chen</span>:</span><br><span class="line">    <span class="string">&#x27;\u90f4\u81e3\u8fb0\u5c18\u6668\u5ff1\u6c89\u9648\u8d81\u886c\u79f0\u8c0c\u62bb\u55d4\u5bb8\u741b\u6987\u809c\u80c2\u789c\u9f80&#x27;</span>,</span><br><span class="line">  <span class="attr">cheng</span>:</span><br><span class="line">    <span class="string">&#x27;\u6491\u57ce\u6a59\u6210\u5448\u4e58\u7a0b\u60e9\u6f84\u8bda\u627f\u901e\u9a8b\u79e4\u57d5\u5d4a\u5fb5\u6d48\u67a8\u67fd\u6a18\u665f\u584d\u77a0\u94d6\u88ce\u86cf\u9172&#x27;</span>,</span><br><span class="line">  <span class="attr">chi</span>:</span><br><span class="line">    <span class="string">&#x27;\u5403\u75f4\u6301\u5319\u6c60\u8fdf\u5f1b\u9a70\u803b\u9f7f\u4f88\u5c3a\u8d64\u7fc5\u65a5\u70bd\u50ba\u5880\u82aa\u830c\u640b\u53f1\u54e7\u557b\u55e4\u5f73\u996c\u6cb2\u5ab8\u6555\u80dd\u7719\u7735\u9e31\u761b\u892b\u86a9\u87ad\u7b1e\u7bea\u8c49\u8e05\u8e1f\u9b51&#x27;</span>,</span><br><span class="line">  <span class="attr">chong</span>: <span class="string">&#x27;\u5145\u51b2\u866b\u5d07\u5ba0\u833a\u5fe1\u61a7\u94f3\u825f&#x27;</span>,</span><br><span class="line">  <span class="attr">chou</span>:</span><br><span class="line">    <span class="string">&#x27;\u62bd\u916c\u7574\u8e0c\u7a20\u6101\u7b79\u4ec7\u7ef8\u7785\u4e11\u4fe6\u5733\u5e31\u60c6\u6eb4\u59af\u7633\u96e0\u9c8b&#x27;</span>,</span><br><span class="line">  <span class="attr">chu</span>:</span><br><span class="line">    <span class="string">&#x27;\u81ed\u521d\u51fa\u6a71\u53a8\u8e87\u9504\u96cf\u6ec1\u9664\u695a\u7840\u50a8\u77d7\u6410\u89e6\u5904\u4e8d\u520d\u61b7\u7ecc\u6775\u696e\u6a17\u870d\u8e70\u9edc&#x27;</span>,</span><br><span class="line">  <span class="attr">chuan</span>:</span><br><span class="line">    <span class="string">&#x27;\u63e3\u5ddd\u7a7f\u693d\u4f20\u8239\u5598\u4e32\u63be\u821b\u60f4\u9044\u5ddb\u6c1a\u948f\u9569\u8221&#x27;</span>,</span><br><span class="line">  <span class="attr">chuang</span>: <span class="string">&#x27;\u75ae\u7a97\u5e62\u5e8a\u95ef\u521b\u6006&#x27;</span>,</span><br><span class="line">  <span class="attr">chui</span>: <span class="string">&#x27;\u5439\u708a\u6376\u9524\u5782\u9672\u68f0\u69cc&#x27;</span>,</span><br><span class="line">  <span class="attr">chun</span>:</span><br><span class="line">    <span class="string">&#x27;\u6625\u693f\u9187\u5507\u6df3\u7eaf\u8822\u4fc3\u83bc\u6c8c\u80ab\u6710\u9e51\u877d&#x27;</span>,</span><br><span class="line">  <span class="attr">chuo</span>: <span class="string">&#x27;\u6233\u7ef0\u851f\u8fb6\u8f8d\u955e\u8e14\u9f8a&#x27;</span>,</span><br><span class="line">  <span class="attr">ci</span>:</span><br><span class="line">    <span class="string">&#x27;\u75b5\u8328\u78c1\u96cc\u8f9e\u6148\u74f7\u8bcd\u6b64\u523a\u8d50\u6b21\u8360\u5472\u5d6f\u9e5a\u8785\u7ccd\u8d91&#x27;</span>,</span><br><span class="line">  <span class="attr">cong</span>:</span><br><span class="line">    <span class="string">&#x27;\u806a\u8471\u56f1\u5306\u4ece\u4e1b\u506c\u82c1\u6dd9\u9aa2\u742e\u7481\u679e&#x27;</span>,</span><br><span class="line">  <span class="attr">cu</span>: <span class="string">&#x27;\u51d1\u7c97\u918b\u7c07\u731d\u6b82\u8e59&#x27;</span>,</span><br><span class="line">  <span class="attr">cuan</span>: <span class="string">&#x27;\u8e7f\u7be1\u7a9c\u6c46\u64ba\u6615\u7228&#x27;</span>,</span><br><span class="line">  <span class="attr">cui</span>:</span><br><span class="line">    <span class="string">&#x27;\u6467\u5d14\u50ac\u8106\u7601\u7cb9\u6dec\u7fe0\u8403\u60b4\u7480\u69b1\u96b9&#x27;</span>,</span><br><span class="line">  <span class="attr">cun</span>: <span class="string">&#x27;\u6751\u5b58\u5bf8\u78cb\u5fd6\u76b4&#x27;</span>,</span><br><span class="line">  <span class="attr">cuo</span>:</span><br><span class="line">    <span class="string">&#x27;\u64ae\u6413\u63aa\u632b\u9519\u539d\u811e\u9509\u77ec\u75e4\u9e7e\u8e49\u8e9c&#x27;</span>,</span><br><span class="line">  <span class="attr">da</span>:</span><br><span class="line">    <span class="string">&#x27;\u642d\u8fbe\u7b54\u7629\u6253\u5927\u8037\u54d2\u55d2\u601b\u59b2\u75b8\u8921\u7b2a\u977c\u9791&#x27;</span>,</span><br><span class="line">  <span class="attr">dai</span>:</span><br><span class="line">    <span class="string">&#x27;\u5446\u6b79\u50a3\u6234\u5e26\u6b86\u4ee3\u8d37\u888b\u5f85\u902e\u6020\u57ed\u7519\u5454\u5cb1\u8fe8\u902f\u9a80\u7ed0\u73b3\u9edb&#x27;</span>,</span><br><span class="line">  <span class="attr">dan</span>:</span><br><span class="line">    <span class="string">&#x27;\u803d\u62c5\u4e39\u5355\u90f8\u63b8\u80c6\u65e6\u6c2e\u4f46\u60ee\u6de1\u8bde\u5f39\u86cb\u4ebb\u510b\u5369\u840f\u5556\u6fb9\u6a90\u6b9a\u8d55\u7708\u7605\u8043\u7baa&#x27;</span>,</span><br><span class="line">  <span class="attr">dang</span>:</span><br><span class="line">    <span class="string">&#x27;\u5f53\u6321\u515a\u8361\u6863\u8c20\u51fc\u83ea\u5b95\u7800\u94db\u88c6&#x27;</span>,</span><br><span class="line">  <span class="attr">dao</span>:</span><br><span class="line">    <span class="string">&#x27;\u5200\u6363\u8e48\u5012\u5c9b\u7977\u5bfc\u5230\u7a3b\u60bc\u9053\u76d7\u53e8\u5541\u5fc9\u6d2e\u6c18\u7118\u5fd1\u7e9b&#x27;</span>,</span><br><span class="line">  <span class="attr">de</span>: <span class="string">&#x27;\u5fb7\u5f97\u7684\u951d&#x27;</span>,</span><br><span class="line">  <span class="attr">deng</span>:</span><br><span class="line">    <span class="string">&#x27;\u8e6c\u706f\u767b\u7b49\u77aa\u51f3\u9093\u5654\u5d9d\u6225\u78f4\u956b\u7c26&#x27;</span>,</span><br><span class="line">  <span class="attr">di</span>:</span><br><span class="line">    <span class="string">&#x27;\u5824\u4f4e\u6ef4\u8fea\u654c\u7b1b\u72c4\u6da4\u7fdf\u5ae1\u62b5\u5e95\u5730\u8482\u7b2c\u5e1d\u5f1f\u9012\u7f14\u6c10\u7c74\u8bcb\u8c1b\u90b8\u577b\u839c\u837b\u5600\u5a23\u67e2\u68e3\u89cc\u7825\u78b2\u7747\u955d\u7f9d\u9ab6&#x27;</span>,</span><br><span class="line">  <span class="attr">dian</span>:</span><br><span class="line">    <span class="string">&#x27;\u98a0\u6382\u6ec7\u7898\u70b9\u5178\u975b\u57ab\u7535\u4f43\u7538\u5e97\u60e6\u5960\u6dc0\u6bbf\u4e36\u963d\u576b\u57dd\u5dc5\u73b7\u765c\u766b\u7c1f\u8e2e&#x27;</span>,</span><br><span class="line">  <span class="attr">diao</span>:</span><br><span class="line">    <span class="string">&#x27;\u7889\u53fc\u96d5\u51cb\u5201\u6389\u540a\u9493\u8c03\u8f7a\u94de\u8729\u7c9c\u8c82&#x27;</span>,</span><br><span class="line">  <span class="attr">die</span>:</span><br><span class="line">    <span class="string">&#x27;\u8dcc\u7239\u789f\u8776\u8fed\u8c0d\u53e0\u4f5a\u57a4\u581e\u63f2\u558b\u6e2b\u8f76\u7252\u74de\u8936\u800b\u8e40\u9cbd\u9cce&#x27;</span>,</span><br><span class="line">  <span class="attr">ding</span>:</span><br><span class="line">    <span class="string">&#x27;\u4e01\u76ef\u53ee\u9489\u9876\u9f0e\u952d\u5b9a\u8ba2\u4e22\u4ec3\u5576\u738e\u815a\u7887\u753a\u94e4\u7594\u8035\u914a&#x27;</span>,</span><br><span class="line">  <span class="attr">dong</span>:</span><br><span class="line">    <span class="string">&#x27;\u4e1c\u51ac\u8463\u61c2\u52a8\u680b\u4f97\u606b\u51bb\u6d1e\u578c\u549a\u5cbd\u5cd2\u5902\u6c21\u80e8\u80f4\u7850\u9e2b&#x27;</span>,</span><br><span class="line">  <span class="attr">dou</span>:</span><br><span class="line">    <span class="string">&#x27;\u515c\u6296\u6597\u9661\u8c46\u9017\u75d8\u8538\u94ad\u7aa6\u7aac\u86aa\u7bfc\u9161&#x27;</span>,</span><br><span class="line">  <span class="attr">du</span>:</span><br><span class="line">    <span class="string">&#x27;\u90fd\u7763\u6bd2\u728a\u72ec\u8bfb\u5835\u7779\u8d4c\u675c\u9540\u809a\u5ea6\u6e21\u5992\u828f\u561f\u6e0e\u691f\u6a50\u724d\u8839\u7b03\u9ad1\u9ee9&#x27;</span>,</span><br><span class="line">  <span class="attr">duan</span>: <span class="string">&#x27;\u7aef\u77ed\u953b\u6bb5\u65ad\u7f0e\u5f56\u6934\u7145\u7c16&#x27;</span>,</span><br><span class="line">  <span class="attr">dui</span>: <span class="string">&#x27;\u5806\u5151\u961f\u5bf9\u603c\u619d\u7893&#x27;</span>,</span><br><span class="line">  <span class="attr">dun</span>:</span><br><span class="line">    <span class="string">&#x27;\u58a9\u5428\u8e72\u6566\u987f\u56e4\u949d\u76fe\u9041\u7096\u7818\u7905\u76f9\u9566\u8db8&#x27;</span>,</span><br><span class="line">  <span class="attr">duo</span>:</span><br><span class="line">    <span class="string">&#x27;\u6387\u54c6\u591a\u593a\u579b\u8eb2\u6735\u8dfa\u8235\u5241\u60f0\u5815\u5484\u54da\u7f0d\u67c1\u94ce\u88f0\u8e31&#x27;</span>,</span><br><span class="line">  <span class="attr">e</span>:</span><br><span class="line">    <span class="string">&#x27;\u86fe\u5ce8\u9e45\u4fc4\u989d\u8bb9\u5a25\u6076\u5384\u627c\u904f\u9102\u997f\u5669\u8c14\u57a9\u57ad\u82ca\u83aa\u843c\u5443\u6115\u5c59\u5a40\u8f6d\u66f7\u816d\u786a\u9507\u9537\u9e57\u989a\u9cc4&#x27;</span>,</span><br><span class="line">  <span class="attr">en</span>: <span class="string">&#x27;\u6069\u84bd\u6441\u5514\u55ef&#x27;</span>,</span><br><span class="line">  <span class="attr">er</span>:</span><br><span class="line">    <span class="string">&#x27;\u800c\u513f\u8033\u5c14\u9975\u6d31\u4e8c\u8d30\u8fe9\u73e5\u94d2\u9e38\u9c95&#x27;</span>,</span><br><span class="line">  <span class="attr">fa</span>: <span class="string">&#x27;\u53d1\u7f5a\u7b4f\u4f10\u4e4f\u9600\u6cd5\u73d0\u57a1\u781d&#x27;</span>,</span><br><span class="line">  <span class="attr">fan</span>:</span><br><span class="line">    <span class="string">&#x27;\u85e9\u5e06\u756a\u7ffb\u6a0a\u77fe\u9492\u7e41\u51e1\u70e6\u53cd\u8fd4\u8303\u8d29\u72af\u996d\u6cdb\u8629\u5e61\u72ad\u68b5\u6535\u71d4\u7548\u8e6f&#x27;</span>,</span><br><span class="line">  <span class="attr">fang</span>:</span><br><span class="line">    <span class="string">&#x27;\u574a\u82b3\u65b9\u80aa\u623f\u9632\u59a8\u4eff\u8bbf\u7eba\u653e\u531a\u90a1\u5f77\u94ab\u822b\u9c82&#x27;</span>,</span><br><span class="line">  <span class="attr">fei</span>:</span><br><span class="line">    <span class="string">&#x27;\u83f2\u975e\u5561\u98de\u80a5\u532a\u8bfd\u5420\u80ba\u5e9f\u6cb8\u8d39\u82be\u72d2\u60b1\u6ddd\u5983\u7ecb\u7eef\u69a7\u8153\u6590\u6249\u7953\u7829\u9544\u75f1\u871a\u7bda\u7fe1\u970f\u9cb1&#x27;</span>,</span><br><span class="line">  <span class="attr">fen</span>:</span><br><span class="line">    <span class="string">&#x27;\u82ac\u915a\u5429\u6c1b\u5206\u7eb7\u575f\u711a\u6c7e\u7c89\u594b\u4efd\u5fff\u6124\u7caa\u507e\u7035\u68fc\u610d\u9cbc\u9f22&#x27;</span>,</span><br><span class="line">  <span class="attr">feng</span>:</span><br><span class="line">    <span class="string">&#x27;\u4e30\u5c01\u67ab\u8702\u5cf0\u950b\u98ce\u75af\u70fd\u9022\u51af\u7f1d\u8bbd\u5949\u51e4\u4ff8\u9146\u8451\u6ca3\u781c&#x27;</span>,</span><br><span class="line">  <span class="attr">fu</span>:</span><br><span class="line">    <span class="string">&#x27;\u4f5b\u5426\u592b\u6577\u80a4\u5b75\u6276\u62c2\u8f90\u5e45\u6c1f\u7b26\u4f0f\u4fd8\u670d\u6d6e\u6daa\u798f\u88b1\u5f17\u752b\u629a\u8f85\u4fef\u91dc\u65a7\u812f\u8151\u5e9c\u8150\u8d74\u526f\u8986\u8d4b\u590d\u5085\u4ed8\u961c\u7236\u8179\u8d1f\u5bcc\u8ba3\u9644\u5987\u7f1a\u5490\u5310\u51eb\u90db\u8299\u82fb\u832f\u83a9\u83d4\u544b\u5e5e\u6ecf\u8274\u5b5a\u9a78\u7ec2\u6874\u8d59\u9efb\u9efc\u7f58\u7a03\u99a5\u864d\u86a8\u8709\u8760\u876e\u9eb8\u8dba\u8dd7\u9cc6&#x27;</span>,</span><br><span class="line">  <span class="attr">ga</span>: <span class="string">&#x27;\u5676\u560e\u86e4\u5c2c\u5477\u5c15\u5c1c\u65ee\u9486&#x27;</span>,</span><br><span class="line">  <span class="attr">gai</span>:</span><br><span class="line">    <span class="string">&#x27;\u8be5\u6539\u6982\u9499\u76d6\u6e89\u4e10\u9654\u5793\u6224\u8d45\u80f2&#x27;</span>,</span><br><span class="line">  <span class="attr">gan</span>:</span><br><span class="line">    <span class="string">&#x27;\u5e72\u7518\u6746\u67d1\u7aff\u809d\u8d76\u611f\u79c6\u6562\u8d63\u5769\u82f7\u5c34\u64c0\u6cd4\u6de6\u6f89\u7ec0\u6a44\u65f0\u77f8\u75b3\u9150&#x27;</span>,</span><br><span class="line">  <span class="attr">gang</span>:</span><br><span class="line">    <span class="string">&#x27;\u5188\u521a\u94a2\u7f38\u809b\u7eb2\u5c97\u6e2f\u6206\u7f61\u9883\u7b7b&#x27;</span>,</span><br><span class="line">  <span class="attr">gong</span>:</span><br><span class="line">    <span class="string">&#x27;\u6760\u5de5\u653b\u529f\u606d\u9f9a\u4f9b\u8eac\u516c\u5bab\u5f13\u5de9\u6c5e\u62f1\u8d21\u5171\u857b\u5efe\u54a3\u73d9\u80b1\u86a3\u86e9\u89e5&#x27;</span>,</span><br><span class="line">  <span class="attr">gao</span>:</span><br><span class="line">    <span class="string">&#x27;\u7bd9\u768b\u9ad8\u818f\u7f94\u7cd5\u641e\u9550\u7a3f\u544a\u777e\u8bf0\u90dc\u84bf\u85c1\u7f1f\u69d4\u69c1\u6772\u9506&#x27;</span>,</span><br><span class="line">  <span class="attr">ge</span>:</span><br><span class="line">    <span class="string">&#x27;\u54e5\u6b4c\u6401\u6208\u9e3d\u80f3\u7599\u5272\u9769\u845b\u683c\u9601\u9694\u94ec\u4e2a\u5404\u9b32\u4ee1\u54ff\u5865\u55dd\u7ea5\u643f\u8188\u784c\u94ea\u9549\u88bc\u988c\u867c\u8238\u9abc\u9ac2&#x27;</span>,</span><br><span class="line">  <span class="attr">gei</span>: <span class="string">&#x27;\u7ed9&#x27;</span>,</span><br><span class="line">  <span class="attr">gen</span>: <span class="string">&#x27;\u6839\u8ddf\u4e98\u831b\u54cf\u826e&#x27;</span>,</span><br><span class="line">  <span class="attr">geng</span>: <span class="string">&#x27;\u8015\u66f4\u5e9a\u7fb9\u57c2\u803f\u6897\u54fd\u8d53\u9ca0&#x27;</span>,</span><br><span class="line">  <span class="attr">gou</span>:</span><br><span class="line">    <span class="string">&#x27;\u94a9\u52fe\u6c9f\u82df\u72d7\u57a2\u6784\u8d2d\u591f\u4f5d\u8bdf\u5ca3\u9058\u5abe\u7f11\u89cf\u5f40\u9e32\u7b31\u7bdd\u97b2&#x27;</span>,</span><br><span class="line">  <span class="attr">gu</span>:</span><br><span class="line">    <span class="string">&#x27;\u8f9c\u83c7\u5495\u7b8d\u4f30\u6cbd\u5b64\u59d1\u9f13\u53e4\u86ca\u9aa8\u8c37\u80a1\u6545\u987e\u56fa\u96c7\u560f\u8bc2\u83f0\u54cc\u5d2e\u6c69\u688f\u8f71\u726f\u727f\u80cd\u81cc\u6bc2\u77bd\u7f5f\u94b4\u9522\u74e0\u9e2a\u9e44\u75fc\u86c4\u9164\u89da\u9cb4\u9ab0\u9e58&#x27;</span>,</span><br><span class="line">  <span class="attr">gua</span>: <span class="string">&#x27;\u522e\u74dc\u5250\u5be1\u6302\u8902\u5366\u8bd6\u5471\u681d\u9e39&#x27;</span>,</span><br><span class="line">  <span class="attr">guai</span>: <span class="string">&#x27;\u4e56\u62d0\u602a\u54d9&#x27;</span>,</span><br><span class="line">  <span class="attr">guan</span>:</span><br><span class="line">    <span class="string">&#x27;\u68fa\u5173\u5b98\u51a0\u89c2\u7ba1\u9986\u7f50\u60ef\u704c\u8d2f\u500c\u839e\u63bc\u6dab\u76e5\u9e73\u9ccf&#x27;</span>,</span><br><span class="line">  <span class="attr">guang</span>: <span class="string">&#x27;\u5149\u5e7f\u901b\u72b7\u6844\u80f1\u7592&#x27;</span>,</span><br><span class="line">  <span class="attr">gui</span>:</span><br><span class="line">    <span class="string">&#x27;\u7470\u89c4\u572d\u7845\u5f52\u9f9f\u95fa\u8f68\u9b3c\u8be1\u7678\u6842\u67dc\u8dea\u8d35\u523d\u5326\u523f\u5e8b\u5b84\u59ab\u6867\u7085\u6677\u7688\u7c0b\u9c91\u9cdc&#x27;</span>,</span><br><span class="line">  <span class="attr">gun</span>: <span class="string">&#x27;\u8f8a\u6eda\u68cd\u4e28\u886e\u7ef2\u78d9\u9ca7&#x27;</span>,</span><br><span class="line">  <span class="attr">guo</span>:</span><br><span class="line">    <span class="string">&#x27;\u9505\u90ed\u56fd\u679c\u88f9\u8fc7\u9998\u8803\u57da\u63b4\u5459\u56d7\u5e3c\u5d1e\u7313\u6901\u8662\u951e\u8052\u872e\u873e\u8748&#x27;</span>,</span><br><span class="line">  <span class="attr">ha</span>: <span class="string">&#x27;\u54c8&#x27;</span>,</span><br><span class="line">  <span class="attr">hai</span>: <span class="string">&#x27;\u9ab8\u5b69\u6d77\u6c26\u4ea5\u5bb3\u9a87\u54b4\u55e8\u988f\u91a2&#x27;</span>,</span><br><span class="line">  <span class="attr">han</span>:</span><br><span class="line">    <span class="string">&#x27;\u9163\u61a8\u90af\u97e9\u542b\u6db5\u5bd2\u51fd\u558a\u7f55\u7ff0\u64bc\u634d\u65f1\u61be\u608d\u710a\u6c57\u6c49\u9097\u83e1\u6496\u961a\u701a\u6657\u7113\u9894\u86b6\u9f3e&#x27;</span>,</span><br><span class="line">  <span class="attr">hen</span>: <span class="string">&#x27;\u592f\u75d5\u5f88\u72e0\u6068&#x27;</span>,</span><br><span class="line">  <span class="attr">hang</span>: <span class="string">&#x27;\u676d\u822a\u6c86\u7ed7\u73e9\u6841&#x27;</span>,</span><br><span class="line">  <span class="attr">hao</span>:</span><br><span class="line">    <span class="string">&#x27;\u58d5\u568e\u8c6a\u6beb\u90dd\u597d\u8017\u53f7\u6d69\u8585\u55e5\u5686\u6fe0\u704f\u660a\u7693\u98a2\u869d&#x27;</span>,</span><br><span class="line">  <span class="attr">he</span>:</span><br><span class="line">    <span class="string">&#x27;\u5475\u559d\u8377\u83cf\u6838\u79be\u548c\u4f55\u5408\u76d2\u8c89\u9602\u6cb3\u6db8\u8d6b\u8910\u9e64\u8d3a\u8bc3\u52be\u58d1\u85ff\u55d1\u55ec\u9616\u76cd\u86b5\u7fee&#x27;</span>,</span><br><span class="line">  <span class="attr">hei</span>: <span class="string">&#x27;\u563f\u9ed1&#x27;</span>,</span><br><span class="line">  <span class="attr">heng</span>: <span class="string">&#x27;\u54fc\u4ea8\u6a2a\u8861\u6052\u8a07\u8605&#x27;</span>,</span><br><span class="line">  <span class="attr">hong</span>:</span><br><span class="line">    <span class="string">&#x27;\u8f70\u54c4\u70d8\u8679\u9e3f\u6d2a\u5b8f\u5f18\u7ea2\u9ec9\u8ba7\u836d\u85a8\u95f3\u6cd3&#x27;</span>,</span><br><span class="line">  <span class="attr">hou</span>:</span><br><span class="line">    <span class="string">&#x27;\u5589\u4faf\u7334\u543c\u539a\u5019\u540e\u5820\u5f8c\u9005\u760a\u7bcc\u7cc7\u9c8e\u9aba&#x27;</span>,</span><br><span class="line">  <span class="attr">hu</span>:</span><br><span class="line">    <span class="string">&#x27;\u547c\u4e4e\u5ffd\u745a\u58f6\u846b\u80e1\u8774\u72d0\u7cca\u6e56\u5f27\u864e\u552c\u62a4\u4e92\u6caa\u6237\u51b1\u553f\u56eb\u5cb5\u7322\u6019\u60da\u6d52\u6ef9\u7425\u69f2\u8f77\u89f3\u70c0\u7173\u623d\u6248\u795c\u9e55\u9e71\u7b0f\u9190\u659b&#x27;</span>,</span><br><span class="line">  <span class="attr">hua</span>:</span><br><span class="line">    <span class="string">&#x27;\u82b1\u54d7\u534e\u733e\u6ed1\u753b\u5212\u5316\u8bdd\u5290\u6d4d\u9a85\u6866\u94e7\u7a1e&#x27;</span>,</span><br><span class="line">  <span class="attr">huai</span>: <span class="string">&#x27;\u69d0\u5f8a\u6000\u6dee\u574f\u8fd8\u8e1d&#x27;</span>,</span><br><span class="line">  <span class="attr">huan</span>:</span><br><span class="line">    <span class="string">&#x27;\u6b22\u73af\u6853\u7f13\u6362\u60a3\u5524\u75ea\u8c62\u7115\u6da3\u5ba6\u5e7b\u90c7\u5942\u57b8\u64d0\u571c\u6d39\u6d63\u6f36\u5bf0\u902d\u7f33\u953e\u9ca9\u9b1f&#x27;</span>,</span><br><span class="line">  <span class="attr">huang</span>:</span><br><span class="line">    <span class="string">&#x27;\u8352\u614c\u9ec4\u78fa\u8757\u7c27\u7687\u51f0\u60f6\u714c\u6643\u5e4c\u604d\u8c0e\u968d\u5fa8\u6e5f\u6f62\u9051\u749c\u8093\u7640\u87e5\u7bc1\u9cc7&#x27;</span>,</span><br><span class="line">  <span class="attr">hui</span>:</span><br><span class="line">    <span class="string">&#x27;\u7070\u6325\u8f89\u5fbd\u6062\u86d4\u56de\u6bc1\u6094\u6167\u5349\u60e0\u6666\u8d3f\u79fd\u4f1a\u70e9\u6c47\u8bb3\u8bf2\u7ed8\u8bd9\u8334\u835f\u8559\u54d5\u5599\u96b3\u6d04\u5f57\u7f0b\u73f2\u6656\u605a\u867a\u87ea\u9ebe&#x27;</span>,</span><br><span class="line">  <span class="attr">hun</span>: <span class="string">&#x27;\u8364\u660f\u5a5a\u9b42\u6d51\u6df7\u8be8\u9984\u960d\u6eb7\u7f17&#x27;</span>,</span><br><span class="line">  <span class="attr">huo</span>:</span><br><span class="line">    <span class="string">&#x27;\u8c41\u6d3b\u4f19\u706b\u83b7\u6216\u60d1\u970d\u8d27\u7978\u6509\u56af\u5925\u94ac\u952a\u956c\u8020\u8816&#x27;</span>,</span><br><span class="line">  <span class="attr">ji</span>:</span><br><span class="line">    <span class="string">&#x27;\u51fb\u573e\u57fa\u673a\u7578\u7a3d\u79ef\u7b95\u808c\u9965\u8ff9\u6fc0\u8ba5\u9e21\u59ec\u7ee9\u7f09\u5409\u6781\u68d8\u8f91\u7c4d\u96c6\u53ca\u6025\u75be\u6c72\u5373\u5ac9\u7ea7\u6324\u51e0\u810a\u5df1\u84df\u6280\u5180\u5b63\u4f0e\u796d\u5242\u60b8\u6d4e\u5bc4\u5bc2\u8ba1\u8bb0\u65e2\u5fcc\u9645\u5993\u7ee7\u7eaa\u5c45\u4e0c\u4e69\u525e\u4f76\u4f74\u8114\u58bc\u82a8\u82b0\u8401\u84ba\u857a\u638e\u53fd\u54ad\u54dc\u5527\u5c8c\u5d74\u6d0e\u5f50\u5c50\u9aa5\u757f\u7391\u696b\u6b9b\u621f\u6222\u8d4d\u89ca\u7284\u9f51\u77f6\u7f81\u5d47\u7a37\u7620\u7635\u866e\u7b08\u7b04\u66a8\u8dfb\u8dfd\u9701\u9c9a\u9cab\u9afb\u9e82&#x27;</span>,</span><br><span class="line">  <span class="attr">jia</span>:</span><br><span class="line">    <span class="string">&#x27;\u5609\u67b7\u5939\u4f73\u5bb6\u52a0\u835a\u988a\u8d3e\u7532\u94be\u5047\u7a3c\u4ef7\u67b6\u9a7e\u5ac1\u4f3d\u90cf\u62ee\u5cac\u6d43\u8fe6\u73c8\u621b\u80db\u605d\u94d7\u9553\u75c2\u86f1\u7b33\u8888\u8dcf&#x27;</span>,</span><br><span class="line">  <span class="attr">jian</span>:</span><br><span class="line">    <span class="string">&#x27;\u6b7c\u76d1\u575a\u5c16\u7b3a\u95f4\u714e\u517c\u80a9\u8270\u5978\u7f04\u8327\u68c0\u67ec\u78b1\u7877\u62e3\u6361\u7b80\u4fed\u526a\u51cf\u8350\u69db\u9274\u8df5\u8d31\u89c1\u952e\u7bad\u4ef6\u5065\u8230\u5251\u996f\u6e10\u6e85\u6da7\u5efa\u50ed\u8c0f\u8c2b\u83c5\u84b9\u641b\u56dd\u6e54\u8e47\u8b07\u7f23\u67a7\u67d9\u6957\u620b\u622c\u726e\u728d\u6bfd\u8171\u7751\u950f\u9e63\u88e5\u7b15\u7bb4\u7fe6\u8dbc\u8e3a\u9ca3\u97af&#x27;</span>,</span><br><span class="line">  <span class="attr">jiang</span>:</span><br><span class="line">    <span class="string">&#x27;\u50f5\u59dc\u5c06\u6d46\u6c5f\u7586\u848b\u6868\u5956\u8bb2\u5320\u9171\u964d\u8333\u6d1a\u7edb\u7f30\u729f\u7913\u8029\u7ce8\u8c47&#x27;</span>,</span><br><span class="line">  <span class="attr">jiao</span>:</span><br><span class="line">    <span class="string">&#x27;\u8549\u6912\u7901\u7126\u80f6\u4ea4\u90ca\u6d47\u9a84\u5a07\u56bc\u6405\u94f0\u77eb\u4fa5\u811a\u72e1\u89d2\u997a\u7f34\u7ede\u527f\u6559\u9175\u8f7f\u8f83\u53eb\u4f7c\u50ec\u832d\u6322\u564d\u5ce4\u5fbc\u59e3\u7e9f\u656b\u768e\u9e6a\u86df\u91ae\u8de4\u9c9b&#x27;</span>,</span><br><span class="line">  <span class="attr">jie</span>:</span><br><span class="line">    <span class="string">&#x27;\u7a96\u63ed\u63a5\u7686\u79f8\u8857\u9636\u622a\u52ab\u8282\u6854\u6770\u6377\u776b\u7aed\u6d01\u7ed3\u89e3\u59d0\u6212\u85c9\u82a5\u754c\u501f\u4ecb\u75a5\u8beb\u5c4a\u5048\u8ba6\u8bd8\u5588\u55df\u736c\u5a55\u5b51\u6840\u7352\u78a3\u9534\u7596\u88b7\u9889\u86a7\u7faf\u9c92\u9ab1\u9aeb&#x27;</span>,</span><br><span class="line">  <span class="attr">jin</span>:</span><br><span class="line">    <span class="string">&#x27;\u5dfe\u7b4b\u65a4\u91d1\u4eca\u6d25\u895f\u7d27\u9526\u4ec5\u8c28\u8fdb\u9773\u664b\u7981\u8fd1\u70ec\u6d78\u5c3d\u537a\u8369\u5807\u5664\u9991\u5ed1\u5997\u7f19\u747e\u69ff\u8d46\u89d0\u9485\u9513\u887f\u77dc&#x27;</span>,</span><br><span class="line">  <span class="attr">jing</span>:</span><br><span class="line">    <span class="string">&#x27;\u52b2\u8346\u5162\u830e\u775b\u6676\u9cb8\u4eac\u60ca\u7cbe\u7cb3\u7ecf\u4e95\u8b66\u666f\u9888\u9759\u5883\u656c\u955c\u5f84\u75c9\u9756\u7adf\u7ade\u51c0\u522d\u5106\u9631\u83c1\u734d\u61ac\u6cfe\u8ff3\u5f2a\u5a67\u80bc\u80eb\u8148\u65cc&#x27;</span>,</span><br><span class="line">  <span class="attr">jiong</span>: <span class="string">&#x27;\u70af\u7a98\u5182\u8fe5\u6243&#x27;</span>,</span><br><span class="line">  <span class="attr">jiu</span>:</span><br><span class="line">    <span class="string">&#x27;\u63ea\u7a76\u7ea0\u7396\u97ed\u4e45\u7078\u4e5d\u9152\u53a9\u6551\u65e7\u81fc\u8205\u548e\u5c31\u759a\u50e6\u557e\u9604\u67e9\u6855\u9e6b\u8d73\u9b0f&#x27;</span>,</span><br><span class="line">  <span class="attr">ju</span>:</span><br><span class="line">    <span class="string">&#x27;\u97a0\u62d8\u72d9\u75bd\u9a79\u83ca\u5c40\u5480\u77e9\u4e3e\u6cae\u805a\u62d2\u636e\u5de8\u5177\u8ddd\u8e1e\u952f\u4ff1\u53e5\u60e7\u70ac\u5267\u5028\u8bb5\u82e3\u82f4\u8392\u63ac\u907d\u5c66\u741a\u67b8\u6910\u6998\u6989\u6a58\u728b\u98d3\u949c\u9514\u7aad\u88fe\u8d84\u91b5\u8e3d\u9f83\u96ce\u97ab&#x27;</span>,</span><br><span class="line">  <span class="attr">juan</span>:</span><br><span class="line">    <span class="string">&#x27;\u6350\u9e43\u5a1f\u5026\u7737\u5377\u7ee2\u9104\u72f7\u6d93\u684a\u8832\u9529\u954c\u96bd&#x27;</span>,</span><br><span class="line">  <span class="attr">jue</span>:</span><br><span class="line">    <span class="string">&#x27;\u6485\u652b\u6289\u6398\u5014\u7235\u89c9\u51b3\u8bc0\u7edd\u53a5\u5282\u8c32\u77cd\u8568\u5658\u5d1b\u7357\u5b53\u73cf\u6877\u6a5b\u721d\u9562\u8e76\u89d6&#x27;</span>,</span><br><span class="line">  <span class="attr">jun</span>:</span><br><span class="line">    <span class="string">&#x27;\u5747\u83cc\u94a7\u519b\u541b\u5cfb\u4fca\u7ae3\u6d5a\u90e1\u9a8f\u6343\u72fb\u76b2\u7b60\u9e87&#x27;</span>,</span><br><span class="line">  <span class="attr">ka</span>: <span class="string">&#x27;\u5580\u5496\u5361\u4f67\u5494\u80e9&#x27;</span>,</span><br><span class="line">  <span class="attr">ke</span>:</span><br><span class="line">    <span class="string">&#x27;\u54af\u5777\u82db\u67ef\u68f5\u78d5\u9897\u79d1\u58f3\u54b3\u53ef\u6e34\u514b\u523b\u5ba2\u8bfe\u5ca2\u606a\u6e98\u9a92\u7f02\u73c2\u8f72\u6c2a\u778c\u94b6\u75b4\u7aa0\u874c\u9ac1&#x27;</span>,</span><br><span class="line">  <span class="attr">kai</span>:</span><br><span class="line">    <span class="string">&#x27;\u5f00\u63e9\u6977\u51ef\u6168\u5240\u57b2\u8488\u5ffe\u607a\u94e0\u950e&#x27;</span>,</span><br><span class="line">  <span class="attr">kan</span>:</span><br><span class="line">    <span class="string">&#x27;\u520a\u582a\u52d8\u574e\u780d\u770b\u4f83\u51f5\u83b0\u83b6\u6221\u9f9b\u77b0&#x27;</span>,</span><br><span class="line">  <span class="attr">kang</span>: <span class="string">&#x27;\u5eb7\u6177\u7ce0\u625b\u6297\u4ea2\u7095\u5751\u4f09\u95f6\u94aa&#x27;</span>,</span><br><span class="line">  <span class="attr">kao</span>: <span class="string">&#x27;\u8003\u62f7\u70e4\u9760\u5c3b\u6832\u7292\u94d0&#x27;</span>,</span><br><span class="line">  <span class="attr">ken</span>: <span class="string">&#x27;\u80af\u5543\u57a6\u6073\u57a0\u88c9\u9880&#x27;</span>,</span><br><span class="line">  <span class="attr">keng</span>: <span class="string">&#x27;\u542d\u5fd0\u94ff&#x27;</span>,</span><br><span class="line">  <span class="attr">kong</span>: <span class="string">&#x27;\u7a7a\u6050\u5b54\u63a7\u5025\u5d06\u7b9c&#x27;</span>,</span><br><span class="line">  <span class="attr">kou</span>: <span class="string">&#x27;\u62a0\u53e3\u6263\u5bc7\u82a4\u853b\u53e9\u770d\u7b58&#x27;</span>,</span><br><span class="line">  <span class="attr">ku</span>:</span><br><span class="line">    <span class="string">&#x27;\u67af\u54ed\u7a9f\u82e6\u9177\u5e93\u88e4\u5233\u5800\u55be\u7ed4\u9ab7&#x27;</span>,</span><br><span class="line">  <span class="attr">kua</span>: <span class="string">&#x27;\u5938\u57ae\u630e\u8de8\u80ef\u4f89&#x27;</span>,</span><br><span class="line">  <span class="attr">kuai</span>: <span class="string">&#x27;\u5757\u7b77\u4fa9\u5feb\u84af\u90d0\u8489\u72ef\u810d&#x27;</span>,</span><br><span class="line">  <span class="attr">kuan</span>: <span class="string">&#x27;\u5bbd\u6b3e\u9acb&#x27;</span>,</span><br><span class="line">  <span class="attr">kuang</span>:</span><br><span class="line">    <span class="string">&#x27;\u5321\u7b50\u72c2\u6846\u77ff\u7736\u65f7\u51b5\u8bd3\u8bf3\u909d\u5739\u593c\u54d0\u7ea9\u8d36&#x27;</span>,</span><br><span class="line">  <span class="attr">kui</span>:</span><br><span class="line">    <span class="string">&#x27;\u4e8f\u76d4\u5cbf\u7aa5\u8475\u594e\u9b41\u5080\u9988\u6127\u6e83\u9997\u532e\u5914\u9697\u63c6\u55b9\u559f\u609d\u6126\u9615\u9035\u668c\u777d\u8069\u8770\u7bd1\u81fe\u8dec&#x27;</span>,</span><br><span class="line">  <span class="attr">kun</span>: <span class="string">&#x27;\u5764\u6606\u6346\u56f0\u6083\u9603\u7428\u951f\u918c\u9cb2\u9ae1&#x27;</span>,</span><br><span class="line">  <span class="attr">kuo</span>: <span class="string">&#x27;\u62ec\u6269\u5ed3\u9614\u86de&#x27;</span>,</span><br><span class="line">  <span class="attr">la</span>:</span><br><span class="line">    <span class="string">&#x27;\u5783\u62c9\u5587\u8721\u814a\u8fa3\u5566\u524c\u647a\u908b\u65ef\u782c\u760c&#x27;</span>,</span><br><span class="line">  <span class="attr">lai</span>:</span><br><span class="line">    <span class="string">&#x27;\u83b1\u6765\u8d56\u5d03\u5f95\u6d9e\u6fd1\u8d49\u7750\u94fc\u765e\u7c41&#x27;</span>,</span><br><span class="line">  <span class="attr">lan</span>:</span><br><span class="line">    <span class="string">&#x27;\u84dd\u5a6a\u680f\u62e6\u7bee\u9611\u5170\u6f9c\u8c30\u63fd\u89c8\u61d2\u7f06\u70c2\u6ee5\u5549\u5c9a\u61d4\u6f24\u6984\u6593\u7f71\u9567\u8934&#x27;</span>,</span><br><span class="line">  <span class="attr">lang</span>:</span><br><span class="line">    <span class="string">&#x27;\u7405\u6994\u72fc\u5eca\u90ce\u6717\u6d6a\u83a8\u8497\u5577\u9606\u9512\u7a02\u8782&#x27;</span>,</span><br><span class="line">  <span class="attr">lao</span>:</span><br><span class="line">    <span class="string">&#x27;\u635e\u52b3\u7262\u8001\u4f6c\u59e5\u916a\u70d9\u6d9d\u5520\u5d02\u6833\u94d1\u94f9\u75e8\u91aa&#x27;</span>,</span><br><span class="line">  <span class="attr">le</span>: <span class="string">&#x27;\u52d2\u4e50\u808b\u4ec2\u53fb\u561e\u6cd0\u9cd3&#x27;</span>,</span><br><span class="line">  <span class="attr">lei</span>:</span><br><span class="line">    <span class="string">&#x27;\u96f7\u956d\u857e\u78ca\u7d2f\u5121\u5792\u64c2\u7c7b\u6cea\u7fb8\u8bd4\u837d\u54a7\u6f2f\u5ad8\u7f27\u6a91\u8012\u9179&#x27;</span>,</span><br><span class="line">  <span class="attr">ling</span>:</span><br><span class="line">    <span class="string">&#x27;\u68f1\u51b7\u62ce\u73b2\u83f1\u96f6\u9f84\u94c3\u4f36\u7f9a\u51cc\u7075\u9675\u5cad\u9886\u53e6\u4ee4\u9143\u5844\u82d3\u5464\u56f9\u6ce0\u7eeb\u67c3\u68c2\u74f4\u8046\u86c9\u7fce\u9cae&#x27;</span>,</span><br><span class="line">  <span class="attr">leng</span>: <span class="string">&#x27;\u695e\u6123&#x27;</span>,</span><br><span class="line">  <span class="attr">li</span>:</span><br><span class="line">    <span class="string">&#x27;\u5398\u68a8\u7281\u9ece\u7bf1\u72f8\u79bb\u6f13\u7406\u674e\u91cc\u9ca4\u793c\u8389\u8354\u540f\u6817\u4e3d\u5389\u52b1\u783e\u5386\u5229\u5088\u4f8b\u4fd0\u75e2\u7acb\u7c92\u6ca5\u96b6\u529b\u7483\u54e9\u4fea\u4fda\u90e6\u575c\u82c8\u8385\u84e0\u85dc\u6369\u5456\u5533\u55b1\u7301\u6ea7\u6fa7\u9026\u5a0c\u5ae0\u9a8a\u7f21\u73de\u67a5\u680e\u8f79\u623e\u783a\u8a48\u7f79\u9502\u9e42\u75a0\u75ac\u86ce\u870a\u8821\u7b20\u7be5\u7c9d\u91b4\u8dde\u96f3\u9ca1\u9ce2\u9ee7&#x27;</span>,</span><br><span class="line">  <span class="attr">lian</span>:</span><br><span class="line">    <span class="string">&#x27;\u4fe9\u8054\u83b2\u8fde\u9570\u5ec9\u601c\u6d9f\u5e18\u655b\u8138\u94fe\u604b\u70bc\u7ec3\u631b\u8539\u5941\u6f4b\u6fc2\u5a08\u740f\u695d\u6b93\u81c1\u81a6\u88e2\u880a\u9ca2&#x27;</span>,</span><br><span class="line">  <span class="attr">liang</span>:</span><br><span class="line">    <span class="string">&#x27;\u7cae\u51c9\u6881\u7cb1\u826f\u4e24\u8f86\u91cf\u667e\u4eae\u8c05\u589a\u690b\u8e09\u9753\u9b49&#x27;</span>,</span><br><span class="line">  <span class="attr">liao</span>:</span><br><span class="line">    <span class="string">&#x27;\u64a9\u804a\u50da\u7597\u71ce\u5be5\u8fbd\u6f66\u4e86\u6482\u9563\u5ed6\u6599\u84fc\u5c25\u5639\u7360\u5bee\u7f2d\u948c\u9e69\u8022&#x27;</span>,</span><br><span class="line">  <span class="attr">lie</span>: <span class="string">&#x27;\u5217\u88c2\u70c8\u52a3\u730e\u51bd\u57d2\u6d0c\u8d94\u8e90\u9b23&#x27;</span>,</span><br><span class="line">  <span class="attr">lin</span>:</span><br><span class="line">    <span class="string">&#x27;\u7433\u6797\u78f7\u9716\u4e34\u90bb\u9cde\u6dcb\u51db\u8d41\u541d\u853a\u5d99\u5eea\u9074\u6aa9\u8f9a\u77b5\u7cbc\u8e8f\u9e9f&#x27;</span>,</span><br><span class="line">  <span class="attr">liu</span>:</span><br><span class="line">    <span class="string">&#x27;\u6e9c\u7409\u69b4\u786b\u998f\u7559\u5218\u7624\u6d41\u67f3\u516d\u62a1\u507b\u848c\u6cd6\u6d4f\u905b\u9a9d\u7efa\u65d2\u7198\u950d\u954f\u9e68\u938f&#x27;</span>,</span><br><span class="line">  <span class="attr">long</span>:</span><br><span class="line">    <span class="string">&#x27;\u9f99\u804b\u5499\u7b3c\u7abf\u9686\u5784\u62e2\u9647\u5f04\u5785\u830f\u6cf7\u73d1\u680a\u80e7\u783b\u7643&#x27;</span>,</span><br><span class="line">  <span class="attr">lou</span>:</span><br><span class="line">    <span class="string">&#x27;\u697c\u5a04\u6402\u7bd3\u6f0f\u964b\u55bd\u5d5d\u9542\u7618\u8027\u877c\u9ac5&#x27;</span>,</span><br><span class="line">  <span class="attr">lu</span>:</span><br><span class="line">    <span class="string">&#x27;\u82a6\u5362\u9885\u5e90\u7089\u63b3\u5364\u864f\u9c81\u9e93\u788c\u9732\u8def\u8d42\u9e7f\u6f5e\u7984\u5f55\u9646\u622e\u5786\u6445\u64b8\u565c\u6cf8\u6e0c\u6f09\u7490\u680c\u6a79\u8f73\u8f82\u8f98\u6c07\u80ea\u9565\u9e2c\u9e6d\u7c0f\u823b\u9c88&#x27;</span>,</span><br><span class="line">  <span class="attr">lv</span>:</span><br><span class="line">    <span class="string">&#x27;\u9a74\u5415\u94dd\u4fa3\u65c5\u5c65\u5c61\u7f15\u8651\u6c2f\u5f8b\u7387\u6ee4\u7eff\u634b\u95fe\u6988\u8182\u7a06\u891b&#x27;</span>,</span><br><span class="line">  <span class="attr">luan</span>: <span class="string">&#x27;\u5ce6\u5b6a\u6ee6\u5375\u4e71\u683e\u9e3e\u92ae&#x27;</span>,</span><br><span class="line">  <span class="attr">lue</span>: <span class="string">&#x27;\u63a0\u7565\u950a&#x27;</span>,</span><br><span class="line">  <span class="attr">lun</span>: <span class="string">&#x27;\u8f6e\u4f26\u4ed1\u6ca6\u7eb6\u8bba\u56f5&#x27;</span>,</span><br><span class="line">  <span class="attr">luo</span>:</span><br><span class="line">    <span class="string">&#x27;\u841d\u87ba\u7f57\u903b\u9523\u7ba9\u9aa1\u88f8\u843d\u6d1b\u9a86\u7edc\u502e\u8366\u645e\u7321\u6cfa\u6924\u8136\u9559\u7630\u96d2&#x27;</span>,</span><br><span class="line">  <span class="attr">ma</span>:</span><br><span class="line">    <span class="string">&#x27;\u5988\u9ebb\u739b\u7801\u8682\u9a6c\u9a82\u561b\u5417\u551b\u72b8\u5b37\u6769\u9ebd&#x27;</span>,</span><br><span class="line">  <span class="attr">mai</span>: <span class="string">&#x27;\u57cb\u4e70\u9ea6\u5356\u8fc8\u8109\u52a2\u836c\u54aa\u973e&#x27;</span>,</span><br><span class="line">  <span class="attr">man</span>:</span><br><span class="line">    <span class="string">&#x27;\u7792\u9992\u86ee\u6ee1\u8513\u66fc\u6162\u6f2b\u8c29\u5881\u5e54\u7f26\u71b3\u9558\u989f\u87a8\u9cd7\u9794&#x27;</span>,</span><br><span class="line">  <span class="attr">mang</span>: <span class="string">&#x27;\u8292\u832b\u76f2\u5fd9\u83bd\u9099\u6f2d\u6726\u786d\u87d2&#x27;</span>,</span><br><span class="line">  <span class="attr">meng</span>:</span><br><span class="line">    <span class="string">&#x27;\u6c13\u840c\u8499\u6aac\u76df\u9530\u731b\u68a6\u5b5f\u52d0\u750d\u77a2\u61f5\u791e\u867b\u8722\u8813\u824b\u8268\u9efe&#x27;</span>,</span><br><span class="line">  <span class="attr">miao</span>:</span><br><span class="line">    <span class="string">&#x27;\u732b\u82d7\u63cf\u7784\u85d0\u79d2\u6e3a\u5e99\u5999\u55b5\u9088\u7f08\u7f2a\u676a\u6dfc\u7707\u9e4b\u8731&#x27;</span>,</span><br><span class="line">  <span class="attr">mao</span>:</span><br><span class="line">    <span class="string">&#x27;\u8305\u951a\u6bdb\u77db\u94c6\u536f\u8302\u5192\u5e3d\u8c8c\u8d38\u4f94\u88a4\u52d6\u8306\u5cc1\u7441\u6634\u7266\u8004\u65c4\u61cb\u7780\u86d1\u8765\u87ca\u9ae6&#x27;</span>,</span><br><span class="line">  <span class="attr">me</span>: <span class="string">&#x27;\u4e48&#x27;</span>,</span><br><span class="line">  <span class="attr">mei</span>:</span><br><span class="line">    <span class="string">&#x27;\u73ab\u679a\u6885\u9176\u9709\u7164\u6ca1\u7709\u5a92\u9541\u6bcf\u7f8e\u6627\u5bd0\u59b9\u5a9a\u5776\u8393\u5d4b\u7338\u6d7c\u6e44\u6963\u9545\u9e5b\u8882\u9b45&#x27;</span>,</span><br><span class="line">  <span class="attr">men</span>: <span class="string">&#x27;\u95e8\u95f7\u4eec\u626a\u739f\u7116\u61d1\u9494&#x27;</span>,</span><br><span class="line">  <span class="attr">mi</span>:</span><br><span class="line">    <span class="string">&#x27;\u772f\u919a\u9761\u7cdc\u8ff7\u8c1c\u5f25\u7c73\u79d8\u89c5\u6ccc\u871c\u5bc6\u5e42\u8288\u5196\u8c27\u863c\u5627\u7315\u736f\u6c68\u5b93\u5f2d\u8112\u6549\u7cf8\u7e3b\u9e8b&#x27;</span>,</span><br><span class="line">  <span class="attr">mian</span>:</span><br><span class="line">    <span class="string">&#x27;\u68c9\u7720\u7ef5\u5195\u514d\u52c9\u5a29\u7f05\u9762\u6c94\u6e4e\u817c\u7704&#x27;</span>,</span><br><span class="line">  <span class="attr">mie</span>: <span class="string">&#x27;\u8511\u706d\u54a9\u881b\u7bfe&#x27;</span>,</span><br><span class="line">  <span class="attr">min</span>: <span class="string">&#x27;\u6c11\u62bf\u76bf\u654f\u60af\u95fd\u82e0\u5cb7\u95f5\u6cef\u73c9&#x27;</span>,</span><br><span class="line">  <span class="attr">ming</span>:</span><br><span class="line">    <span class="string">&#x27;\u660e\u879f\u9e23\u94ed\u540d\u547d\u51a5\u8317\u6e9f\u669d\u7791\u9169&#x27;</span>,</span><br><span class="line">  <span class="attr">miu</span>: <span class="string">&#x27;\u8c2c&#x27;</span>,</span><br><span class="line">  <span class="attr">mo</span>:</span><br><span class="line">    <span class="string">&#x27;\u6478\u6479\u8611\u6a21\u819c\u78e8\u6469\u9b54\u62b9\u672b\u83ab\u58a8\u9ed8\u6cab\u6f20\u5bde\u964c\u8c1f\u8309\u84e6\u998d\u5aeb\u9546\u79e3\u763c\u8031\u87c6\u8c8a\u8c98&#x27;</span>,</span><br><span class="line">  <span class="attr">mou</span>: <span class="string">&#x27;\u8c0b\u725f\u67d0\u53b6\u54de\u5a7a\u7738\u936a&#x27;</span>,</span><br><span class="line">  <span class="attr">mu</span>:</span><br><span class="line">    <span class="string">&#x27;\u62c7\u7261\u4ea9\u59c6\u6bcd\u5893\u66ae\u5e55\u52df\u6155\u6728\u76ee\u7766\u7267\u7a46\u4eeb\u82dc\u5452\u6c90\u6bea\u94bc&#x27;</span>,</span><br><span class="line">  <span class="attr">na</span>:</span><br><span class="line">    <span class="string">&#x27;\u62ff\u54ea\u5450\u94a0\u90a3\u5a1c\u7eb3\u5185\u637a\u80ad\u954e\u8872\u7bac&#x27;</span>,</span><br><span class="line">  <span class="attr">nai</span>: <span class="string">&#x27;\u6c16\u4e43\u5976\u8010\u5948\u9f10\u827f\u8418\u67f0&#x27;</span>,</span><br><span class="line">  <span class="attr">nan</span>: <span class="string">&#x27;\u5357\u7537\u96be\u56ca\u5583\u56e1\u6960\u8169\u877b\u8d67&#x27;</span>,</span><br><span class="line">  <span class="attr">nao</span>: <span class="string">&#x27;\u6320\u8111\u607c\u95f9\u5b6c\u57b4\u7331\u7459\u7847\u94d9\u86f2&#x27;</span>,</span><br><span class="line">  <span class="attr">ne</span>: <span class="string">&#x27;\u6dd6\u5462\u8bb7&#x27;</span>,</span><br><span class="line">  <span class="attr">nei</span>: <span class="string">&#x27;\u9981&#x27;</span>,</span><br><span class="line">  <span class="attr">nen</span>: <span class="string">&#x27;\u5ae9\u80fd\u6798\u6041&#x27;</span>,</span><br><span class="line">  <span class="attr">ni</span>:</span><br><span class="line">    <span class="string">&#x27;\u59ae\u9713\u502a\u6ce5\u5c3c\u62df\u4f60\u533f\u817b\u9006\u6eba\u4f32\u576d\u730a\u6029\u6ee0\u6635\u65ce\u7962\u615d\u7768\u94cc\u9cb5&#x27;</span>,</span><br><span class="line">  <span class="attr">nian</span>:</span><br><span class="line">    <span class="string">&#x27;\u852b\u62c8\u5e74\u78be\u64b5\u637b\u5ff5\u5eff\u8f87\u9ecf\u9c87\u9cb6&#x27;</span>,</span><br><span class="line">  <span class="attr">niang</span>: <span class="string">&#x27;\u5a18\u917f&#x27;</span>,</span><br><span class="line">  <span class="attr">niao</span>: <span class="string">&#x27;\u9e1f\u5c3f\u8311\u5b32\u8132\u8885&#x27;</span>,</span><br><span class="line">  <span class="attr">nie</span>:</span><br><span class="line">    <span class="string">&#x27;\u634f\u8042\u5b7d\u556e\u954a\u954d\u6d85\u4e5c\u9667\u8616\u55eb\u8080\u989e\u81ec\u8e51&#x27;</span>,</span><br><span class="line">  <span class="attr">nin</span>: <span class="string">&#x27;\u60a8\u67e0&#x27;</span>,</span><br><span class="line">  <span class="attr">ning</span>: <span class="string">&#x27;\u72de\u51dd\u5b81\u62e7\u6cde\u4f5e\u84e5\u549b\u752f\u804d&#x27;</span>,</span><br><span class="line">  <span class="attr">niu</span>: <span class="string">&#x27;\u725b\u626d\u94ae\u7ebd\u72c3\u5ff8\u599e\u86b4&#x27;</span>,</span><br><span class="line">  <span class="attr">nong</span>: <span class="string">&#x27;\u8113\u6d53\u519c\u4fac&#x27;</span>,</span><br><span class="line">  <span class="attr">nu</span>: <span class="string">&#x27;\u5974\u52aa\u6012\u5476\u5e11\u5f29\u80ec\u5b65\u9a7d&#x27;</span>,</span><br><span class="line">  <span class="attr">nv</span>: <span class="string">&#x27;\u5973\u6067\u9495\u8844&#x27;</span>,</span><br><span class="line">  <span class="attr">nuan</span>: <span class="string">&#x27;\u6696&#x27;</span>,</span><br><span class="line">  <span class="attr">nuenue</span>: <span class="string">&#x27;\u8650&#x27;</span>,</span><br><span class="line">  <span class="attr">nue</span>: <span class="string">&#x27;\u759f\u8c11&#x27;</span>,</span><br><span class="line">  <span class="attr">nuo</span>: <span class="string">&#x27;\u632a\u61e6\u7cef\u8bfa\u50a9\u6426\u558f\u9518&#x27;</span>,</span><br><span class="line">  <span class="attr">ou</span>: <span class="string">&#x27;\u54e6\u6b27\u9e25\u6bb4\u85d5\u5455\u5076\u6ca4\u6004\u74ef\u8026&#x27;</span>,</span><br><span class="line">  <span class="attr">pa</span>: <span class="string">&#x27;\u556a\u8db4\u722c\u5e15\u6015\u7436\u8469\u7b62&#x27;</span>,</span><br><span class="line">  <span class="attr">pai</span>: <span class="string">&#x27;\u62cd\u6392\u724c\u5f98\u6e43\u6d3e\u4ff3\u848e&#x27;</span>,</span><br><span class="line">  <span class="attr">pan</span>:</span><br><span class="line">    <span class="string">&#x27;\u6500\u6f58\u76d8\u78d0\u76fc\u7554\u5224\u53db\u723f\u6cee\u88a2\u897b\u87e0\u8e52&#x27;</span>,</span><br><span class="line">  <span class="attr">pang</span>: <span class="string">&#x27;\u4e53\u5e9e\u65c1\u802a\u80d6\u6ec2\u9004&#x27;</span>,</span><br><span class="line">  <span class="attr">pao</span>:</span><br><span class="line">    <span class="string">&#x27;\u629b\u5486\u5228\u70ae\u888d\u8dd1\u6ce1\u530f\u72cd\u5e96\u812c\u75b1&#x27;</span>,</span><br><span class="line">  <span class="attr">pei</span>:</span><br><span class="line">    <span class="string">&#x27;\u5478\u80da\u57f9\u88f4\u8d54\u966a\u914d\u4f69\u6c9b\u638a\u8f94\u5e14\u6de0\u65c6\u952b\u9185\u9708&#x27;</span>,</span><br><span class="line">  <span class="attr">pen</span>: <span class="string">&#x27;\u55b7\u76c6\u6e53&#x27;</span>,</span><br><span class="line">  <span class="attr">peng</span>:</span><br><span class="line">    <span class="string">&#x27;\u7830\u62a8\u70f9\u6f8e\u5f6d\u84ec\u68da\u787c\u7bf7\u81a8\u670b\u9e4f\u6367\u78b0\u576f\u580b\u562d\u6026\u87db&#x27;</span>,</span><br><span class="line">  <span class="attr">pi</span>:</span><br><span class="line">    <span class="string">&#x27;\u7812\u9739\u6279\u62ab\u5288\u7435\u6bd7\u5564\u813e\u75b2\u76ae\u5339\u75de\u50fb\u5c41\u8b6c\u4e15\u9674\u90b3\u90eb\u572e\u9f19\u64d7\u567c\u5e80\u5ab2\u7eb0\u6787\u7513\u7765\u7f74\u94cd\u75e6\u7656\u758b\u868d\u8c94&#x27;</span>,</span><br><span class="line">  <span class="attr">pian</span>: <span class="string">&#x27;\u7bc7\u504f\u7247\u9a97\u8c1d\u9a88\u728f\u80fc\u890a\u7fe9\u8e41&#x27;</span>,</span><br><span class="line">  <span class="attr">piao</span>: <span class="string">&#x27;\u98d8\u6f02\u74e2\u7968\u527d\u560c\u5ad6\u7f25\u6b8d\u779f\u87b5&#x27;</span>,</span><br><span class="line">  <span class="attr">pie</span>: <span class="string">&#x27;\u6487\u77a5\u4e3f\u82e4\u6c15&#x27;</span>,</span><br><span class="line">  <span class="attr">pin</span>: <span class="string">&#x27;\u62fc\u9891\u8d2b\u54c1\u8058\u62da\u59d8\u5ad4\u6980\u725d\u98a6&#x27;</span>,</span><br><span class="line">  <span class="attr">ping</span>:</span><br><span class="line">    <span class="string">&#x27;\u4e52\u576a\u82f9\u840d\u5e73\u51ed\u74f6\u8bc4\u5c4f\u4fdc\u5a09\u67b0\u9c86&#x27;</span>,</span><br><span class="line">  <span class="attr">po</span>:</span><br><span class="line">    <span class="string">&#x27;\u5761\u6cfc\u9887\u5a46\u7834\u9b44\u8feb\u7c95\u53f5\u9131\u6ea5\u73c0\u948b\u94b7\u76a4\u7b38&#x27;</span>,</span><br><span class="line">  <span class="attr">pou</span>: <span class="string">&#x27;\u5256\u88d2\u8e23&#x27;</span>,</span><br><span class="line">  <span class="attr">pu</span>:</span><br><span class="line">    <span class="string">&#x27;\u6251\u94fa\u4ec6\u8386\u8461\u83e9\u84b2\u57d4\u6734\u5703\u666e\u6d66\u8c31\u66dd\u7011\u530d\u5657\u6fee\u749e\u6c06\u9564\u9568\u8e7c&#x27;</span>,</span><br><span class="line">  <span class="attr">qi</span>:</span><br><span class="line">    <span class="string">&#x27;\u671f\u6b3a\u6816\u621a\u59bb\u4e03\u51c4\u6f06\u67d2\u6c8f\u5176\u68cb\u5947\u6b67\u7566\u5d0e\u8110\u9f50\u65d7\u7948\u7941\u9a91\u8d77\u5c82\u4e5e\u4f01\u542f\u5951\u780c\u5668\u6c14\u8fc4\u5f03\u6c7d\u6ce3\u8bab\u4e9f\u4e93\u573b\u8291\u840b\u847a\u5601\u5c7a\u5c90\u6c54\u6dc7\u9a90\u7eee\u742a\u7426\u675e\u6864\u69ed\u6b39\u797a\u61a9\u789b\u86f4\u871e\u7da6\u7dae\u8dbf\u8e4a\u9ccd\u9e92&#x27;</span>,</span><br><span class="line">  <span class="attr">qia</span>: <span class="string">&#x27;\u6390\u6070\u6d3d\u845c&#x27;</span>,</span><br><span class="line">  <span class="attr">qian</span>:</span><br><span class="line">    <span class="string">&#x27;\u7275\u6266\u948e\u94c5\u5343\u8fc1\u7b7e\u4edf\u8c26\u4e7e\u9ed4\u94b1\u94b3\u524d\u6f5c\u9063\u6d45\u8c34\u5811\u5d4c\u6b20\u6b49\u4f65\u9621\u828a\u82a1\u8368\u63ae\u5c8d\u60ad\u614a\u9a9e\u6434\u8930\u7f31\u6920\u80b7\u6106\u94a4\u8654\u7b9d&#x27;</span>,</span><br><span class="line">  <span class="attr">qiang</span>:</span><br><span class="line">    <span class="string">&#x27;\u67aa\u545b\u8154\u7f8c\u5899\u8537\u5f3a\u62a2\u5af1\u6a2f\u6217\u709d\u9516\u9535\u956a\u8941\u8723\u7f9f\u8deb\u8dc4&#x27;</span>,</span><br><span class="line">  <span class="attr">qiao</span>:</span><br><span class="line">    <span class="string">&#x27;\u6a47\u9539\u6572\u6084\u6865\u77a7\u4e54\u4fa8\u5de7\u9798\u64ac\u7fd8\u5ced\u4fcf\u7a8d\u5281\u8bee\u8c2f\u835e\u6100\u6194\u7f32\u6a35\u6bf3\u7857\u8df7\u9792&#x27;</span>,</span><br><span class="line">  <span class="attr">qie</span>:</span><br><span class="line">    <span class="string">&#x27;\u5207\u8304\u4e14\u602f\u7a83\u90c4\u553c\u60ec\u59be\u6308\u9532\u7ba7&#x27;</span>,</span><br><span class="line">  <span class="attr">qin</span>:</span><br><span class="line">    <span class="string">&#x27;\u94a6\u4fb5\u4eb2\u79e6\u7434\u52e4\u82b9\u64d2\u79bd\u5bdd\u6c81\u82a9\u84c1\u8572\u63ff\u5423\u55ea\u5659\u6eb1\u6a8e\u8793\u887e&#x27;</span>,</span><br><span class="line">  <span class="attr">qing</span>:</span><br><span class="line">    <span class="string">&#x27;\u9752\u8f7b\u6c22\u503e\u537f\u6e05\u64ce\u6674\u6c30\u60c5\u9877\u8bf7\u5e86\u5029\u82d8\u570a\u6aa0\u78ec\u873b\u7f44\u7b90\u8b26\u9cad\u9ee5&#x27;</span>,</span><br><span class="line">  <span class="attr">qiong</span>: <span class="string">&#x27;\u743c\u7a77\u909b\u8315\u7a79\u7b47\u928e&#x27;</span>,</span><br><span class="line">  <span class="attr">qiu</span>:</span><br><span class="line">    <span class="string">&#x27;\u79cb\u4e18\u90b1\u7403\u6c42\u56da\u914b\u6cc5\u4fc5\u6c3d\u5def\u827d\u72b0\u6e6b\u9011\u9052\u6978\u8d47\u9e20\u866c\u86af\u8764\u88d8\u7cd7\u9cc5\u9f3d&#x27;</span>,</span><br><span class="line">  <span class="attr">qu</span>:</span><br><span class="line">    <span class="string">&#x27;\u8d8b\u533a\u86c6\u66f2\u8eaf\u5c48\u9a71\u6e20\u53d6\u5a36\u9f8b\u8da3\u53bb\u8bce\u52ac\u8556\u8627\u5c96\u8862\u9612\u74a9\u89d1\u6c0d\u795b\u78f2\u766f\u86d0\u883c\u9eb4\u77bf\u9ee2&#x27;</span>,</span><br><span class="line">  <span class="attr">quan</span>:</span><br><span class="line">    <span class="string">&#x27;\u5708\u98a7\u6743\u919b\u6cc9\u5168\u75ca\u62f3\u72ac\u5238\u529d\u8be0\u8343\u737e\u609b\u7efb\u8f81\u754e\u94e8\u8737\u7b4c\u9b08&#x27;</span>,</span><br><span class="line">  <span class="attr">que</span>: <span class="string">&#x27;\u7f3a\u7094\u7638\u5374\u9e4a\u69b7\u786e\u96c0\u9619\u60ab&#x27;</span>,</span><br><span class="line">  <span class="attr">qun</span>: <span class="string">&#x27;\u88d9\u7fa4\u9021&#x27;</span>,</span><br><span class="line">  <span class="attr">ran</span>: <span class="string">&#x27;\u7136\u71c3\u5189\u67d3\u82d2\u9aef&#x27;</span>,</span><br><span class="line">  <span class="attr">rang</span>: <span class="string">&#x27;\u74e4\u58e4\u6518\u56b7\u8ba9\u79b3\u7a70&#x27;</span>,</span><br><span class="line">  <span class="attr">rao</span>: <span class="string">&#x27;\u9976\u6270\u7ed5\u835b\u5a06\u6861&#x27;</span>,</span><br><span class="line">  <span class="attr">ruo</span>: <span class="string">&#x27;\u60f9\u82e5\u5f31&#x27;</span>,</span><br><span class="line">  <span class="attr">re</span>: <span class="string">&#x27;\u70ed\u504c&#x27;</span>,</span><br><span class="line">  <span class="attr">ren</span>:</span><br><span class="line">    <span class="string">&#x27;\u58ec\u4ec1\u4eba\u5fcd\u97e7\u4efb\u8ba4\u5203\u598a\u7eab\u4ede\u834f\u845a\u996a\u8f6b\u7a14\u887d&#x27;</span>,</span><br><span class="line">  <span class="attr">reng</span>: <span class="string">&#x27;\u6254\u4ecd&#x27;</span>,</span><br><span class="line">  <span class="attr">ri</span>: <span class="string">&#x27;\u65e5&#x27;</span>,</span><br><span class="line">  <span class="attr">rong</span>:</span><br><span class="line">    <span class="string">&#x27;\u620e\u8338\u84c9\u8363\u878d\u7194\u6eb6\u5bb9\u7ed2\u5197\u5d58\u72e8\u7f1b\u6995\u877e&#x27;</span>,</span><br><span class="line">  <span class="attr">rou</span>: <span class="string">&#x27;\u63c9\u67d4\u8089\u7cc5\u8e42\u97a3&#x27;</span>,</span><br><span class="line">  <span class="attr">ru</span>:</span><br><span class="line">    <span class="string">&#x27;\u8339\u8815\u5112\u5b7a\u5982\u8fb1\u4e73\u6c5d\u5165\u8925\u84d0\u85b7\u5685\u6d33\u6ebd\u6fe1\u94f7\u8966\u98a5&#x27;</span>,</span><br><span class="line">  <span class="attr">ruan</span>: <span class="string">&#x27;\u8f6f\u962e\u670a&#x27;</span>,</span><br><span class="line">  <span class="attr">rui</span>: <span class="string">&#x27;\u854a\u745e\u9510\u82ae\u8564\u777f\u868b&#x27;</span>,</span><br><span class="line">  <span class="attr">run</span>: <span class="string">&#x27;\u95f0\u6da6&#x27;</span>,</span><br><span class="line">  <span class="attr">sa</span>: <span class="string">&#x27;\u6492\u6d12\u8428\u5345\u4ee8\u6332\u98d2&#x27;</span>,</span><br><span class="line">  <span class="attr">sai</span>: <span class="string">&#x27;\u816e\u9cc3\u585e\u8d5b\u567b&#x27;</span>,</span><br><span class="line">  <span class="attr">san</span>: <span class="string">&#x27;\u4e09\u53c1\u4f1e\u6563\u5f61\u9993\u6c35\u6bf5\u7cc1\u9730&#x27;</span>,</span><br><span class="line">  <span class="attr">sang</span>: <span class="string">&#x27;\u6851\u55d3\u4e27\u6421\u78c9\u98a1&#x27;</span>,</span><br><span class="line">  <span class="attr">sao</span>: <span class="string">&#x27;\u6414\u9a9a\u626b\u5ac2\u57fd\u81ca\u7619\u9ccb&#x27;</span>,</span><br><span class="line">  <span class="attr">se</span>: <span class="string">&#x27;\u745f\u8272\u6da9\u556c\u94e9\u94ef\u7a51&#x27;</span>,</span><br><span class="line">  <span class="attr">sen</span>: <span class="string">&#x27;\u68ee&#x27;</span>,</span><br><span class="line">  <span class="attr">seng</span>: <span class="string">&#x27;\u50e7&#x27;</span>,</span><br><span class="line">  <span class="attr">sha</span>:</span><br><span class="line">    <span class="string">&#x27;\u838e\u7802\u6740\u5239\u6c99\u7eb1\u50bb\u5565\u715e\u810e\u6b43\u75e7\u88df\u970e\u9ca8&#x27;</span>,</span><br><span class="line">  <span class="attr">shai</span>: <span class="string">&#x27;\u7b5b\u6652\u917e&#x27;</span>,</span><br><span class="line">  <span class="attr">shan</span>:</span><br><span class="line">    <span class="string">&#x27;\u73ca\u82eb\u6749\u5c71\u5220\u717d\u886b\u95ea\u9655\u64c5\u8d61\u81b3\u5584\u6c55\u6247\u7f2e\u5261\u8baa\u912f\u57cf\u829f\u6f78\u59d7\u9a9f\u81bb\u9490\u759d\u87ee\u8222\u8dda\u9cdd&#x27;</span>,</span><br><span class="line">  <span class="attr">shang</span>:</span><br><span class="line">    <span class="string">&#x27;\u5892\u4f24\u5546\u8d4f\u664c\u4e0a\u5c1a\u88f3\u57a7\u7ef1\u6b87\u71b5\u89de&#x27;</span>,</span><br><span class="line">  <span class="attr">shao</span>:</span><br><span class="line">    <span class="string">&#x27;\u68a2\u634e\u7a0d\u70e7\u828d\u52fa\u97f6\u5c11\u54e8\u90b5\u7ecd\u52ad\u82d5\u6f72\u86f8\u7b24\u7b72\u8244&#x27;</span>,</span><br><span class="line">  <span class="attr">she</span>:</span><br><span class="line">    <span class="string">&#x27;\u5962\u8d4a\u86c7\u820c\u820d\u8d66\u6444\u5c04\u6151\u6d89\u793e\u8bbe\u538d\u4f58\u731e\u7572\u9e9d&#x27;</span>,</span><br><span class="line">  <span class="attr">shen</span>:</span><br><span class="line">    <span class="string">&#x27;\u7837\u7533\u547b\u4f38\u8eab\u6df1\u5a20\u7ec5\u795e\u6c88\u5ba1\u5a76\u751a\u80be\u614e\u6e17\u8bdc\u8c02\u5432\u54c2\u6e16\u6939\u77e7\u8703&#x27;</span>,</span><br><span class="line">  <span class="attr">sheng</span>:</span><br><span class="line">    <span class="string">&#x27;\u58f0\u751f\u7525\u7272\u5347\u7ef3\u7701\u76db\u5269\u80dc\u5723\u4e1e\u6e11\u5ab5\u771a\u7b19&#x27;</span>,</span><br><span class="line">  <span class="attr">shi</span>:</span><br><span class="line">    <span class="string">&#x27;\u5e08\u5931\u72ee\u65bd\u6e7f\u8bd7\u5c38\u8671\u5341\u77f3\u62fe\u65f6\u4ec0\u98df\u8680\u5b9e\u8bc6\u53f2\u77e2\u4f7f\u5c4e\u9a76\u59cb\u5f0f\u793a\u58eb\u4e16\u67ff\u4e8b\u62ed\u8a93\u901d\u52bf\u662f\u55dc\u566c\u9002\u4ed5\u4f8d\u91ca\u9970\u6c0f\u5e02\u6043\u5ba4\u89c6\u8bd5\u8c25\u57d8\u83b3\u84cd\u5f11\u5511\u9963\u8f7c\u8006\u8d33\u70bb\u793b\u94c8\u94ca\u87ab\u8210\u7b6e\u8c55\u9ca5\u9cba&#x27;</span>,</span><br><span class="line">  <span class="attr">shou</span>:</span><br><span class="line">    <span class="string">&#x27;\u6536\u624b\u9996\u5b88\u5bff\u6388\u552e\u53d7\u7626\u517d\u624c\u72e9\u7ef6\u824f&#x27;</span>,</span><br><span class="line">  <span class="attr">shu</span>:</span><br><span class="line">    <span class="string">&#x27;\u852c\u67a2\u68b3\u6b8a\u6292\u8f93\u53d4\u8212\u6dd1\u758f\u4e66\u8d4e\u5b70\u719f\u85af\u6691\u66d9\u7f72\u8700\u9ecd\u9f20\u5c5e\u672f\u8ff0\u6811\u675f\u620d\u7ad6\u5885\u5eb6\u6570\u6f31\u6055\u500f\u587e\u83fd\u5fc4\u6cad\u6d91\u6f8d\u59dd\u7ebe\u6bf9\u8167\u6bb3\u956f\u79eb\u9e6c&#x27;</span>,</span><br><span class="line">  <span class="attr">shua</span>: <span class="string">&#x27;\u5237\u800d\u5530\u6dae&#x27;</span>,</span><br><span class="line">  <span class="attr">shuai</span>: <span class="string">&#x27;\u6454\u8870\u7529\u5e05\u87c0&#x27;</span>,</span><br><span class="line">  <span class="attr">shuan</span>: <span class="string">&#x27;\u6813\u62f4\u95e9&#x27;</span>,</span><br><span class="line">  <span class="attr">shuang</span>: <span class="string">&#x27;\u971c\u53cc\u723d\u5b40&#x27;</span>,</span><br><span class="line">  <span class="attr">shui</span>: <span class="string">&#x27;\u8c01\u6c34\u7761\u7a0e&#x27;</span>,</span><br><span class="line">  <span class="attr">shun</span>: <span class="string">&#x27;\u542e\u77ac\u987a\u821c\u6042&#x27;</span>,</span><br><span class="line">  <span class="attr">shuo</span>: <span class="string">&#x27;\u8bf4\u7855\u6714\u70c1\u84b4\u6420\u55cd\u6fef\u5981\u69ca\u94c4&#x27;</span>,</span><br><span class="line">  <span class="attr">si</span>:</span><br><span class="line">    <span class="string">&#x27;\u65af\u6495\u5636\u601d\u79c1\u53f8\u4e1d\u6b7b\u8086\u5bfa\u55e3\u56db\u4f3a\u4f3c\u9972\u5df3\u53ae\u4fdf\u5155\u83e5\u549d\u6c5c\u6cd7\u6f8c\u59d2\u9a77\u7f0c\u7940\u7960\u9536\u9e36\u801c\u86f3\u7b25&#x27;</span>,</span><br><span class="line">  <span class="attr">song</span>:</span><br><span class="line">    <span class="string">&#x27;\u677e\u8038\u6002\u9882\u9001\u5b8b\u8bbc\u8bf5\u51c7\u83d8\u5d27\u5d69\u5fea\u609a\u6dde\u7ae6&#x27;</span>,</span><br><span class="line">  <span class="attr">sou</span>:</span><br><span class="line">    <span class="string">&#x27;\u641c\u8258\u64de\u55fd\u53df\u55d6\u55fe\u998a\u6eb2\u98d5\u778d\u953c\u878b&#x27;</span>,</span><br><span class="line">  <span class="attr">su</span>:</span><br><span class="line">    <span class="string">&#x27;\u82cf\u9165\u4fd7\u7d20\u901f\u7c9f\u50f3\u5851\u6eaf\u5bbf\u8bc9\u8083\u5919\u8c21\u850c\u55c9\u612b\u7c0c\u89eb\u7a23&#x27;</span>,</span><br><span class="line">  <span class="attr">suan</span>: <span class="string">&#x27;\u9178\u849c\u7b97&#x27;</span>,</span><br><span class="line">  <span class="attr">sui</span>:</span><br><span class="line">    <span class="string">&#x27;\u867d\u968b\u968f\u7ee5\u9ad3\u788e\u5c81\u7a57\u9042\u96a7\u795f\u84d1\u51ab\u8c07\u6fc9\u9083\u71e7\u772d\u7762&#x27;</span>,</span><br><span class="line">  <span class="attr">sun</span>: <span class="string">&#x27;\u5b59\u635f\u7b0b\u836a\u72f2\u98e7\u69ab\u8de3\u96bc&#x27;</span>,</span><br><span class="line">  <span class="attr">suo</span>:</span><br><span class="line">    <span class="string">&#x27;\u68ad\u5506\u7f29\u7410\u7d22\u9501\u6240\u5522\u55e6\u5a11\u686b\u7743\u7fa7&#x27;</span>,</span><br><span class="line">  <span class="attr">ta</span>:</span><br><span class="line">    <span class="string">&#x27;\u584c\u4ed6\u5b83\u5979\u5854\u736d\u631e\u8e4b\u8e0f\u95fc\u6ebb\u9062\u69bb\u6c93&#x27;</span>,</span><br><span class="line">  <span class="attr">tai</span>:</span><br><span class="line">    <span class="string">&#x27;\u80ce\u82d4\u62ac\u53f0\u6cf0\u915e\u592a\u6001\u6c70\u90b0\u85b9\u80bd\u70b1\u949b\u8dc6\u9c90&#x27;</span>,</span><br><span class="line">  <span class="attr">tan</span>:</span><br><span class="line">    <span class="string">&#x27;\u574d\u644a\u8d2a\u762b\u6ee9\u575b\u6a80\u75f0\u6f6d\u8c2d\u8c08\u5766\u6bef\u8892\u78b3\u63a2\u53f9\u70ad\u90ef\u8548\u6619\u94bd\u952c\u8983&#x27;</span>,</span><br><span class="line">  <span class="attr">tang</span>:</span><br><span class="line">    <span class="string">&#x27;\u6c64\u5858\u642a\u5802\u68e0\u819b\u5510\u7cd6\u50a5\u9967\u6e8f\u746d\u94f4\u9557\u8025\u8797\u87b3\u7fb0\u91a3&#x27;</span>,</span><br><span class="line">  <span class="attr">thang</span>: <span class="string">&#x27;\u5018\u8eba\u6dcc&#x27;</span>,</span><br><span class="line">  <span class="attr">theng</span>: <span class="string">&#x27;\u8d9f\u70eb&#x27;</span>,</span><br><span class="line">  <span class="attr">tao</span>:</span><br><span class="line">    <span class="string">&#x27;\u638f\u6d9b\u6ed4\u7ee6\u8404\u6843\u9003\u6dd8\u9676\u8ba8\u5957\u6311\u9f17\u5555\u97ec\u9955&#x27;</span>,</span><br><span class="line">  <span class="attr">te</span>: <span class="string">&#x27;\u7279&#x27;</span>,</span><br><span class="line">  <span class="attr">teng</span>: <span class="string">&#x27;\u85e4\u817e\u75bc\u8a8a\u6ed5&#x27;</span>,</span><br><span class="line">  <span class="attr">ti</span>:</span><br><span class="line">    <span class="string">&#x27;\u68af\u5254\u8e22\u9511\u63d0\u9898\u8e44\u557c\u4f53\u66ff\u568f\u60d5\u6d95\u5243\u5c49\u8351\u608c\u9016\u7ee8\u7f07\u9e48\u88fc\u918d&#x27;</span>,</span><br><span class="line">  <span class="attr">tian</span>:</span><br><span class="line">    <span class="string">&#x27;\u5929\u6dfb\u586b\u7530\u751c\u606c\u8214\u8146\u63ad\u5fdd\u9617\u6b84\u754b\u94bf\u86ba&#x27;</span>,</span><br><span class="line">  <span class="attr">tiao</span>: <span class="string">&#x27;\u6761\u8fe2\u773a\u8df3\u4f7b\u7967\u94eb\u7a95\u9f86\u9ca6&#x27;</span>,</span><br><span class="line">  <span class="attr">tie</span>: <span class="string">&#x27;\u8d34\u94c1\u5e16\u841c\u992e&#x27;</span>,</span><br><span class="line">  <span class="attr">ting</span>:</span><br><span class="line">    <span class="string">&#x27;\u5385\u542c\u70c3\u6c40\u5ef7\u505c\u4ead\u5ead\u633a\u8247\u839b\u8476\u5a77\u6883\u8713\u9706&#x27;</span>,</span><br><span class="line">  <span class="attr">tong</span>:</span><br><span class="line">    <span class="string">&#x27;\u901a\u6850\u916e\u77b3\u540c\u94dc\u5f64\u7ae5\u6876\u6345\u7b52\u7edf\u75db\u4f5f\u50ee\u4edd\u833c\u55f5\u6078\u6f7c\u783c&#x27;</span>,</span><br><span class="line">  <span class="attr">tou</span>: <span class="string">&#x27;\u5077\u6295\u5934\u900f\u4ea0&#x27;</span>,</span><br><span class="line">  <span class="attr">tu</span>:</span><br><span class="line">    <span class="string">&#x27;\u51f8\u79c3\u7a81\u56fe\u5f92\u9014\u6d82\u5c60\u571f\u5410\u5154\u580d\u837c\u83df\u948d\u9174&#x27;</span>,</span><br><span class="line">  <span class="attr">tuan</span>: <span class="string">&#x27;\u6e4d\u56e2\u7583&#x27;</span>,</span><br><span class="line">  <span class="attr">tui</span>: <span class="string">&#x27;\u63a8\u9893\u817f\u8715\u892a\u9000\u5fd2\u717a&#x27;</span>,</span><br><span class="line">  <span class="attr">tun</span>: <span class="string">&#x27;\u541e\u5c6f\u81c0\u9968\u66be\u8c5a\u7a80&#x27;</span>,</span><br><span class="line">  <span class="attr">tuo</span>:</span><br><span class="line">    <span class="string">&#x27;\u62d6\u6258\u8131\u9e35\u9640\u9a6e\u9a7c\u692d\u59a5\u62d3\u553e\u4e47\u4f57\u5768\u5eb9\u6cb1\u67dd\u7823\u7ba8\u8204\u8dce\u9f0d&#x27;</span>,</span><br><span class="line">  <span class="attr">wa</span>: <span class="string">&#x27;\u6316\u54c7\u86d9\u6d3c\u5a03\u74e6\u889c\u4f64\u5a32\u817d&#x27;</span>,</span><br><span class="line">  <span class="attr">wai</span>: <span class="string">&#x27;\u6b6a\u5916&#x27;</span>,</span><br><span class="line">  <span class="attr">wan</span>:</span><br><span class="line">    <span class="string">&#x27;\u8c4c\u5f2f\u6e7e\u73a9\u987d\u4e38\u70f7\u5b8c\u7897\u633d\u665a\u7696\u60cb\u5b9b\u5a49\u4e07\u8155\u525c\u8284\u82cb\u83c0\u7ea8\u7efe\u742c\u8118\u7579\u873f\u7ba2&#x27;</span>,</span><br><span class="line">  <span class="attr">wang</span>:</span><br><span class="line">    <span class="string">&#x27;\u6c6a\u738b\u4ea1\u6789\u7f51\u5f80\u65fa\u671b\u5fd8\u5984\u7f54\u5c22\u60d8\u8f8b\u9b4d&#x27;</span>,</span><br><span class="line">  <span class="attr">wei</span>:</span><br><span class="line">    <span class="string">&#x27;\u5a01\u5dcd\u5fae\u5371\u97e6\u8fdd\u6845\u56f4\u552f\u60df\u4e3a\u6f4d\u7ef4\u82c7\u840e\u59d4\u4f1f\u4f2a\u5c3e\u7eac\u672a\u851a\u5473\u754f\u80c3\u5582\u9b4f\u4f4d\u6e2d\u8c13\u5c09\u6170\u536b\u502d\u504e\u8bff\u9688\u8473\u8587\u5e0f\u5e37\u5d34\u5d6c\u7325\u732c\u95f1\u6ca9\u6d27\u6da0\u9036\u5a13\u73ae\u97ea\u8ece\u709c\u7168\u71a8\u75ff\u8249\u9c94&#x27;</span>,</span><br><span class="line">  <span class="attr">wen</span>:</span><br><span class="line">    <span class="string">&#x27;\u761f\u6e29\u868a\u6587\u95fb\u7eb9\u543b\u7a33\u7d0a\u95ee\u520e\u6120\u960c\u6c76\u74ba\u97eb\u6b81\u96ef&#x27;</span>,</span><br><span class="line">  <span class="attr">weng</span>: <span class="string">&#x27;\u55e1\u7fc1\u74ee\u84ca\u8579&#x27;</span>,</span><br><span class="line">  <span class="attr">wo</span>:</span><br><span class="line">    <span class="string">&#x27;\u631d\u8717\u6da1\u7a9d\u6211\u65a1\u5367\u63e1\u6c83\u83b4\u5e44\u6e25\u674c\u809f\u9f8c&#x27;</span>,</span><br><span class="line">  <span class="attr">wu</span>:</span><br><span class="line">    <span class="string">&#x27;\u5deb\u545c\u94a8\u4e4c\u6c61\u8bec\u5c4b\u65e0\u829c\u68a7\u543e\u5434\u6bcb\u6b66\u4e94\u6342\u5348\u821e\u4f0d\u4fae\u575e\u620a\u96fe\u6664\u7269\u52ff\u52a1\u609f\u8bef\u5140\u4ef5\u9622\u90ac\u572c\u82b4\u5e91\u6003\u5fe4\u6d6f\u5be4\u8fd5\u59a9\u9a9b\u727e\u7110\u9e49\u9e5c\u8708\u92c8\u9f2f&#x27;</span>,</span><br><span class="line">  <span class="attr">xi</span>:</span><br><span class="line">    <span class="string">&#x27;\u6614\u7199\u6790\u897f\u7852\u77fd\u6670\u563b\u5438\u9521\u727a\u7a00\u606f\u5e0c\u6089\u819d\u5915\u60dc\u7184\u70ef\u6eaa\u6c50\u7280\u6a84\u88ad\u5e2d\u4e60\u5ab3\u559c\u94e3\u6d17\u7cfb\u9699\u620f\u7ec6\u50d6\u516e\u96b0\u90d7\u831c\u8478\u84f0\u595a\u550f\u5f99\u9969\u960b\u6d60\u6dc5\u5c63\u5b09\u73ba\u6a28\u66e6\u89cb\u6b37\u71b9\u798a\u79a7\u94b8\u7699\u7a78\u8725\u87cb\u823e\u7fb2\u7c9e\u7fd5\u91af\u9f37&#x27;</span>,</span><br><span class="line">  <span class="attr">xia</span>:</span><br><span class="line">    <span class="string">&#x27;\u778e\u867e\u5323\u971e\u8f96\u6687\u5ce1\u4fa0\u72ed\u4e0b\u53a6\u590f\u5413\u6380\u846d\u55c4\u72ce\u9050\u7455\u7856\u7615\u7f45\u9ee0&#x27;</span>,</span><br><span class="line">  <span class="attr">xian</span>:</span><br><span class="line">    <span class="string">&#x27;\u9528\u5148\u4ed9\u9c9c\u7ea4\u54b8\u8d24\u8854\u8237\u95f2\u6d8e\u5f26\u5acc\u663e\u9669\u73b0\u732e\u53bf\u817a\u9985\u7fa1\u5baa\u9677\u9650\u7ebf\u51bc\u85d3\u5c98\u7303\u66b9\u5a34\u6c19\u7946\u9e47\u75eb\u86ac\u7b45\u7c7c\u9170\u8df9&#x27;</span>,</span><br><span class="line">  <span class="attr">xiang</span>:</span><br><span class="line">    <span class="string">&#x27;\u76f8\u53a2\u9576\u9999\u7bb1\u8944\u6e58\u4e61\u7fd4\u7965\u8be6\u60f3\u54cd\u4eab\u9879\u5df7\u6a61\u50cf\u5411\u8c61\u8297\u8459\u9977\u5ea0\u9aa7\u7f03\u87d3\u9c9e\u98e8&#x27;</span>,</span><br><span class="line">  <span class="attr">xiao</span>:</span><br><span class="line">    <span class="string">&#x27;\u8427\u785d\u9704\u524a\u54ee\u56a3\u9500\u6d88\u5bb5\u6dc6\u6653\u5c0f\u5b5d\u6821\u8096\u5578\u7b11\u6548\u54d3\u54bb\u5d24\u6f47\u900d\u9a81\u7ee1\u67ad\u67b5\u7b71\u7bab\u9b48&#x27;</span>,</span><br><span class="line">  <span class="attr">xie</span>:</span><br><span class="line">    <span class="string">&#x27;\u6954\u4e9b\u6b47\u874e\u978b\u534f\u631f\u643a\u90aa\u659c\u80c1\u8c10\u5199\u68b0\u5378\u87f9\u61c8\u6cc4\u6cfb\u8c22\u5c51\u5055\u4eb5\u52f0\u71ee\u85a4\u64b7\u5ee8\u7023\u9082\u7ec1\u7f2c\u69ad\u698d\u6b59\u8e9e&#x27;</span>,</span><br><span class="line">  <span class="attr">xin</span>:</span><br><span class="line">    <span class="string">&#x27;\u85aa\u82af\u950c\u6b23\u8f9b\u65b0\u5ffb\u5fc3\u4fe1\u8845\u56df\u99a8\u8398\u6b46\u94fd\u946b&#x27;</span>,</span><br><span class="line">  <span class="attr">xing</span>:</span><br><span class="line">    <span class="string">&#x27;\u661f\u8165\u7329\u60fa\u5174\u5211\u578b\u5f62\u90a2\u884c\u9192\u5e78\u674f\u6027\u59d3\u9649\u8347\u8365\u64e4\u60bb\u784e&#x27;</span>,</span><br><span class="line">  <span class="attr">xiong</span>: <span class="string">&#x27;\u5144\u51f6\u80f8\u5308\u6c79\u96c4\u718a\u828e&#x27;</span>,</span><br><span class="line">  <span class="attr">xiu</span>:</span><br><span class="line">    <span class="string">&#x27;\u4f11\u4fee\u7f9e\u673d\u55c5\u9508\u79c0\u8896\u7ee3\u83a0\u5cab\u9990\u5ea5\u9e3a\u8c85\u9af9&#x27;</span>,</span><br><span class="line">  <span class="attr">xu</span>:</span><br><span class="line">    <span class="string">&#x27;\u589f\u620c\u9700\u865a\u5618\u987b\u5f90\u8bb8\u84c4\u9157\u53d9\u65ed\u5e8f\u755c\u6064\u7d6e\u5a7f\u7eea\u7eed\u8bb4\u8be9\u5729\u84ff\u6035\u6d2b\u6e86\u987c\u6829\u7166\u7809\u76f1\u80e5\u7cc8\u9191&#x27;</span>,</span><br><span class="line">  <span class="attr">xuan</span>:</span><br><span class="line">    <span class="string">&#x27;\u8f69\u55a7\u5ba3\u60ac\u65cb\u7384\u9009\u7663\u7729\u7eda\u5107\u8c16\u8431\u63ce\u9994\u6ceb\u6d35\u6e32\u6f29\u7487\u6966\u6684\u70ab\u714a\u78b9\u94c9\u955f\u75c3&#x27;</span>,</span><br><span class="line">  <span class="attr">xue</span>: <span class="string">&#x27;\u9774\u859b\u5b66\u7a74\u96ea\u8840\u5671\u6cf6\u9cd5&#x27;</span>,</span><br><span class="line">  <span class="attr">xun</span>:</span><br><span class="line">    <span class="string">&#x27;\u52cb\u718f\u5faa\u65ec\u8be2\u5bfb\u9a6f\u5de1\u6b89\u6c5b\u8bad\u8baf\u900a\u8fc5\u5dfd\u57d9\u8340\u85b0\u5ccb\u5f87\u6d54\u66db\u7aa8\u91ba\u9c9f&#x27;</span>,</span><br><span class="line">  <span class="attr">ya</span>:</span><br><span class="line">    <span class="string">&#x27;\u538b\u62bc\u9e26\u9e2d\u5440\u4e2b\u82bd\u7259\u869c\u5d16\u8859\u6daf\u96c5\u54d1\u4e9a\u8bb6\u4f22\u63e0\u5416\u5c88\u8fd3\u5a05\u740a\u6860\u6c29\u7811\u775a\u75d6&#x27;</span>,</span><br><span class="line">  <span class="attr">yan</span>:</span><br><span class="line">    <span class="string">&#x27;\u7109\u54bd\u9609\u70df\u6df9\u76d0\u4e25\u7814\u8712\u5ca9\u5ef6\u8a00\u989c\u960e\u708e\u6cbf\u5944\u63a9\u773c\u884d\u6f14\u8273\u5830\u71d5\u538c\u781a\u96c1\u5501\u5f66\u7130\u5bb4\u8c1a\u9a8c\u53a3\u9765\u8d5d\u4fe8\u5043\u5156\u8ba0\u8c33\u90fe\u9122\u82ab\u83f8\u5d26\u6079\u95eb\u960f\u6d07\u6e6e\u6edf\u598d\u5ae3\u7430\u664f\u80ed\u814c\u7131\u7f68\u7b75\u917d\u9b47\u990d\u9f39&#x27;</span>,</span><br><span class="line">  <span class="attr">yang</span>:</span><br><span class="line">    <span class="string">&#x27;\u6b83\u592e\u9e2f\u79e7\u6768\u626c\u4f6f\u75a1\u7f8a\u6d0b\u9633\u6c27\u4ef0\u75d2\u517b\u6837\u6f3e\u5f89\u600f\u6cf1\u7080\u70ca\u6059\u86d8\u9785&#x27;</span>,</span><br><span class="line">  <span class="attr">yao</span>:</span><br><span class="line">    <span class="string">&#x27;\u9080\u8170\u5996\u7476\u6447\u5c27\u9065\u7a91\u8c23\u59da\u54ac\u8200\u836f\u8981\u8000\u592d\u723b\u5406\u5d3e\u5fad\u7039\u5e7a\u73e7\u6773\u66dc\u80b4\u9e5e\u7a88\u7e47\u9cd0&#x27;</span>,</span><br><span class="line">  <span class="attr">ye</span>:</span><br><span class="line">    <span class="string">&#x27;\u6930\u564e\u8036\u7237\u91ce\u51b6\u4e5f\u9875\u6396\u4e1a\u53f6\u66f3\u814b\u591c\u6db2\u8c12\u90ba\u63f6\u9980\u6654\u70e8\u94d8&#x27;</span>,</span><br><span class="line">  <span class="attr">yi</span>:</span><br><span class="line">    <span class="string">&#x27;\u4e00\u58f9\u533b\u63d6\u94f1\u4f9d\u4f0a\u8863\u9890\u5937\u9057\u79fb\u4eea\u80f0\u7591\u6c82\u5b9c\u59e8\u5f5d\u6905\u8681\u501a\u5df2\u4e59\u77e3\u4ee5\u827a\u6291\u6613\u9091\u5c79\u4ebf\u5f79\u81c6\u9038\u8084\u75ab\u4ea6\u88d4\u610f\u6bc5\u5fc6\u4e49\u76ca\u6ea2\u8be3\u8bae\u8c0a\u8bd1\u5f02\u7ffc\u7fcc\u7ece\u5208\u5293\u4f7e\u8bd2\u572a\u572f\u57f8\u61ff\u82e1\u858f\u5f08\u5955\u6339\u5f0b\u5453\u54a6\u54bf\u566b\u5cc4\u5db7\u7317\u9974\u603f\u6021\u6092\u6f2a\u8fe4\u9a7f\u7f22\u6baa\u8d3b\u65d6\u71a0\u9487\u9552\u9571\u75cd\u7617\u7654\u7fca\u8864\u8734\u8223\u7fbf\u7ff3\u914f\u9edf&#x27;</span>,</span><br><span class="line">  <span class="attr">yin</span>:</span><br><span class="line">    <span class="string">&#x27;\u8335\u836b\u56e0\u6bb7\u97f3\u9634\u59fb\u541f\u94f6\u6deb\u5bc5\u996e\u5c39\u5f15\u9690\u5370\u80e4\u911e\u5819\u831a\u5591\u72fa\u5924\u6c24\u94df\u763e\u8693\u972a\u9f88&#x27;</span>,</span><br><span class="line">  <span class="attr">ying</span>:</span><br><span class="line">    <span class="string">&#x27;\u82f1\u6a31\u5a74\u9e70\u5e94\u7f28\u83b9\u8424\u8425\u8367\u8747\u8fce\u8d62\u76c8\u5f71\u9896\u786c\u6620\u5b34\u90e2\u8314\u83ba\u8426\u6484\u5624\u81ba\u6ee2\u6f46\u701b\u745b\u748e\u6979\u9e66\u763f\u988d\u7f42&#x27;</span>,</span><br><span class="line">  <span class="attr">yo</span>: <span class="string">&#x27;\u54df\u5537&#x27;</span>,</span><br><span class="line">  <span class="attr">yong</span>:</span><br><span class="line">    <span class="string">&#x27;\u62e5\u4f63\u81c3\u75c8\u5eb8\u96cd\u8e0a\u86f9\u548f\u6cf3\u6d8c\u6c38\u607f\u52c7\u7528\u4fd1\u58c5\u5889\u6175\u9095\u955b\u752c\u9cd9\u9954&#x27;</span>,</span><br><span class="line">  <span class="attr">you</span>:</span><br><span class="line">    <span class="string">&#x27;\u5e7d\u4f18\u60a0\u5fe7\u5c24\u7531\u90ae\u94c0\u72b9\u6cb9\u6e38\u9149\u6709\u53cb\u53f3\u4f51\u91c9\u8bf1\u53c8\u5e7c\u5363\u6538\u4f91\u83b8\u5466\u56ff\u5ba5\u67da\u7337\u7256\u94d5\u75a3\u8763\u9c7f\u9edd\u9f2c&#x27;</span>,</span><br><span class="line">  <span class="attr">yu</span>:</span><br><span class="line">    <span class="string">&#x27;\u8fc2\u6de4\u4e8e\u76c2\u6986\u865e\u611a\u8206\u4f59\u4fde\u903e\u9c7c\u6109\u6e1d\u6e14\u9685\u4e88\u5a31\u96e8\u4e0e\u5c7f\u79b9\u5b87\u8bed\u7fbd\u7389\u57df\u828b\u90c1\u5401\u9047\u55bb\u5cea\u5fa1\u6108\u6b32\u72f1\u80b2\u8a89\u6d74\u5bd3\u88d5\u9884\u8c6b\u9a6d\u79ba\u6bd3\u4f1b\u4fe3\u8c00\u8c15\u8438\u84e3\u63c4\u5581\u5704\u5709\u5d5b\u72f3\u996b\u5ebe\u9608\u59aa\u59a4\u7ea1\u745c\u6631\u89ce\u8174\u6b24\u65bc\u715c\u71e0\u807f\u94b0\u9e46\u7610\u7600\u7ab3\u8753\u7afd\u8201\u96e9\u9f89&#x27;</span>,</span><br><span class="line">  <span class="attr">yuan</span>:</span><br><span class="line">    <span class="string">&#x27;\u9e33\u6e0a\u51a4\u5143\u57a3\u8881\u539f\u63f4\u8f95\u56ed\u5458\u5706\u733f\u6e90\u7f18\u8fdc\u82d1\u613f\u6028\u9662\u586c\u6c85\u5a9b\u7457\u6a7c\u7230\u7722\u9e22\u8788\u9f0b&#x27;</span>,</span><br><span class="line">  <span class="attr">yue</span>:</span><br><span class="line">    <span class="string">&#x27;\u66f0\u7ea6\u8d8a\u8dc3\u94a5\u5cb3\u7ca4\u6708\u60a6\u9605\u9fa0\u6a3e\u5216\u94ba&#x27;</span>,</span><br><span class="line">  <span class="attr">yun</span>:</span><br><span class="line">    <span class="string">&#x27;\u8018\u4e91\u90e7\u5300\u9668\u5141\u8fd0\u8574\u915d\u6655\u97f5\u5b55\u90d3\u82b8\u72c1\u607d\u7ead\u6b92\u6600\u6c32&#x27;</span>,</span><br><span class="line">  <span class="attr">za</span>: <span class="string">&#x27;\u531d\u7838\u6742\u62f6\u5482&#x27;</span>,</span><br><span class="line">  <span class="attr">zai</span>: <span class="string">&#x27;\u683d\u54c9\u707e\u5bb0\u8f7d\u518d\u5728\u54b1\u5d3d\u753e&#x27;</span>,</span><br><span class="line">  <span class="attr">zan</span>: <span class="string">&#x27;\u6512\u6682\u8d5e\u74d2\u661d\u7c2a\u7ccc\u8db1\u933e&#x27;</span>,</span><br><span class="line">  <span class="attr">zang</span>: <span class="string">&#x27;\u8d43\u810f\u846c\u5958\u6215\u81e7&#x27;</span>,</span><br><span class="line">  <span class="attr">zao</span>:</span><br><span class="line">    <span class="string">&#x27;\u906d\u7cdf\u51ff\u85fb\u67a3\u65e9\u6fa1\u86a4\u8e81\u566a\u9020\u7682\u7076\u71e5\u5523\u7f2b&#x27;</span>,</span><br><span class="line">  <span class="attr">ze</span>:</span><br><span class="line">    <span class="string">&#x27;\u8d23\u62e9\u5219\u6cfd\u4ec4\u8d5c\u5567\u8fee\u6603\u7b2e\u7ba6\u8234&#x27;</span>,</span><br><span class="line">  <span class="attr">zei</span>: <span class="string">&#x27;\u8d3c&#x27;</span>,</span><br><span class="line">  <span class="attr">zen</span>: <span class="string">&#x27;\u600e\u8c2e&#x27;</span>,</span><br><span class="line">  <span class="attr">zeng</span>: <span class="string">&#x27;\u589e\u618e\u66fe\u8d60\u7f2f\u7511\u7f7e\u9503&#x27;</span>,</span><br><span class="line">  <span class="attr">zha</span>:</span><br><span class="line">    <span class="string">&#x27;\u624e\u55b3\u6e23\u672d\u8f67\u94e1\u95f8\u7728\u6805\u69a8\u548b\u4e4d\u70b8\u8bc8\u63f8\u5412\u54a4\u54f3\u600d\u781f\u75c4\u86b1\u9f44&#x27;</span>,</span><br><span class="line">  <span class="attr">zhai</span>: <span class="string">&#x27;\u6458\u658b\u5b85\u7a84\u503a\u5be8\u7826&#x27;</span>,</span><br><span class="line">  <span class="attr">zhan</span>:</span><br><span class="line">    <span class="string">&#x27;\u77bb\u6be1\u8a79\u7c98\u6cbe\u76cf\u65a9\u8f97\u5d2d\u5c55\u8638\u6808\u5360\u6218\u7ad9\u6e5b\u7efd\u8c35\u640c\u65c3&#x27;</span>,</span><br><span class="line">  <span class="attr">zhang</span>:</span><br><span class="line">    <span class="string">&#x27;\u6a1f\u7ae0\u5f70\u6f33\u5f20\u638c\u6da8\u6756\u4e08\u5e10\u8d26\u4ed7\u80c0\u7634\u969c\u4ec9\u9123\u5e5b\u5d82\u7350\u5adc\u748b\u87d1&#x27;</span>,</span><br><span class="line">  <span class="attr">zhao</span>:</span><br><span class="line">    <span class="string">&#x27;\u62db\u662d\u627e\u6cbc\u8d75\u7167\u7f69\u5146\u8087\u53ec\u722a\u8bcf\u68f9\u948a\u7b0a&#x27;</span>,</span><br><span class="line">  <span class="attr">zhe</span>:</span><br><span class="line">    <span class="string">&#x27;\u906e\u6298\u54f2\u86f0\u8f99\u8005\u9517\u8517\u8fd9\u6d59\u8c2a\u966c\u67d8\u8f84\u78d4\u9e67\u891a\u8707\u8d6d&#x27;</span>,</span><br><span class="line">  <span class="attr">zhen</span>:</span><br><span class="line">    <span class="string">&#x27;\u73cd\u659f\u771f\u7504\u7827\u81fb\u8d1e\u9488\u4fa6\u6795\u75b9\u8bca\u9707\u632f\u9547\u9635\u7f1c\u6862\u699b\u8f78\u8d48\u80d7\u6715\u796f\u755b\u9e29&#x27;</span>,</span><br><span class="line">  <span class="attr">zheng</span>:</span><br><span class="line">    <span class="string">&#x27;\u84b8\u6323\u7741\u5f81\u72f0\u4e89\u6014\u6574\u62ef\u6b63\u653f\u5e27\u75c7\u90d1\u8bc1\u8be4\u5ce5\u94b2\u94ee\u7b5d&#x27;</span>,</span><br><span class="line">  <span class="attr">zhi</span>:</span><br><span class="line">    <span class="string">&#x27;\u829d\u679d\u652f\u5431\u8718\u77e5\u80a2\u8102\u6c41\u4e4b\u7ec7\u804c\u76f4\u690d\u6b96\u6267\u503c\u4f84\u5740\u6307\u6b62\u8dbe\u53ea\u65e8\u7eb8\u5fd7\u631a\u63b7\u81f3\u81f4\u7f6e\u5e1c\u5cd9\u5236\u667a\u79e9\u7a1a\u8d28\u7099\u75d4\u6ede\u6cbb\u7a92\u536e\u965f\u90c5\u57f4\u82b7\u646d\u5e19\u5fee\u5f58\u54ab\u9a98\u6809\u67b3\u6800\u684e\u8f75\u8f7e\u6534\u8d3d\u81a3\u7949\u7957\u9ef9\u96c9\u9e37\u75e3\u86ed\u7d77\u916f\u8dd6\u8e2c\u8e2f\u8c78\u89ef&#x27;</span>,</span><br><span class="line">  <span class="attr">zhong</span>:</span><br><span class="line">    <span class="string">&#x27;\u4e2d\u76c5\u5fe0\u949f\u8877\u7ec8\u79cd\u80bf\u91cd\u4ef2\u4f17\u51a2\u953a\u87bd\u8202\u822f\u8e35&#x27;</span>,</span><br><span class="line">  <span class="attr">zhou</span>:</span><br><span class="line">    <span class="string">&#x27;\u821f\u5468\u5dde\u6d32\u8bcc\u7ca5\u8f74\u8098\u5e1a\u5492\u76b1\u5b99\u663c\u9aa4\u5544\u7740\u501c\u8bf9\u836e\u9b3b\u7ea3\u80c4\u78a1\u7c40\u8233\u914e\u9cb7&#x27;</span>,</span><br><span class="line">  <span class="attr">zhu</span>:</span><br><span class="line">    <span class="string">&#x27;\u73e0\u682a\u86db\u6731\u732a\u8bf8\u8bdb\u9010\u7af9\u70db\u716e\u62c4\u77a9\u5631\u4e3b\u8457\u67f1\u52a9\u86c0\u8d2e\u94f8\u7b51\u4f4f\u6ce8\u795d\u9a7b\u4f2b\u4f8f\u90be\u82ce\u8331\u6d19\u6e1a\u6f74\u9a7a\u677c\u69e0\u6a65\u70b7\u94e2\u75b0\u7603\u86b0\u7afa\u7bb8\u7fe5\u8e85\u9e88&#x27;</span>,</span><br><span class="line">  <span class="attr">zhua</span>: <span class="string">&#x27;\u6293&#x27;</span>,</span><br><span class="line">  <span class="attr">zhuai</span>: <span class="string">&#x27;\u62fd&#x27;</span>,</span><br><span class="line">  <span class="attr">zhuan</span>: <span class="string">&#x27;\u4e13\u7816\u8f6c\u64b0\u8d5a\u7bc6\u629f\u556d\u989b&#x27;</span>,</span><br><span class="line">  <span class="attr">zhuang</span>: <span class="string">&#x27;\u6869\u5e84\u88c5\u5986\u649e\u58ee\u72b6\u4e2c&#x27;</span>,</span><br><span class="line">  <span class="attr">zhui</span>: <span class="string">&#x27;\u690e\u9525\u8ffd\u8d58\u5760\u7f00\u8411\u9a93\u7f12&#x27;</span>,</span><br><span class="line">  <span class="attr">zhun</span>: <span class="string">&#x27;\u8c06\u51c6&#x27;</span>,</span><br><span class="line">  <span class="attr">zhuo</span>:</span><br><span class="line">    <span class="string">&#x27;\u6349\u62d9\u5353\u684c\u7422\u8301\u914c\u707c\u6d4a\u502c\u8bfc\u5ef4\u855e\u64e2\u555c\u6d5e\u6dbf\u6753\u712f\u799a\u65ab&#x27;</span>,</span><br><span class="line">  <span class="attr">zi</span>:</span><br><span class="line">    <span class="string">&#x27;\u5179\u54a8\u8d44\u59ff\u6ecb\u6dc4\u5b5c\u7d2b\u4ed4\u7c7d\u6ed3\u5b50\u81ea\u6e0d\u5b57\u8c18\u5d6b\u59ca\u5b73\u7f01\u6893\u8f8e\u8d40\u6063\u7726\u9531\u79ed\u8014\u7b2b\u7ca2\u89dc\u8a3e\u9cbb\u9aed&#x27;</span>,</span><br><span class="line">  <span class="attr">zong</span>: <span class="string">&#x27;\u9b03\u68d5\u8e2a\u5b97\u7efc\u603b\u7eb5\u8159\u7cbd&#x27;</span>,</span><br><span class="line">  <span class="attr">zou</span>: <span class="string">&#x27;\u90b9\u8d70\u594f\u63cd\u9139\u9cb0&#x27;</span>,</span><br><span class="line">  <span class="attr">zu</span>:</span><br><span class="line">    <span class="string">&#x27;\u79df\u8db3\u5352\u65cf\u7956\u8bc5\u963b\u7ec4\u4fce\u83f9\u5550\u5f82\u9a75\u8e74&#x27;</span>,</span><br><span class="line">  <span class="attr">zuan</span>: <span class="string">&#x27;\u94bb\u7e82\u6525\u7f35&#x27;</span>,</span><br><span class="line">  <span class="attr">zui</span>: <span class="string">&#x27;\u5634\u9189\u6700\u7f6a&#x27;</span>,</span><br><span class="line">  <span class="attr">zun</span>: <span class="string">&#x27;\u5c0a\u9075\u6499\u6a3d\u9cdf&#x27;</span>,</span><br><span class="line">  <span class="attr">zuo</span>:</span><br><span class="line">    <span class="string">&#x27;\u6628\u5de6\u4f50\u67de\u505a\u4f5c\u5750\u5ea7\u961d\u963c\u80d9\u795a\u9162&#x27;</span>,</span><br><span class="line">  <span class="attr">cou</span>: <span class="string">&#x27;\u85ae\u6971\u8f8f\u8160&#x27;</span>,</span><br><span class="line">  <span class="attr">nang</span>: <span class="string">&#x27;\u652e\u54dd\u56d4\u9995\u66e9&#x27;</span>,</span><br><span class="line">  <span class="attr">o</span>: <span class="string">&#x27;\u5594&#x27;</span>,</span><br><span class="line">  <span class="attr">dia</span>: <span class="string">&#x27;\u55f2&#x27;</span>,</span><br><span class="line">  <span class="attr">chuai</span>: <span class="string">&#x27;\u562c\u81aa\u8e39&#x27;</span>,</span><br><span class="line">  <span class="attr">cen</span>: <span class="string">&#x27;\u5c91\u6d94&#x27;</span>,</span><br><span class="line">  <span class="attr">diu</span>: <span class="string">&#x27;\u94e5&#x27;</span>,</span><br><span class="line">  <span class="attr">nou</span>: <span class="string">&#x27;\u8028&#x27;</span>,</span><br><span class="line">  <span class="attr">fou</span>: <span class="string">&#x27;\u7f36&#x27;</span>,</span><br><span class="line">  <span class="attr">bia</span>: <span class="string">&#x27;\u9adf&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 汉字转拼音</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ConvertPinyin</span> (l1) &#123;</span><br><span class="line">  <span class="keyword">var</span> l2 = l1.<span class="property">length</span></span><br><span class="line">  <span class="keyword">var</span> <span class="variable constant_">I1</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;[a-zA-Z0-9- ]&#x27;</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; l2; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> val = l1.<span class="title function_">substr</span>(i, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">var</span> name = <span class="title function_">arraySearch</span>(val, <span class="title class_">PinYin</span>)</span><br><span class="line">    <span class="keyword">if</span> (reg.<span class="title function_">test</span>(val)) &#123;</span><br><span class="line">      <span class="variable constant_">I1</span> += val</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name !== <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="variable constant_">I1</span> += name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable constant_">I1</span> = <span class="variable constant_">I1</span>.<span class="title function_">replace</span>(<span class="regexp">/ /g</span>, <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">  <span class="keyword">while</span> (<span class="variable constant_">I1</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;--&#x27;</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable constant_">I1</span> = <span class="variable constant_">I1</span>.<span class="title function_">replace</span>(<span class="string">&#x27;--&#x27;</span>, <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable constant_">I1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在对象中搜索</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arraySearch</span> (l1, l2) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> l2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (l2[name].<span class="title function_">indexOf</span>(l1) != -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">ucfirst</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 首字母大写</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ucfirst</span> (l1) &#123;</span><br><span class="line">  <span class="keyword">if</span> (l1.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> first = l1.<span class="title function_">substr</span>(<span class="number">0</span>, <span class="number">1</span>).<span class="title function_">toUpperCase</span>()</span><br><span class="line">    <span class="keyword">var</span> spare = l1.<span class="title function_">substr</span>(<span class="number">1</span>, l1.<span class="property">length</span>)</span><br><span class="line">    <span class="keyword">return</span> first + spare</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">ConvertPinyin</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>从零开始配置webpack</title>
    <url>/post/dea76e8a02f5/</url>
    <content><![CDATA[<h2 id="从零开始配置webpack-基于webpack-4-和-babel-7版本"><a href="#从零开始配置webpack-基于webpack-4-和-babel-7版本" class="headerlink" title="从零开始配置webpack(基于webpack 4 和 babel 7版本)"></a>从零开始配置webpack(基于webpack 4 和 babel 7版本)</h2><h3 id="webpack-核心概念"><a href="#webpack-核心概念" class="headerlink" title="webpack 核心概念:"></a>webpack 核心概念:</h3><ul>
<li>Entry: 入口</li>
<li>Module:模块，webpack中一切皆是模块</li>
<li>Chunk:代码库，一个chunk由十多个模块组合而成，用于代码合并与分割</li>
<li>Loader:模块转换器，用于把模块原内容按照需求转换成新内容</li>
<li>Plugin:扩展插件，在webpack构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要做的事情</li>
<li>Output: 输出结果</li>
</ul>
<h3 id="webpack流程"><a href="#webpack流程" class="headerlink" title="webpack流程:"></a>webpack流程:</h3><p>webpack启动后会从 Entry 里配置的 Module 开始递归解析 Entry 依赖的所有Module.每找到一个Module,就会根据配置的Loader去找出对应的转换规则，对Module进行转换后，再解析出当前的Module依赖的Module.这些模块会以Entry为单位进行分组，一个Entry和其所有依赖的Module被分到一个组也就是一个Chunk。最好Webpack会把所有Chunk转换成文件输出。在整个流程中Webpack会在恰当的时机执行Plugin里定义的逻辑。</p>
<p>下面我们开始从零开始配置一个支持打包图片,CSS,LESS,SASS,支持ES6&#x2F;ES7和JSX语法，并对代码进行压缩的webpack配置.</p>
<h3 id="1-最简webpack配置"><a href="#1-最简webpack配置" class="headerlink" title="1. 最简webpack配置"></a>1. 最简webpack配置</h3><p>首先初始化npm和安装webpack的依赖:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br><span class="line">npm install --save-dev webpack webpack-cli</span><br></pre></td></tr></table></figure>
<p>配置 webpack.config.js 文件如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src/index.js&#x27;</span>),</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">        <span class="attr">publicPath</span>: <span class="string">&#x27;/&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: publicPath 上线时配置的是cdn的地址。</p>
<p>使用命令进行打包:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">webpack --mode production</span><br></pre></td></tr></table></figure>
<p>也可以将其配置到 package.json 中的 scripts 字段.</p>
<p>入口文件为 src&#x2F;index.js, 打包输出到 dist&#x2F;bundle.js.</p>
<h3 id="2-使用模板-html"><a href="#2-使用模板-html" class="headerlink" title="2. 使用模板 html"></a>2. 使用模板 html</h3><p>html-webpack-plugin 可以指定template模板文件，将会在output目录下，生成html文件，并引入打包后的js.</p>
<p>安装依赖:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save-dev html-webpack-plugin</span><br></pre></td></tr></table></figure>
<p>在 webpack.config.js 增加 plugins 配置:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">//...other code</span></span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">            <span class="attr">template</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src/index.html&#x27;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HtmlWebpackPlugin 还有一些其它的参数,如title(html的title),minify(是否要压缩),filename(dist中生成的html的文件名)等</p>
<h3 id="3-配置-webpack-dev-server"><a href="#3-配置-webpack-dev-server" class="headerlink" title="3. 配置 webpack-dev-server"></a>3. 配置 webpack-dev-server</h3><p>webpack-dev-server提供了一个简单的Web服务器和实时热更新的能力</p>
<p>安装依赖:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save-dev webpack-dev-server</span><br></pre></td></tr></table></figure>
<p>在 webpack.config.js 增加 devServer 配置:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">//...other code</span></span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">contentBase</span>: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">        <span class="attr">port</span>: <span class="string">&#x27;8080&#x27;</span>,</span><br><span class="line">        <span class="attr">host</span>: <span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 package.json 的 scripts 字段中增加:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">webpack-dev-server --mode development</span><br></pre></td></tr></table></figure>
<p>之后，我们就可以通过 npm run dev , 来启动服务。</p>
<p>更多 webpack-dev-server 的知识，请访问: <a href="https://webpack.js.org/configuration/dev-server/">https://webpack.js.org/configuration/dev-server/</a></p>
<h3 id="4-支持加载css文件"><a href="#4-支持加载css文件" class="headerlink" title="4. 支持加载css文件"></a>4. 支持加载css文件</h3><p>通过使用不同的 style-loader 和 css-loader, 可以将 css 文件转换成JS文件类型。</p>
<p>安装依赖:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save-dev style-loader css-loader</span><br></pre></td></tr></table></figure>
<p>在 webpack.config.js 中增加 loader 的配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">//other code</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.css/</span>,</span><br><span class="line">                <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>],</span><br><span class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                <span class="attr">include</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>loader 可以配置以下参数:</p>
<ul>
<li>test: 匹配处理文件的扩展名的正则表达式</li>
<li>use: loader名称</li>
<li>include&#x2F;exclude: 手动指定必须处理的文件夹或屏蔽不需要处理的文件夹</li>
<li>query: 为loader提供额外的设置选项</li>
</ul>
<p>如果需要给loader传参，那么可以使用use+loader的方式,如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">//other code</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="attr">use</span>: [&#123;</span><br><span class="line">                        <span class="attr">loader</span>: <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">                        <span class="attr">options</span>: &#123;</span><br><span class="line">                            <span class="attr">insertAt</span>: <span class="string">&#x27;top&#x27;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="comment">//....</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="5-支持加载图片"><a href="#5-支持加载图片" class="headerlink" title="5. 支持加载图片"></a>5. 支持加载图片</h3><ul>
<li>file-loader: 解决CSS等文件中的引入图片路径问题</li>
<li>url-loader: 当图片小于limit的时候会把图片Base64编码，大于limit参数的时候还是使用file-loader进行拷贝</li>
</ul>
<p>如果希望图片存放在单独的目录下，那么需要指定outputPath</p>
<p>安装依赖:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save-dev url-loader file-loader</span><br></pre></td></tr></table></figure>
<p>在 webpack.config.js 中增加 loader 的配置(增加在 module.rules 的数组中)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">//other code</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.(gif|jpg|png|bmp|eot|woff|woff2|ttf|svg)/</span>,</span><br><span class="line">                <span class="attr">use</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">                        <span class="attr">options</span>: &#123;</span><br><span class="line">                            <span class="attr">limit</span>: <span class="number">8192</span>,</span><br><span class="line">                            <span class="attr">outputPath</span>: <span class="string">&#x27;images&#x27;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="6-支持编译less和sass"><a href="#6-支持编译less和sass" class="headerlink" title="6.支持编译less和sass"></a>6.支持编译less和sass</h3><p>有些前端同事可能习惯于使用less或者是sass编写css，那么也需要在 webpack 中进行配置。</p>
<p>安装对应的依赖:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save-dev less less-loader</span><br><span class="line">npm install --save-dev node-sass sass-loader</span><br></pre></td></tr></table></figure>
<p>在 webpack.config.js 中增加 loader 的配置(module.rules 数组中)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">//other code</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.less/</span>,</span><br><span class="line">                <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;less-loader&#x27;</span>],</span><br><span class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                <span class="attr">include</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.scss/</span>,</span><br><span class="line">                <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;sass-loader&#x27;</span>],</span><br><span class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                <span class="attr">include</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>
<h3 id="7-支持转义-ES6-ES7-JSX"><a href="#7-支持转义-ES6-ES7-JSX" class="headerlink" title="7.支持转义 ES6&#x2F;ES7&#x2F;JSX"></a>7.支持转义 ES6&#x2F;ES7&#x2F;JSX</h3><p>ES6&#x2F;ES7&#x2F;JSX 转义需要 Babel 的依赖，支持装饰器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save-dev @babel/core babel-loader @babel/preset-env @babel/preset-react @babel/plugin-proposal-decorators @babel/plugin-proposal-object-rest-spread</span><br></pre></td></tr></table></figure>
<p>在 webpack.config.js 中增加 loader 的配置(module.rules 数组中)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">//other code</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">                <span class="attr">use</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">                        <span class="attr">options</span>: &#123;</span><br><span class="line">                            <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>, <span class="string">&#x27;@babel/react&#x27;</span>],</span><br><span class="line">                            <span class="attr">plugins</span>: [</span><br><span class="line">                                [<span class="built_in">require</span>(<span class="string">&quot;@babel/plugin-proposal-decorators&quot;</span>), &#123; <span class="string">&quot;legacy&quot;</span>: <span class="literal">true</span> &#125;]</span><br><span class="line">                            ]</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">include</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src&#x27;</span>),</span><br><span class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-压缩JS文件"><a href="#8-压缩JS文件" class="headerlink" title="8.压缩JS文件"></a>8.压缩JS文件</h3><p>安装依赖:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save-dev uglifyjs-webpack-plugin</span><br><span class="line">npm install --save-dev optimize-css-assets-webpack-plugin</span><br></pre></td></tr></table></figure>
<p>在 webpack.config.js 中增加 optimization 的配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">UglifyWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;uglifyjs-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">//other code</span></span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line">        <span class="attr">minimizer</span>: [</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">UglifyWebpackPlugin</span>(&#123;</span><br><span class="line">                <span class="attr">parallel</span>: <span class="number">4</span></span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="9-分离CSS-如果CSS文件较大的话"><a href="#9-分离CSS-如果CSS文件较大的话" class="headerlink" title="9.分离CSS(如果CSS文件较大的话)"></a>9.分离CSS(如果CSS文件较大的话)</h3><p>因为CSS的下载和JS可以并行，当一个HTML文件很大的时候，可以把CSS单独提取出来加载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save-dev mini-css-extract-plugin</span><br></pre></td></tr></table></figure>
<p>在 webpack.config.js 中增加 plugins 的配置,并且将 ‘style-loader’ 修改为 { loader: MiniCssExtractPlugin.loader}。</p>
<p>CSS打包在单独目录，那么配置filename。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">//other code</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.css/</span>,</span><br><span class="line">                <span class="attr">use</span>: [&#123; <span class="attr">loader</span>: <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>&#125;, <span class="string">&#x27;css-loader&#x27;</span>],</span><br><span class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                <span class="attr">include</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.less/</span>,</span><br><span class="line">                <span class="attr">use</span>: [&#123; <span class="attr">loader</span>: <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span> &#125;, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;less-loader&#x27;</span>],</span><br><span class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                <span class="attr">include</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.scss/</span>,</span><br><span class="line">                <span class="attr">use</span>: [&#123; <span class="attr">loader</span>: <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span> &#125;, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;sass-loader&#x27;</span>],</span><br><span class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                <span class="attr">include</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">            <span class="attr">filename</span>: <span class="string">&#x27;css/[name].css&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-压缩CSS文件"><a href="#10-压缩CSS文件" class="headerlink" title="10.压缩CSS文件"></a>10.压缩CSS文件</h3><p>安装依赖:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save-dev optimize-css-assets-webpack-plugin</span><br></pre></td></tr></table></figure>
<p>在 webpack.config.js 中的 optimization 中增加配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">OptimizeCssAssetsWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;optimize-css-assets-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">//other code</span></span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line">        <span class="attr">minimizer</span>: [</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">OptimizeCssAssetsWebpackPlugin</span>()</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="11-打包前先清空输出目录"><a href="#11-打包前先清空输出目录" class="headerlink" title="11.打包前先清空输出目录"></a>11.打包前先清空输出目录</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save-dev clean-webpack-plugin</span><br></pre></td></tr></table></figure>
<p>在 webpack.config.js 中增加 plugins 的配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CleanWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">//other code</span></span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CleanWebpackPlugin</span>()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，webpack配置已经基本能满足需求。</p>
<h3 id="完整webpack-config-js和package-json文件"><a href="#完整webpack-config-js和package-json文件" class="headerlink" title="完整webpack.config.js和package.json文件"></a>完整webpack.config.js和package.json文件</h3><p>webpack.config.js文件:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> htmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">UglifyWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;uglifyjs-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CleanWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">OptimizeCssAssetsWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;optimize-css-assets-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src/index.js&#x27;</span>),</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">        <span class="attr">publicPath</span>: <span class="string">&#x27;/&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">contentBase</span>: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">        <span class="attr">port</span>: <span class="string">&#x27;8080&#x27;</span>,</span><br><span class="line">        <span class="attr">host</span>: <span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">                <span class="attr">use</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">                        <span class="attr">options</span>: &#123;</span><br><span class="line">                            <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>, <span class="string">&#x27;@babel/react&#x27;</span>],</span><br><span class="line">                            <span class="attr">plugins</span>: [</span><br><span class="line">                                [<span class="built_in">require</span>(<span class="string">&quot;@babel/plugin-proposal-decorators&quot;</span>), &#123; <span class="string">&quot;legacy&quot;</span>: <span class="literal">true</span> &#125;]</span><br><span class="line">                            ]</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">include</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src&#x27;</span>),</span><br><span class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.css/</span>,</span><br><span class="line">                <span class="attr">use</span>: [&#123; <span class="attr">loader</span>: <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>&#125;, <span class="string">&#x27;css-loader&#x27;</span>],</span><br><span class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                <span class="attr">include</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.less/</span>,</span><br><span class="line">                <span class="attr">use</span>: [&#123; <span class="attr">loader</span>: <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span> &#125;, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;less-loader&#x27;</span>],</span><br><span class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                <span class="attr">include</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.scss/</span>,</span><br><span class="line">                <span class="attr">use</span>: [&#123; <span class="attr">loader</span>: <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span> &#125;, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;sass-loader&#x27;</span>],</span><br><span class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                <span class="attr">include</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.(gif|jpg|png|bmp|eot|woff|woff2|ttf|svg)/</span>,</span><br><span class="line">                <span class="attr">use</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">                        <span class="attr">options</span>: &#123;</span><br><span class="line">                            <span class="attr">limit</span>: <span class="number">1024</span>,</span><br><span class="line">                            <span class="attr">outputPath</span>: <span class="string">&#x27;images&#x27;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line">        <span class="attr">minimizer</span>: [</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">UglifyWebpackPlugin</span>(&#123;</span><br><span class="line">                <span class="attr">parallel</span>: <span class="number">4</span></span><br><span class="line">            &#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">OptimizeCssAssetsWebpackPlugin</span>()</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> <span class="title function_">htmlWebpackPlugin</span>(&#123;</span><br><span class="line">            <span class="attr">template</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src/index.html&#x27;</span>),</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">            <span class="attr">filename</span>: <span class="string">&#x27;css/[name].css&#x27;</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CleanWebpackPlugin</span>()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>package.json文件:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;webpk&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;webpack.config.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build&quot;</span>: <span class="string">&quot;webpack --mode production&quot;</span>,</span><br><span class="line">    <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;webpack-dev-server --mode development&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;keywords&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span>,</span><br><span class="line">  <span class="string">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;@babel/core&quot;</span>: <span class="string">&quot;^7.4.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@babel/plugin-proposal-decorators&quot;</span>: <span class="string">&quot;^7.4.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@babel/plugin-proposal-object-rest-spread&quot;</span>: <span class="string">&quot;^7.4.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@babel/preset-env&quot;</span>: <span class="string">&quot;^7.4.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@babel/preset-react&quot;</span>: <span class="string">&quot;^7.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;babel-loader&quot;</span>: <span class="string">&quot;^8.0.5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;clean-webpack-plugin&quot;</span>: <span class="string">&quot;^2.0.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;css-loader&quot;</span>: <span class="string">&quot;^2.1.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;file-loader&quot;</span>: <span class="string">&quot;^3.0.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;html-webpack-plugin&quot;</span>: <span class="string">&quot;^3.2.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;less&quot;</span>: <span class="string">&quot;^3.9.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;less-loader&quot;</span>: <span class="string">&quot;^4.1.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;mini-css-extract-plugin&quot;</span>: <span class="string">&quot;^0.5.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;node-sass&quot;</span>: <span class="string">&quot;^4.11.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;optimize-css-assets-webpack-plugin&quot;</span>: <span class="string">&quot;^5.0.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sass-loader&quot;</span>: <span class="string">&quot;^7.1.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;style-loader&quot;</span>: <span class="string">&quot;^0.23.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;uglifyjs-webpack-plugin&quot;</span>: <span class="string">&quot;^2.1.2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;url-loader&quot;</span>: <span class="string">&quot;^1.1.2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;webpack&quot;</span>: <span class="string">&quot;^4.29.6&quot;</span>,</span><br><span class="line">    <span class="string">&quot;webpack-cli&quot;</span>: <span class="string">&quot;^3.3.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;webpack-dev-server&quot;</span>: <span class="string">&quot;^3.2.1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;react&quot;</span>: <span class="string">&quot;^16.8.4&quot;</span>,</span><br><span class="line">    <span class="string">&quot;react-dom&quot;</span>: <span class="string">&quot;^16.8.4&quot;</span>,</span><br><span class="line">    <span class="string">&quot;react-redux&quot;</span>: <span class="string">&quot;^6.0.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;redux&quot;</span>: <span class="string">&quot;^4.0.1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多loader和plugin的参数可以参考:</p>
<p><a href="https://www.webpackjs.com/loaders/">https://www.webpackjs.com/loaders/</a></p>
<p><a href="https://www.webpackjs.com/plugins/">https://www.webpackjs.com/plugins/</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Gitalk实现静态博客无后台评论系统</title>
    <url>/post/94236b9656f1/</url>
    <content><![CDATA[<h1 id="使用Gitalk实现静态博客无后台评论系统"><a href="#使用Gitalk实现静态博客无后台评论系统" class="headerlink" title="使用Gitalk实现静态博客无后台评论系统"></a>使用Gitalk实现静态博客无后台评论系统</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Gitalk，一个基于 Github Issue 和 Preact 开发的评论插件。</p>
<p>下面我们来用它在vuepress搭建的博客中搭建评论区吧</p>
<span id="more"></span>


<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>使用一个新的东西首先当然是要了解它</p>
<p>Gitalk demo：<a href="https://gitalk.github.io/">https://gitalk.github.io/</a></p>
<p>Gitalk github：<a href="https://github.com/gitalk/gitalk">https://github.com/gitalk/gitalk</a></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>如何实现？最好的方法我认为是看<a href="https://github.com/gitalk/gitalk/blob/master/readme-cn.md">官方文档</a>，这里我只是记录一下实现的步骤。</p>
<p>使用一个别人已经开发好的 <a href="https://github.com/dongyuanxin/vuepress-plugin-comment">vuepress-plugin-comment</a> 插件来帮助我们把Gitalk应用到vuepress搭建的静态博客。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install --save vuepress-plugin-comment</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><code>options</code>的配置和<code>Gitalk</code>的配置相同</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&#x27;vuepress-plugin-comment&#x27;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">choosen</span>: <span class="string">&#x27;gitalk&#x27;</span>, </span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">clientID</span>: <span class="string">&#x27;GitHub Application Client ID&#x27;</span>,</span><br><span class="line">          <span class="attr">clientSecret</span>: <span class="string">&#x27;GitHub Application Client Secret&#x27;</span>,</span><br><span class="line">          <span class="attr">repo</span>: <span class="string">&#x27;GitHub repo&#x27;</span>,</span><br><span class="line">          <span class="attr">owner</span>: <span class="string">&#x27;GitHub repo owner&#x27;</span>,</span><br><span class="line">          <span class="attr">admin</span>: [<span class="string">&#x27;GitHub repo owner and collaborators, only these guys can initialize github issues&#x27;</span>],</span><br><span class="line">          <span class="attr">distractionFreeMode</span>: <span class="literal">false</span> </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要 <strong>GitHub Application</strong>，如果没有 <a href="https://github.com/settings/applications/new">点击这里申请</a>，<code>Authorization callback URL</code> 填写当前使用插件页面的域名。</p>
<p><img src="https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/QQ%E6%88%AA%E5%9B%BE20191220124134.jpg"></p>
<p>申请完成就会得 Client ID 和 Client Secret。然后把对应参数填写到配置中，例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&#x27;vuepress-plugin-comment&#x27;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">choosen</span>: <span class="string">&#x27;gitalk&#x27;</span>, </span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">clientID</span>: <span class="string">&#x27;a6e*******4709b88b&#x27;</span>,</span><br><span class="line">          <span class="attr">clientSecret</span>: <span class="string">&#x27;f0e***************beb8b2d54d7241&#x27;</span>,</span><br><span class="line">          <span class="attr">repo</span>: <span class="string">&#x27;blog&#x27;</span>, <span class="comment">// GitHub 仓库</span></span><br><span class="line">          <span class="attr">owner</span>: <span class="string">&#x27;ytking&#x27;</span>, <span class="comment">// GitHub仓库所有者</span></span><br><span class="line">          <span class="attr">admin</span>: [<span class="string">&#x27;ytking&#x27;</span>], <span class="comment">// 对仓库有写权限的人</span></span><br><span class="line">          <span class="attr">distractionFreeMode</span>: <span class="literal">false</span> </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置好之后重启项目就发现页面上多了一个评论区，说明评论功能实现啦。但还是有一些bug，继续完善它~</p>
<h3 id="BUG修复"><a href="#BUG修复" class="headerlink" title="BUG修复"></a>BUG修复</h3><p><strong>评论区与博客样式不匹配</strong></p>
<p>解决办法：新增全局样式文件<code>.vuepress/styles/index.styl</code>，写入样式</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#vuepress-plugin-comment</span></span><br><span class="line">  <span class="attribute">max-width</span> <span class="variable">$contentWidth</span></span><br><span class="line">  <span class="attribute">margin</span> <span class="number">0</span> auto</span><br><span class="line">  <span class="attribute">padding</span> <span class="number">2rem</span> <span class="number">2.5rem</span></span><br><span class="line">  <span class="keyword">@media</span> (<span class="attribute">max-width</span>: $MQNarrow)</span><br><span class="line">    padding <span class="number">2rem</span></span><br><span class="line">  @media (<span class="attribute">max-width</span>: $MQMobileNarrow)</span><br><span class="line">    padding <span class="number">1.5rem</span></span><br></pre></td></tr></table></figure>



<p><strong>评论区出现 Error: Validation Failed.</strong></p>
<p>问题分析：当页面 链接过长  或 存在中文链接，导致整个链接字符串长度超过50时，会造成请求issues接口失败，出现422状态码。（中文链接会自动转码，变得很长，id参数默认取的是链接，长度不能超过50）</p>
<p>解决办法：手动设置id取值，限制长度不超过50。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attr">choosen</span>: <span class="string">&#x27;gitalk&#x27;</span>, </span><br><span class="line"> <span class="attr">options</span>: &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="attr">id</span>: <span class="string">&quot;&lt;%- (window.location.origin + (frontmatter.to.path || window.location.pathname)).slice(-50) %&gt;&quot;</span>, <span class="comment">//  页面的唯一标识,长度不能超过50</span></span><br><span class="line">   <span class="attr">title</span>: <span class="string">&quot;「评论」&lt;%- document.title %&gt;&quot;</span>, <span class="comment">// GitHub issue 的标题</span></span><br><span class="line">   <span class="attr">labels</span>: [<span class="string">&quot;Gitalk&quot;</span>, <span class="string">&quot;Comment&quot;</span>], <span class="comment">// GitHub issue 的标签</span></span><br><span class="line">   <span class="attr">body</span>:<span class="string">&quot;&lt;%- document.title %&gt;：&lt;%- window.location.origin + (frontmatter.to.path || window.location.pathname) %&gt;&quot;</span> <span class="comment">// GitHub issue 的内容</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>访问变量时，如 <code>$frontmatter</code> 或 <code>window</code>等，请使用  <strong>EJS</strong> 语法。因为在配置中不能使用回调函数，会被vuepress过滤，因此使用 <strong>EJS</strong> 语法。 ——插件作者文档说明</p>
</blockquote>
<p><strong>切换页面后评论区内容还是上一个页面的评论</strong></p>
<p>解决：id在获取<code>path</code>时使用 <code>frontmatter.to.path</code>，插件内置了 &#96;&#96;frontmatter.from<code>、</code>frontmatter.to&#96;。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attr">choosen</span>: <span class="string">&#x27;gitalk&#x27;</span>, </span><br><span class="line"> <span class="attr">options</span>: &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="attr">id</span>: <span class="string">&quot;&lt;%- (window.location.origin + (frontmatter.to.path || window.location.pathname)).slice(-50) %&gt;&quot;</span>, <span class="comment">//  页面的唯一标识,长度不能超过50</span></span><br><span class="line">   <span class="attr">title</span>: <span class="string">&quot;「评论」&lt;%- document.title %&gt;&quot;</span>, <span class="comment">// GitHub issue 的标题</span></span><br><span class="line">   <span class="attr">labels</span>: [<span class="string">&quot;Gitalk&quot;</span>, <span class="string">&quot;Comment&quot;</span>], <span class="comment">// GitHub issue 的标签</span></span><br><span class="line">   <span class="attr">body</span>:<span class="string">&quot;&lt;%- document.title %&gt;：&lt;%- window.location.origin + (frontmatter.to.path || window.location.pathname) %&gt;&quot;</span> <span class="comment">// GitHub issue 的内容</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

























































]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>使用CSS实现进度条和饼图</title>
    <url>/post/1fcbce14f5b5/</url>
    <content><![CDATA[<p>进度条，是我们日常界面中使用的非常多的一种，下面我们来看看。到今天，我们可以如何实现进度条。</p>
<h2 id="HTML-标签-–-meter-progress"><a href="#HTML-标签-–-meter-progress" class="headerlink" title="HTML 标签 – meter &amp; progress"></a>HTML 标签 – meter &amp; progress</h2><p>这个可能是一些同学还不太清楚的，HTML5 原生提供了两个标签 <code>&lt;meter&gt;</code> 和 <code>&lt;progress&gt;</code> 来实现进度条。</p>
<ul>
<li><code>&lt;meter&gt;</code>：用来显示已知范围的标量值或者分数值</li>
<li><code>&lt;progress&gt;</code>：用来显示一项任务的完成进度，通常情况下，该元素都显示为一个进度条</li>
</ul>
<p>我们分别来看看，首先是 <code>&lt;meter&gt;</code> 标签：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>完成度：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">meter</span> <span class="attr">min</span>=<span class="string">&quot;0&quot;</span> <span class="attr">max</span>=<span class="string">&quot;500&quot;</span> <span class="attr">value</span>=<span class="string">&quot;350&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    350 degrees</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">meter</span>&gt;</span></span></span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">meter &#123;</span><br><span class="line">    <span class="attr">width</span>: 200px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>样式如下：</p>
<p><img src="https://alianck.oss-cn-beijing.aliyuncs.com/process1.webp" alt="图片"></p>
<p>其中，<code>min</code>、<code>max</code>、<code>value</code> 分别表示最大值，最小值与当前值。</p>
<p>无独有偶，我们再来看看 <code>&lt;progress&gt;</code> 标签的用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;file&quot;</span>&gt;</span>完成度：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">progress</span> <span class="attr">max</span>=<span class="string">&quot;100&quot;</span> <span class="attr">value</span>=<span class="string">&quot;70&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;&quot; &quot;&#125;</span></span><br><span class="line"><span class="language-xml">    70%&#123;&quot; &quot;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">progress</span>&gt;</span></span></span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">progress &#123;</span><br><span class="line">    <span class="attr">width</span>: 200px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>样式如下：</p>
<p><img src="https://alianck.oss-cn-beijing.aliyuncs.com/process2.webp" alt="图片"></p>
<p>其中，<code>max</code> 属性描述这个 progress 元素所表示的任务一共需要完成多少工作量，<code>value</code> 属性用来指定该进度条已完成的工作量。</p>
<h3 id="meter-progress-之间的差异"><a href="#meter-progress-之间的差异" class="headerlink" title="meter &amp; progress 之间的差异"></a>meter &amp; progress 之间的差异</h3><p>那么问题来了，从上述 Demo 看，两个标签的效果一模一样，那么它们的区别是什么？为什么会有两个看似一样的标签呢？</p>
<p>这两个元素最大的差异在于<strong>语义上的差别</strong>。</p>
<ul>
<li><code>&lt;meter&gt;</code>：表示<strong>已知范围内的标量测量值或分数值</strong></li>
<li><code>&lt;progress&gt;</code>：表示<strong>任务的完成进度</strong></li>
</ul>
<p>譬如，一个需求当前的完成度，应该使用 <code>&lt;progress&gt;</code>，而如果要展示汽车仪表盘当前的速度值，应该使用 <code>meter</code>。</p>
<h3 id="meter-progress-的局限性"><a href="#meter-progress-的局限性" class="headerlink" title="meter &amp; progress 的局限性"></a>meter &amp; progress 的局限性</h3><p>当然，在实际的业务需求中，或者生产环境，你几乎是不会看到 <code>&lt;meter&gt;</code> 和 <code>&lt;progress&gt;</code> 标签。</p>
<p>和我们在这篇文章中 – 《利用 datalist 实现可过滤下拉选框》[1] 讲到的原因类似，在于：</p>
<ol>
<li>我们无法有效的修改 <code>&lt;meter&gt;</code> 和 <code>&lt;progress&gt;</code> 标签的样式，譬如背景色，进度前景色等。并且，最为致命的是，浏览器默认样式的表现在不同浏览器之间并不一致。这给追求稳定，UI 表现一致的业务来说，是灾难性的缺点！</li>
<li>我们无法给他添加一些动画效果、交互效果，因为一些实际的应用场景中，肯定不是简单的展示一个进度条仅此而已</li>
</ol>
<h2 id="利用-CSS-实现进度条"><a href="#利用-CSS-实现进度条" class="headerlink" title="利用 CSS 实现进度条"></a>利用 CSS 实现进度条</h2><p>因此，在现阶段，更多的还是使用一些 CSS 的方式去实现进度条。</p>
<h3 id="使用百分比实现进度条"><a href="#使用百分比实现进度条" class="headerlink" title="使用百分比实现进度条"></a>使用百分比实现进度条</h3><p>最为常见的一种方式是使用背景色配合百分比的方式制作进度条。</p>
<p>最简单的一个 DEMO：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;g-container&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;g-progress&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.<span class="property">g</span>-container &#123;</span><br><span class="line">    <span class="attr">width</span>: 240px;</span><br><span class="line">    <span class="attr">height</span>: 25px;</span><br><span class="line">    border-<span class="attr">radius</span>: 25px;</span><br><span class="line">    <span class="attr">background</span>: #eee;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">g</span>-progress &#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="number">50</span>%;</span><br><span class="line">    <span class="attr">height</span>: inherit;</span><br><span class="line">    border-<span class="attr">radius</span>: 25px <span class="number">0</span> <span class="number">0</span> 25px;</span><br><span class="line">    <span class="attr">background</span>: #0f0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://alianck.oss-cn-beijing.aliyuncs.com/process3.webp" alt="图片"></p>
<p>这种方式优势在于使用简单，实际进度可以非常方便的传递进 CSS 中</p>
<ol>
<li>利用 HTML <code>style</code> 属性填写完整的 <code>width</code> 值，譬如 <code>&lt;div class=&quot;g-progress&quot; style=&quot;width: 50%&quot;&gt;&lt;/div&gt;</code></li>
<li>或者利用 CSS 自定义属性 <code>&lt;div class=&quot;g-progress&quot; style=&quot;--progress: 50%&quot;&gt;&lt;/div&gt;</code> 配合实际 CSS 中的 <code>width: var(--progress)</code></li>
<li>完全的自定义样式，以及可以轻松的添加辅助丰富的动画和交互效果</li>
</ol>
<p>譬如给 <code>g-progress</code> 添加一个过渡效果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.<span class="property">g</span>-progress &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">transition</span>: width .2s linear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样，每次进度变化，都是一个动态的过渡过程：</p>
<p><img src="https://alianck.oss-cn-beijing.aliyuncs.com/process4.gif" alt="图片"></p>
<p>或者，渐变前景色，修改 <code>background: #0f0</code> 为 <code>background: linear-gradient(90deg, #0f0, #0ff)</code>：</p>
<h3 id="单标签使用渐变实现"><a href="#单标签使用渐变实现" class="headerlink" title="单标签使用渐变实现"></a>单标签使用渐变实现</h3><p>当然，可以看到，我们上面使用的是两个标签的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;g-container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;g-progress&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>抠门点，我们还可以仅仅利用一个标签去完成这个事情，主要借助了渐变去完成这个事情：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;g-progress&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.<span class="property">g</span>-progress &#123;</span><br><span class="line">    <span class="attr">width</span>: 240px;</span><br><span class="line">    <span class="attr">height</span>: 25px;</span><br><span class="line">    border-<span class="attr">radius</span>: 25px;</span><br><span class="line">    <span class="attr">background</span>: linear-<span class="title function_">gradient</span>(90deg, #0f0, #0ff <span class="number">70</span>%, transparent <span class="number">0</span>);</span><br><span class="line">    <span class="attr">border</span>: 1px solid #eee;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="https://alianck.oss-cn-beijing.aliyuncs.com/process5.webp" alt="图片"></p>
<p>同样的，我们可以利用 HTML <code>style</code> 属性填写完整的 <code>background</code> 值传递实际百分比，当然，这里更推荐使用 CSS 自定义属性传值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;g-progress&quot;</span> style=<span class="string">&quot;--progress: 50%&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.<span class="property">g</span>-progress &#123;</span><br><span class="line">    <span class="attr">background</span>: linear-<span class="title function_">gradient</span>(90deg, #0f0, #0ff <span class="title function_">var</span>(--progress), transparent <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>熟悉 CSS 的同学会发现一个目前这种方式的弊端，在于当修改 <code>--progress</code> 的值的时候，即便给 <code>.g-progress</code> 添加了 <code>transition</code>，也不会有过渡动画效果。</p>
<p>原因在于，CSS 中，渐变（诸如 <code>linear-gradinet</code>、<code>radial-gradient</code>、<code>conic-gradient</code>）都是不支持过渡变换的。</p>
<p>所以，在这里，为了实现动画效果，我们可以借助 CSS @property，改造下我们的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;g-progress&quot; style=&quot;--progress: 70%&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@property --progress &#123;</span><br><span class="line">  <span class="attr">syntax</span>: <span class="string">&#x27;&lt;percentage&gt;&#x27;</span>;</span><br><span class="line">  <span class="attr">inherits</span>: <span class="literal">false</span>;</span><br><span class="line">  initial-<span class="attr">value</span>: <span class="number">0</span>%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.<span class="property">g</span>-progress &#123;</span><br><span class="line">    <span class="attr">margin</span>: auto;</span><br><span class="line">    <span class="attr">width</span>: 240px;</span><br><span class="line">    <span class="attr">height</span>: 25px;</span><br><span class="line">    border-<span class="attr">radius</span>: 25px;</span><br><span class="line">    <span class="attr">background</span>: linear-<span class="title function_">gradient</span>(90deg, #0f0, #0ff <span class="title function_">var</span>(--progress), transparent <span class="number">0</span>);</span><br><span class="line">    <span class="attr">border</span>: 1px solid #eee;</span><br><span class="line">    <span class="attr">transition</span>: .3s --progress;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>借助 CSS @property 的特性，我们在单标签下也是可以实现动画效果的：</p>
<p><img src="https://alianck.oss-cn-beijing.aliyuncs.com/process6.gif" alt="图片"></p>
<p>CodePen Demo – 单标签的进度条效果[2]</p>
<blockquote>
<p>对 CSS @property 还不了解的，可以看看我的这篇文章 – CSS @property，让不可能变可能[3]</p>
</blockquote>
<h2 id="圆弧形进度条"><a href="#圆弧形进度条" class="headerlink" title="圆弧形进度条"></a>圆弧形进度条</h2><p>当然，进度条不可能只有直线型的。还有非常多其他类型的，下面我们首先来看看圆弧型的进度条。</p>
<p>在今天，我们可以使用 CSS 快速的创建圆弧形式的进度条，类似于这样：</p>
<p><img src="https://alianck.oss-cn-beijing.aliyuncs.com/process7.webp" alt="图片"></p>
<p>核心就是使用角向渐变 <code>background: conic-gradient()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;g-progress&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.<span class="property">g</span>-progress &#123;</span><br><span class="line">    <span class="attr">width</span>: 160px;</span><br><span class="line">    <span class="attr">height</span>: 160px;</span><br><span class="line">    border-<span class="attr">radius</span>: <span class="number">50</span>%;</span><br><span class="line">    <span class="attr">background</span>: conic-<span class="title function_">gradient</span>(#<span class="title class_">FFCDB2</span> <span class="number">0</span>, #<span class="title class_">FFCDB2</span> <span class="number">25</span>%, #<span class="variable constant_">B5838D</span> <span class="number">25</span>%, #<span class="variable constant_">B5838D</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>利用角向渐变 <code>background: conic-gradient()</code>，我们可以轻松实现这样一个饼图：</p>
<p><img src="https://alianck.oss-cn-beijing.aliyuncs.com/process8.webp" alt="图片"></p>
<p>接下来就是镂空中间部分。</p>
<p>传统的想法是，在中间叠加一个圆，然而，这样做的一个极大的弊端在于，如果我们的背景不是纯色而是渐变色，就不适用了，譬如这样：</p>
<p><img src="https://alianck.oss-cn-beijing.aliyuncs.com/process9.webp" alt="图片"></p>
<p>那么如何镂空中间，使得中间部分透明呢？这里我们可以巧妙的通过 <code>mask</code> 属性达到目的，镂空中间：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.<span class="property">g</span>-progress &#123;</span><br><span class="line">    <span class="attr">background</span>: conic-<span class="title function_">gradient</span>(#<span class="title class_">FFCDB2</span> <span class="number">0</span>, #<span class="title class_">FFCDB2</span> <span class="number">25</span>%, #<span class="variable constant_">B5838D</span> <span class="number">25</span>%, #<span class="variable constant_">B5838D</span>);</span><br><span class="line">  + <span class="attr">mask</span>: radial-<span class="title function_">gradient</span>(transparent, transparent <span class="number">50</span>%, #<span class="number">000</span> <span class="number">50</span>%, #<span class="number">000</span> <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样，我们就轻松的镂空了中间，即便背景不是纯色也无妨。</p>
<p><img src="https://alianck.oss-cn-beijing.aliyuncs.com/process10.webp" alt="图片"></p>
<p>CodePen Demo - 角向渐变实现圆弧形进度条[4]</p>
<p>基于此拓展，还可以实现多色的圆弧型进度条：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.<span class="property">g</span>-progress &#123;</span><br><span class="line">    <span class="attr">width</span>: 160px;</span><br><span class="line">    <span class="attr">height</span>: 160px;</span><br><span class="line">    border-<span class="attr">radius</span>: <span class="number">50</span>%;</span><br><span class="line">    <span class="attr">mask</span>: radial-<span class="title function_">gradient</span>(transparent, transparent <span class="number">50</span>%, #<span class="number">000</span> <span class="number">51</span>%, #<span class="number">000</span> <span class="number">0</span>);</span><br><span class="line">    <span class="attr">background</span>:</span><br><span class="line">        conic-<span class="title function_">gradient</span>(</span><br><span class="line">            #<span class="title class_">FFCDB2</span> <span class="number">0</span>, #<span class="title class_">FFCDB2</span> <span class="number">25</span>%,</span><br><span class="line">            #<span class="variable constant_">B5838D</span> <span class="number">25</span>%, #<span class="variable constant_">B5838D</span> <span class="number">50</span>%,</span><br><span class="line">            #673ab7 <span class="number">50</span>%, #673ab7 <span class="number">90</span>%,</span><br><span class="line">            #ff5722 <span class="number">90.2</span>%, #ff5722 <span class="number">100</span>%</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然，这个可能不像进度条，更类似于饼图？</p>
<p><img src="https://alianck.oss-cn-beijing.aliyuncs.com/process11.webp" alt="图片"></p>
<h3 id="角向渐变实现圆弧进度条的局限性"><a href="#角向渐变实现圆弧进度条的局限性" class="headerlink" title="角向渐变实现圆弧进度条的局限性"></a>角向渐变实现圆弧进度条的局限性</h3><p>当然，这个方法有两个弊端。</p>
<ol>
<li>当然进度百分比不是类似于 0°、90°、180°、270°、360° 这类数字时，使用角向渐变时，不同颜色间的衔接处会有明显的锯齿。</li>
</ol>
<p>看个例子 <code>conic-gradient(#FFCDB2 0, #FFCDB2 27%, #B5838D 27%, #B5838D)</code>：</p>
<p><img src="https://alianck.oss-cn-beijing.aliyuncs.com/process12.webp" alt="图片"></p>
<p>遇到此类问题的解决方案是，在衔接处，适当留出一些渐变空间，我们简单的改造一下上述角向渐变代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  - <span class="attr">background</span>: conic-<span class="title function_">gradient</span>(#<span class="title class_">FFCDB2</span> <span class="number">0</span>, #<span class="title class_">FFCDB2</span> <span class="number">27</span>%, #<span class="variable constant_">B5838D</span> <span class="number">27</span>%, #<span class="variable constant_">B5838D</span>)<span class="string">`</span></span><br><span class="line"><span class="string">  + background: conic-gradient(#FFCDB2 0, #FFCDB2 27%, #B5838D 27.2%, #B5838D)`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>仔细看上面的代码，将从 <code>27%</code> 到 <code>27%</code> 的一个变化，改为了 从 <code>27%</code> 到 <code>27.2%</code>，这多出来的 <code>0.2%</code> 就是为了消除锯齿的，实际改变后的效果：</p>
<p><img src="https://alianck.oss-cn-beijing.aliyuncs.com/process13.webp" alt="图片"></p>
<p>具体使用的使用，可以多调试选取既不会看出模糊，又能尽可能消除锯齿的一个范围幅度。</p>
<ol>
<li>对于开头和结尾需要圆形的圆弧进度条实现起来较为麻烦</li>
</ol>
<p>还有一种情况，实际使用中，要求的是首尾带圆形的圆弧进度条，例如下图所示：</p>
<p><img src="https://alianck.oss-cn-beijing.aliyuncs.com/process14.webp" alt="图片"></p>
<p>当然，这种情况当然进度条颜色是<strong>纯色</strong>也是可以解决的，我们通过在在首尾处叠加两个小圆圈即可实现这种效果。</p>
<p>如果进度条是渐变色的话，这种进度条则需要借助 SVG&#x2F;Canvas 实现了。</p>
<p>上述完整的带圆角的圆弧进度条，你可以戳这里看完整源码 – CodePen Demo – 首尾为圆形的圆弧进度条[5]</p>
<h2 id="球形进度条-wave"><a href="#球形进度条-wave" class="headerlink" title="球形进度条 wave"></a>球形进度条 wave</h2><p>球形进度条也是比较常见的，类似于下面这种：</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>对于球形进度条，其实核心在于使用 CSS 实现中间部分的波浪效果。</p>
<p>这个技巧到今天应该已经被大伙熟知了，就不过多赘述，一图胜千言，可以使用滚动大圆的方式，类似于这样：</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>容器应用 <code>overflow: hidden</code>，就能得到这样的效果：</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>对这个技巧还不理解，可以猛击这篇文章：纯 CSS 实现波浪效果！[6]</p>
<p>应用这个技巧，只需要简单的封装，控制一下球形容器表示进度 0% - 100% 时的波浪的高度即可。我们就能得到从 0% - 100% 的动画效果。</p>
<p>完整的代码大概如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wave-change&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wave&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.<span class="property">container</span> &#123;</span><br><span class="line">    <span class="attr">width</span>: 200px;</span><br><span class="line">    <span class="attr">height</span>: 200px;</span><br><span class="line">    <span class="attr">border</span>: 5px solid <span class="title function_">rgb</span>(<span class="number">118</span>, <span class="number">218</span>, <span class="number">255</span>);</span><br><span class="line">    border-<span class="attr">radius</span>: <span class="number">50</span>%;</span><br><span class="line">    <span class="attr">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">wave</span>-change &#123;</span><br><span class="line">        <span class="attr">position</span>: absolute;</span><br><span class="line">        <span class="attr">width</span>: 200px;</span><br><span class="line">        <span class="attr">height</span>: 200px;</span><br><span class="line">        <span class="attr">left</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attr">top</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attr">animation</span>: change 12s infinite linear;</span><br><span class="line">      &#125;</span><br><span class="line">      .<span class="property">wave</span>-<span class="attr">change</span>::before,</span><br><span class="line">      .<span class="property">wave</span>-<span class="attr">change</span>::after &#123;</span><br><span class="line">        <span class="attr">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="attr">position</span>: absolute;</span><br><span class="line">        <span class="attr">width</span>: 400px;</span><br><span class="line">        <span class="attr">height</span>: 400px;</span><br><span class="line">        <span class="attr">top</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attr">left</span>: <span class="number">50</span>%;</span><br><span class="line">        background-<span class="attr">color</span>: <span class="title function_">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.6</span>);</span><br><span class="line">        border-<span class="attr">radius</span>: <span class="number">45</span>% <span class="number">47</span>% <span class="number">43</span>% <span class="number">46</span>%;</span><br><span class="line">        <span class="attr">transform</span>: <span class="title function_">translate</span>(-<span class="number">50</span>%, -<span class="number">70</span>%) <span class="title function_">rotate</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="attr">animation</span>: rotate 7s linear infinite;</span><br><span class="line">        z-<span class="attr">index</span>: <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      .<span class="property">wave</span>-<span class="attr">change</span>::after &#123;</span><br><span class="line">        border-<span class="attr">radius</span>: <span class="number">47</span>% <span class="number">42</span>% <span class="number">46</span>% <span class="number">44</span>%;</span><br><span class="line">        background-<span class="attr">color</span>: <span class="title function_">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.8</span>);</span><br><span class="line">        <span class="attr">transform</span>: <span class="title function_">translate</span>(-<span class="number">50</span>%, -<span class="number">70</span>%) <span class="title function_">rotate</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="attr">animation</span>: rotate 9s linear -4s infinite;</span><br><span class="line">        z-<span class="attr">index</span>: <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">.<span class="property">wave</span> &#123;</span><br><span class="line">    <span class="attr">position</span>: relative;</span><br><span class="line">    <span class="attr">width</span>: 200px;</span><br><span class="line">    <span class="attr">height</span>: 200px;</span><br><span class="line">    background-<span class="attr">color</span>: <span class="title function_">rgb</span>(<span class="number">118</span>, <span class="number">218</span>, <span class="number">255</span>);</span><br><span class="line">    border-<span class="attr">radius</span>: <span class="number">50</span>%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p &#123;</span><br><span class="line">    <span class="attr">position</span>: absolute;</span><br><span class="line">    <span class="attr">top</span>: <span class="number">50</span>%;</span><br><span class="line">    <span class="attr">left</span>: <span class="number">50</span>%;</span><br><span class="line">    <span class="attr">transform</span>: <span class="title function_">translate</span>(-<span class="number">50</span>%, -<span class="number">50</span>%);</span><br><span class="line">    font-<span class="attr">size</span>: 36px;</span><br><span class="line">    <span class="attr">color</span>: #<span class="number">000</span>;</span><br><span class="line">    z-<span class="attr">index</span>: <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes rotate &#123;</span><br><span class="line">   to &#123;</span><br><span class="line">        <span class="attr">transform</span>: <span class="title function_">translate</span>(-<span class="number">50</span>%, -<span class="number">70</span>%) <span class="title function_">rotate</span>(360deg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes change &#123;</span><br><span class="line">    <span class="keyword">from</span> &#123;</span><br><span class="line">        <span class="attr">top</span>: 80px;</span><br><span class="line">    &#125;</span><br><span class="line">    to &#123;</span><br><span class="line">        <span class="attr">top</span>: -120px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>完整的代码示例，你可以戳这里：</p>
<ul>
<li>CodePen Demo – Pure Css Wave Progress bar[7]</li>
<li>CodePen Demo – Pure Css Wave Progress bar Animation[8]</li>
</ul>
<h2 id="3D-进度条"><a href="#3D-进度条" class="headerlink" title="3D 进度条"></a>3D 进度条</h2><p>嗯，下面这个 3D 进度条需要对 CSS 3D 有基本的掌握。</p>
<p>你可以先看看这篇文章 – 奇思妙想 CSS 3D 动画 | 仅使用 CSS 能制作出多惊艳的动画？[9]</p>
<p>它主要是借助了一个 3D 立方体。接下来我们来实现一个立方体进度条~</p>
<p>首先，实现一个立方体，结构如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;demo-cube perspective&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;cube&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;top&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;bottom&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;front&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;back&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>我们可以把这个立方体想象成一个立体的进度条容器，通过控制 6 面的颜色，我们可以巧妙的得到一种 3D 进度条效果。</p>
<p>当然，其实我们不需要那么多面，4 个面即可，去掉左右，然后利用渐变修改一下立方体各个面的颜色，去掉 border，核心的 CSS 代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.<span class="property">demo</span>-cube &#123;</span><br><span class="line">  <span class="attr">position</span>: relative;</span><br><span class="line"></span><br><span class="line">  .<span class="property">cube</span> &#123;</span><br><span class="line">    <span class="attr">position</span>: absolute;</span><br><span class="line">    <span class="attr">top</span>: <span class="number">50</span>%;</span><br><span class="line">    <span class="attr">left</span>: <span class="number">50</span>%;</span><br><span class="line">    <span class="attr">width</span>: 300px;</span><br><span class="line">    <span class="attr">height</span>: 100px;</span><br><span class="line">    transform-<span class="attr">style</span>: preserve-3d;</span><br><span class="line">    <span class="attr">transform</span>: <span class="title function_">translate</span>(-<span class="number">50</span>%, -<span class="number">50</span>%) <span class="title function_">rotateX</span>(-<span class="number">33.</span>5deg);</span><br><span class="line"></span><br><span class="line">    li &#123;</span><br><span class="line">      <span class="attr">position</span>: absolute;</span><br><span class="line">      <span class="attr">width</span>: 300px;</span><br><span class="line">      <span class="attr">height</span>: 100px;</span><br><span class="line">      <span class="attr">background</span>: linear-<span class="title function_">gradient</span>(90deg, <span class="title function_">rgba</span>(<span class="number">156</span>, <span class="number">39</span>, <span class="number">176</span>, <span class="number">.3</span>), <span class="title function_">rgba</span>(<span class="number">255</span>, <span class="number">34</span>, <span class="number">109</span>, <span class="number">.8</span>) <span class="number">70</span>%, <span class="title function_">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">.6</span>) <span class="number">70</span>%, <span class="title function_">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">.6</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    .<span class="property">top</span> &#123;</span><br><span class="line">      <span class="attr">transform</span>: <span class="title function_">rotateX</span>(90deg) <span class="title function_">translateZ</span>(50px);</span><br><span class="line">    &#125;</span><br><span class="line">    .<span class="property">bottom</span> &#123;</span><br><span class="line">      <span class="attr">transform</span>: <span class="title function_">rotateX</span>(-90deg) <span class="title function_">translateZ</span>(50px);</span><br><span class="line">    &#125;</span><br><span class="line">    .<span class="property">front</span> &#123;</span><br><span class="line">      <span class="attr">transform</span>: <span class="title function_">translateZ</span>(50px);</span><br><span class="line">    &#125;</span><br><span class="line">    .<span class="property">back</span> &#123;</span><br><span class="line">      <span class="attr">transform</span>: <span class="title function_">rotateX</span>(-180deg) <span class="title function_">translateZ</span>(50px);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们就可以得到一个非常酷炫的 3D 进度条效果：</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<h4 id="利用-CSS-Property-给-3D-进度条加上动画"><a href="#利用-CSS-Property-给-3D-进度条加上动画" class="headerlink" title="利用 CSS Property 给 3D 进度条加上动画"></a>利用 CSS Property 给 3D 进度条加上动画</h4><p>当然，进度条嘛，它需要一个填充动画。由于我们使用的是渐变实现的进度条的进度，需要去控制其中的颜色百分比变化。</p>
<p>而正常而言，CSS 是不支持渐变的动画的，不过这也难不倒我们，因为我们可以使用 CSS @Property 。</p>
<p>简单改造一下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@property --per &#123;</span><br><span class="line">  <span class="attr">syntax</span>: <span class="string">&#x27;&lt;percentage&gt;&#x27;</span>;</span><br><span class="line">  <span class="attr">inherits</span>: <span class="literal">false</span>;</span><br><span class="line">  initial-<span class="attr">value</span>: <span class="number">0</span>%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.<span class="property">demo</span>-cube .<span class="property">cube</span> &#123;</span><br><span class="line">  .<span class="property">top</span>,</span><br><span class="line">  .<span class="property">front</span>,</span><br><span class="line">  .<span class="property">bottom</span>,</span><br><span class="line">  .<span class="property">back</span> &#123;</span><br><span class="line">    <span class="attr">background</span>: linear-<span class="title function_">gradient</span>(90deg, <span class="title function_">rgba</span>(<span class="number">255</span>, <span class="number">217</span>, <span class="number">34</span>, <span class="number">.6</span>), <span class="title function_">rgba</span>(<span class="number">255</span>, <span class="number">34</span>, <span class="number">109</span>, <span class="number">.8</span>) <span class="title function_">var</span>(--per), <span class="title function_">rgba</span>(<span class="number">255</span>, <span class="number">34</span>, <span class="number">109</span>, <span class="number">.1</span>) <span class="title function_">var</span>(--per), <span class="title function_">rgba</span>(<span class="number">255</span>, <span class="number">34</span>, <span class="number">109</span>, <span class="number">.1</span>));</span><br><span class="line">    <span class="attr">animation</span>: perChange 6s infinite;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes perChange &#123;</span><br><span class="line">  <span class="number">0</span>% &#123;</span><br><span class="line">    --<span class="attr">per</span>: <span class="number">0</span>%;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">90</span>%,</span><br><span class="line">  to &#123;</span><br><span class="line">    --<span class="attr">per</span>: <span class="number">80</span>%;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样，我们就实现了一个会动的 3D 进度条，只需要控制 <code>--per</code> CSS 自定义属性即可，效果如下：</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<blockquote>
<p>对于 CSS @Property 不算很了解的，可以看看作者的这篇文章 – CSS @property，让不可能变可能[10]，它的出现，让 CSS 极大的提升了制作各种动画的能力。</p>
</blockquote>
<p>上述的完整代码，你可以猛击这里：CSS 灵感 – 3D 立方体进度条[11]</p>
<h2 id="扩展延伸"><a href="#扩展延伸" class="headerlink" title="扩展延伸"></a>扩展延伸</h2><p>本文从简到繁介绍了使用 HTML&#x2F;CSS 逐步构建进度条的方式，并且逐渐加深了难度。</p>
<p>当然，随着难度的提升，得到的是更为酷炫的进度条。</p>
<p>基于上述的方法介绍，基本可以演化出各种我们需要的进度条。譬如基于上述的方法，可以实现一个简单的电池充电动画：</p>
<p><img src="https://alianck.oss-cn-beijing.aliyuncs.com/process15.gif" alt="图片"></p>
<p>当然，CSS 千变万化，进度条的种类肯定也不仅仅局限于上述的几类。譬如我们可以利用滤镜实现的仿华为手机的充电动画，也是一种进度条的呈现方式，也是能够使用纯 CSS 实现的：</p>
<p><img src="https://alianck.oss-cn-beijing.aliyuncs.com/process16.gif" alt="图片"></p>
<blockquote>
<p>上述效果的完整实现可以戳 – 巧用 CSS 实现酷炫的充电动画[12]</p>
</blockquote>
<p>又或者，我们可以在进度条的纹理上做文章：</p>
<p><img src="https://alianck.oss-cn-beijing.aliyuncs.com/process17.webp" alt="图片"></p>
<p>效果来源于 CodePen – Bars By Lucagaz[13]。</p>
<p>总而言之，CSS 美好世界值得我们去探索。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>好了，本文到此结束，希望本文对你有所帮助 :)</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>修改对象数组的属性（key）名</title>
    <url>/post/b9a25a07667b/</url>
    <content><![CDATA[<h2 id="修改数组对象的属性（key）名"><a href="#修改数组对象的属性（key）名" class="headerlink" title="修改数组对象的属性（key）名"></a>修改数组对象的属性（key）名</h2><p>方法一</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;小明&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&quot;小红&quot;</span> &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line"><span class="comment">//旧key到新key的映射</span></span><br><span class="line"><span class="keyword">var</span> keyMap = &#123; <span class="attr">id</span>: <span class="string">&quot;value&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;label&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> obj = array[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">var</span> newKey = keyMap[key];</span><br><span class="line">    <span class="keyword">if</span> (newKey) &#123;</span><br><span class="line">      obj[newKey] = obj[key];</span><br><span class="line">      <span class="keyword">delete</span> obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array);</span><br></pre></td></tr></table></figure>

<p>方法二</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">  &#123; <span class="attr">evaluateResult</span>: <span class="string">&quot;A类&quot;</span>, <span class="attr">evaluateTotal</span>: <span class="number">22</span>, <span class="attr">a</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">evaluateResult</span>: <span class="string">&quot;B类&quot;</span>, <span class="attr">evaluateTotal</span>: <span class="number">22</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">let</span> keyMap = &#123; <span class="attr">evaluateResult</span>: <span class="string">&quot;name&quot;</span>, <span class="attr">evaluateTotal</span>: <span class="string">&quot;value&quot;</span> &#125;;</span><br><span class="line">arr.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> objs = <span class="title class_">Object</span>.<span class="title function_">keys</span>(item).<span class="title function_">reduce</span>(<span class="function">(<span class="params">newData, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> newKey = keyMap[key] || key;</span><br><span class="line">    newData[newKey] = item[key];</span><br><span class="line">    <span class="keyword">return</span> newData;</span><br><span class="line">  &#125;, &#123;&#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(objs);</span><br><span class="line">  <span class="comment">//&#123;name: &quot;A类&quot;, value: 22, a: 1&#125;</span></span><br><span class="line">  <span class="comment">//&#123;name: &quot;B类&quot;, value: 22, b: 2&#125;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>方法三</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">categoryOption</span> = res.<span class="property">data</span>.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">value</span>: item.<span class="property">id</span>,</span><br><span class="line">            <span class="attr">label</span>: item.<span class="property">name</span>,</span><br><span class="line">            <span class="attr">children</span>: item.<span class="property">sonList</span>.<span class="title function_">map</span>(<span class="function"><span class="params">sonItem</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">value</span>: sonItem.<span class="property">id</span>,</span><br><span class="line">                <span class="attr">label</span>: sonItem.<span class="property">name</span></span><br><span class="line">              &#125;;</span><br><span class="line">            &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">categoryOption</span>);</span><br></pre></td></tr></table></figure>



<h2 id="JS-时间对象-new-Date-的常用方法"><a href="#JS-时间对象-new-Date-的常用方法" class="headerlink" title="JS 时间对象 new Date()的常用方法"></a>JS 时间对象 new Date()的常用方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="comment">//Sat May 22 2021 10:38:06 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="comment">//返回时间戳</span></span><br><span class="line">+<span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">//1621651748005</span></span><br><span class="line"><span class="title class_">Date</span>.<span class="title function_">now</span>();<span class="comment">//1621651748005</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()<span class="comment">//1621651748005</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toJSON</span>(), <span class="comment">//2021-05-22T02:38:06.765Z</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toISOString</span>(), <span class="comment">//2021-05-22T02:38:06.765Z</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toDateString</span>(), <span class="comment">//Sat May 22 2021</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toLocaleString</span>(), <span class="comment">//2021/5/22上午10:38:06</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toLocaleDateString</span>(), <span class="comment">//2021/5/22</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toLocaleTimeString</span>(), <span class="comment">//&quot;上午10:40:24&quot;</span></span><br><span class="line"><span class="comment">//加参数的</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1621541748005</span>).<span class="title function_">toLocaleString</span>()<span class="comment">//2021/5/21上午4:15:48</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">getDate</span>()获取当前日期对象是几日(<span class="number">1</span>-<span class="number">31</span>)</span><br><span class="line"><span class="title function_">getDay</span>()获取当前日期对象是周几(返回<span class="number">0</span>-<span class="number">6.0</span>表示周日<span class="number">.1</span>表示周一)</span><br><span class="line"><span class="title function_">getMonth</span>()获取当前月份(<span class="number">0</span>-<span class="number">11.0</span>表示一月<span class="number">.11</span>表示<span class="number">12</span>月)</span><br><span class="line"><span class="title function_">geFullYear</span>()获取当前年份</span><br><span class="line"><span class="title function_">geHours</span>()获取小时(<span class="number">0</span>-<span class="number">23</span>)</span><br><span class="line"><span class="title function_">geMinutes</span>()获取分钟(<span class="number">0</span>-<span class="number">59</span>)</span><br><span class="line"><span class="title function_">geSeconds</span>()获取秒数(<span class="number">0</span>-<span class="number">59</span>)</span><br><span class="line"><span class="title function_">geMilliseconds</span>()获取毫秒数</span><br></pre></td></tr></table></figure>

<h2 id="js-base64-转二进制-Blog-大对象"><a href="#js-base64-转二进制-Blog-大对象" class="headerlink" title="js base64 转二进制 Blog 大对象"></a>js base64 转二进制 Blog 大对象</h2><p>imgURL &#x3D; canvas.toDataURL(“image&#x2F;png”);&#x2F;&#x2F;返回的是 data:image&#x2F;png;base64,iVBORxxxx…<br>imgURL&#x3D;URL.createObjectURL(&#x2F;blob&#x2F;对象);&#x2F;&#x2F;返回的是 data:image&#x2F;png;base64,iVBORxxxx…</p>
<p>下面是将 base64 的 URL 转换成 Blob 对象<br>1.Base64 转文件格式大小（带有前缀的截取，比如 data:application&#x2F;pdf;base64,JVEwxxx…）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">base64toBlob</span>(<span class="params">dataurl, filename</span>) &#123;</span><br><span class="line">  将base64转换为文件;</span><br><span class="line">  <span class="keyword">var</span> arr = dataurl.<span class="title function_">split</span>(<span class="string">&quot;,&quot;</span>),</span><br><span class="line">    mime = arr[<span class="number">0</span>].<span class="title function_">match</span>(<span class="regexp">/:(.*?);/</span>)[<span class="number">1</span>],</span><br><span class="line">    bstr = <span class="title function_">atob</span>(arr[<span class="number">1</span>]),</span><br><span class="line">    n = bstr.<span class="property">length</span>,</span><br><span class="line">    u8arr = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(n);</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    u8arr[n] = bstr.<span class="title function_">charCodeAt</span>(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">File</span>([u8arr], filename, &#123; <span class="attr">type</span>: mime &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.Base64 转 blob 格式大小（不用处理前缀）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">base64toBlob</span>(<span class="params">base64, type</span>) &#123;</span><br><span class="line">  <span class="comment">// 将base64转为Unicode规则编码</span></span><br><span class="line">  (bstr = <span class="title function_">atob</span>(base64, type)), (n = bstr.<span class="property">length</span>), (u8arr = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(n));</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    u8arr[n] = bstr.<span class="title function_">charCodeAt</span>(n); <span class="comment">// 转换编码后才可以使用charCodeAt 找到Unicode编码</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Blob</span>([u8arr], &#123;</span><br><span class="line">    type,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下载图片</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">a.<span class="property">download</span> = <span class="string">&quot;image&quot;</span>;</span><br><span class="line">a.<span class="property">href</span> = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(blob);</span><br><span class="line">a.<span class="title function_">click</span>();</span><br><span class="line"><span class="variable constant_">URL</span>.<span class="title function_">revokeObjectURL</span>(blob);</span><br><span class="line"></span><br><span class="line"><span class="comment">//html2canvas(canvasID).then()插件可实现截图效果</span></span><br></pre></td></tr></table></figure>

<h2 id="vue-中的-render-函数介绍"><a href="#vue-中的-render-函数介绍" class="headerlink" title="vue 中的 render 函数介绍"></a>vue 中的 render 函数介绍</h2><p>使用 render 函数描述虚拟 DOM 时，vue 提供一个函数，这个函数是就构建虚拟 DOM 所需要的工具。官网上给他起了个名字叫 createElement。还有约定的简写叫 h,</p>
<p>vm 中有一个方法_c,也是这个函数的别名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * render: 渲染函数</span></span><br><span class="line"><span class="comment">  * 参数: createElement</span></span><br><span class="line"><span class="comment">  * 参数类型: Function</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="attr">render</span>: <span class="keyword">function</span> (<span class="params">createElement</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> _this = <span class="variable language_">this</span>[<span class="string">&#x27;$options&#x27;</span>].<span class="property">parent</span>	<span class="comment">// 我这个是在 .vue 文件的 components 中写的，这样写才能访问this</span></span><br><span class="line">   <span class="keyword">let</span> _header = _this.<span class="property">$slots</span>.<span class="property">header</span>   	<span class="comment">// $slots: vue中所有分发插槽，不具名的都在default里</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * createElement 本身也是一个函数，它有三个参数</span></span><br><span class="line"><span class="comment">    * 返回值: VNode，即虚拟节点</span></span><br><span class="line"><span class="comment">    * 1. 一个 HTML 标签字符串，组件选项对象，或者解析上述任何一种的一个 async 异步函数。必需参数。&#123;String | Object | Function&#125; - 就是你要渲染的最外层标签</span></span><br><span class="line"><span class="comment">    * 2. 一个包含模板相关属性的数据对象你可以在 template 中使用这些特性。可选参数。&#123;Object&#125; - 1中的标签的属性</span></span><br><span class="line"><span class="comment">    * 3. 子虚拟节点 (VNodes)，由 `createElement()` 构建而成，也可以使用字符串来生成“文本虚拟节点”。可选参数。&#123;String | Array&#125; - 1的子节点，可以用 createElement() 创建，文本节点直接写就可以</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">return</span> <span class="title function_">createElement</span>(</span><br><span class="line">     <span class="comment">// 1. 要渲染的标签名称：第一个参数【必需】</span></span><br><span class="line">     <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">     <span class="comment">// 2. 1中渲染的标签的属性，详情查看文档：第二个参数【可选】</span></span><br><span class="line">     &#123;</span><br><span class="line">       <span class="attr">style</span>: &#123;</span><br><span class="line">         <span class="attr">color</span>: <span class="string">&#x27;#333&#x27;</span>,</span><br><span class="line">         <span class="attr">border</span>: <span class="string">&#x27;1px solid #ccc&#x27;</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="comment">// 3. 1中渲染的标签的子元素数组：第三个参数【可选】</span></span><br><span class="line">     [</span><br><span class="line">       <span class="string">&#x27;text&#x27;</span>,   <span class="comment">// 文本节点直接写就可以</span></span><br><span class="line">       _this.<span class="property">$slots</span>.<span class="property">default</span>,  <span class="comment">// 所有不具名插槽，是个数组</span></span><br><span class="line">       <span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>, _header)   <span class="comment">// createElement()创建的VNodes</span></span><br><span class="line">     ]</span><br><span class="line">   )</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>就是说 createElement（params1，params2，params3）接受三个参数，每个参数的类型官方介绍已经说明<br><strong>render 函数的用法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">render</span>: <span class="function">(<span class="params">h</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&quot;div&quot;</span>, &#123;</span><br><span class="line">    <span class="comment">//给div绑定value属性</span></span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">value</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    &#125;, <span class="comment">//给div绑定样式</span></span><br><span class="line">    <span class="attr">style</span>: &#123;</span><br><span class="line">      <span class="attr">width</span>: <span class="string">&quot;30px&quot;</span>,</span><br><span class="line">    &#125;, <span class="comment">//给div绑定点击事件</span></span><br><span class="line">    <span class="attr">on</span>: &#123;</span><br><span class="line">      <span class="attr">click</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;点击事件&quot;</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常用的轮子</title>
    <url>/post/fef193614e35/</url>
    <content><![CDATA[<h2 id="React-UI-组件库"><a href="#React-UI-组件库" class="headerlink" title="React UI 组件库"></a>React UI 组件库</h2><ul>
<li><a href="https://ant.design/">Ant Design</a></li>
<li><a href="https://react-bootstrap.github.io/">React Bootstrap</a></li>
<li><a href="https://material-ui.com/">MATERIAL-UI</a></li>
</ul>
<h2 id="Vue-UI组件库"><a href="#Vue-UI组件库" class="headerlink" title="Vue UI组件库"></a>Vue UI组件库</h2><ul>
<li><a href="https://element.eleme.io/#/zh-CN">Element UI</a> PC端</li>
<li><a href="https://youzan.github.io/vant/#/zh-CN/">Vant</a> 移动端</li>
<li><a href="https://www.iviewui.com/">View UI</a></li>
</ul>
<h2 id="常用效果组件"><a href="#常用效果组件" class="headerlink" title="常用效果组件"></a>常用效果组件</h2><ul>
<li><a href="https://animate.style/">Animate.css</a> 动画库</li>
<li><a href="https://www.swiper.com.cn/">Swiper</a> 轮播组件</li>
<li><a href="http://www.mescroll.com/">mescroll</a> 下拉刷新和上拉加载框架-基于原生JS</li>
</ul>
<h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><ul>
<li><a href="https://www.lodashjs.com/">Lodash.js</a></li>
<li><a href="https://dayjs.fenxianglu.cn/">Day.js</a> 处理日期</li>
<li><a href="https://github.com/hustcc/timeago.js">Timeago.js</a> 相对时间，如N小时前</li>
<li><a href="https://echarts.apache.org/zh/index.html">Echarts</a> 百度图表</li>
<li><a href="https://pandao.github.io/editor.md/">Meditor.md</a> 开源在线 Markdown 编辑器</li>
<li><a href="https://github.com/validatorjs/validator.js">validator.js</a> 验证库</li>
</ul>
<h2 id="Vue工具类"><a href="#Vue工具类" class="headerlink" title="Vue工具类"></a>Vue工具类</h2><ul>
<li><a href="https://www.itxst.com/vue-draggable/tutorial.html">vue-draggable</a> 基于Sortable.js实现的vue拖拽插件</li>
<li><a href="https://www.npmjs.com/package/vue-qr">vue-qr</a> 文本转二维码</li>
<li><a href="https://github.com/xyxiao001/vue-cropper">vue-cropper</a> 图片裁剪插件</li>
<li><a href="https://www.npmjs.com/package/vue-lazyload">vue-lazyload</a> 懒加载</li>
<li><a href="https://github.com/saivarunk/vue-simple-upload">vue-simple-upload</a> 上传组件</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><a href="https://github.com/linjc/smooth-signature">H5带笔锋手写签名，支持PC端和移动端</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>多种数组去重性能对比</title>
    <url>/post/a332e335877a/</url>
    <content><![CDATA[<h1 id="多种数组去重性能对比"><a href="#多种数组去重性能对比" class="headerlink" title="多种数组去重性能对比"></a>多种数组去重性能对比</h1><h2 id="测试模板"><a href="#测试模板" class="headerlink" title="测试模板"></a>测试模板</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 1 ~ 10w 的数组，Array.from为ES6语法</span></span><br><span class="line"><span class="keyword">let</span> arr1 = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1000000</span>), <span class="function">(<span class="params">x, index</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> index</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">500000</span>), <span class="function">(<span class="params">x, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> index + index</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> start = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始数组去重&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组去重</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">distinct</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = a.<span class="title function_">concat</span>(b);</span><br><span class="line">  <span class="comment">// 去重方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;去重后的长度&#x27;</span>, <span class="title function_">distinct</span>(arr1, arr2).<span class="property">length</span>)</span><br><span class="line"><span class="keyword">let</span> end = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;耗时&#x27;</span>, end - start + <span class="string">&#x27;ms&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 1 ~ 10w 的数组，Array.from为ES6语法</span></span><br><span class="line"><span class="keyword">let</span> arr1 = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1000000</span>), <span class="function">(<span class="params">x, index</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> index</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">500000</span>), <span class="function">(<span class="params">x, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> index + index</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> start = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始数组去重&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组去重</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">distinct</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = a.<span class="title function_">concat</span>(b);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 方法1，耗时约11675ms，约11s</span></span><br><span class="line">  <span class="comment">// return arr.filter((item, index) =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//   return arr.indexOf(item) === index</span></span><br><span class="line">  <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方法2，耗时约22851ms，约22s，性能最差</span></span><br><span class="line">  <span class="comment">// for (let i = 0, len = arr.length; i &lt; len; i++) &#123;</span></span><br><span class="line">  <span class="comment">//   for (let j = i + 1; j &lt; len; j++) &#123;</span></span><br><span class="line">  <span class="comment">//     if (arr[i] == arr[j]) &#123;</span></span><br><span class="line">  <span class="comment">//       arr.splice(j, 1);</span></span><br><span class="line">  <span class="comment">//       // splice 会改变数组长度，所以要将数组长度 len 和下标 j 减一</span></span><br><span class="line">  <span class="comment">//       len--;</span></span><br><span class="line">  <span class="comment">//       j--;</span></span><br><span class="line">  <span class="comment">//     &#125;</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="comment">// return arr</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//方法3，耗时约12789ms，约12s，和方法1相当</span></span><br><span class="line">  <span class="comment">// let result = []</span></span><br><span class="line">  <span class="comment">// for (let i of arr) &#123;</span></span><br><span class="line">  <span class="comment">//   !result.includes(i) &amp;&amp; result.push(i)</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="comment">// return result</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//方法4，耗时约23ms，ES5标准中性能最高</span></span><br><span class="line">  <span class="comment">// arr = arr.sort()</span></span><br><span class="line">  <span class="comment">// let result = [arr[0]]</span></span><br><span class="line">  <span class="comment">// for (let i = 1, len = arr.length; i &lt; len; i++) &#123;</span></span><br><span class="line">  <span class="comment">//   arr[i] !== arr[i - 1] &amp;&amp; result.push(arr[i])</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="comment">// return result</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方法5，ES6的Set数据结构，耗时约20ms，性能高，代码简洁</span></span><br><span class="line">  <span class="comment">// return Array.from(new Set([...a, ...b]))</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方法6，耗时约16ms，所有方法中 性能最高！ (千万级数据量下效率比方法5高4倍，for...of 为ES6语法)</span></span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj[i]) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(i)</span><br><span class="line">      obj[i] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;去重后的长度&#x27;</span>, <span class="title function_">distinct</span>(arr1, arr2).<span class="property">length</span>)</span><br><span class="line"><span class="keyword">let</span> end = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;耗时&#x27;</span>, end - start + <span class="string">&#x27;ms&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>ES5标准中性能最高的数组去重方法为:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 耗时约23ms</span></span><br><span class="line">arr = arr.<span class="title function_">sort</span>()</span><br><span class="line"><span class="keyword">let</span> result = [arr[<span class="number">0</span>]]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>, len = arr.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">    arr[i] !== arr[i - <span class="number">1</span>] &amp;&amp; result.<span class="title function_">push</span>(arr[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>ES6标准中性能最高的数组去重方法为:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 耗时约16ms (千万级数据量下效率比使用Set数据结构方法高4倍，for...of 为ES6语法)</span></span><br><span class="line"><span class="keyword">let</span> result = []</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj[i]) &#123;</span><br><span class="line">        result.<span class="title function_">push</span>(i)</span><br><span class="line">        obj[i] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>代码既简洁性能又相对高的去重方法为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 耗时约20ms，性能高，代码简洁</span></span><br><span class="line"><span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>([...a, ...b]))</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>图片加载不出来，使用默认图片的三种方法</title>
    <url>/post/a07779cfb79d/</url>
    <content><![CDATA[<h2 id="vue-自定义指令，图片加载不出来，使用默认图片的三种方法"><a href="#vue-自定义指令，图片加载不出来，使用默认图片的三种方法" class="headerlink" title="vue 自定义指令，图片加载不出来，使用默认图片的三种方法"></a>vue 自定义指令，图片加载不出来，使用默认图片的三种方法</h2><h3 id="一、常规解决方法"><a href="#一、常规解决方法" class="headerlink" title="一、常规解决方法"></a>一、常规解决方法</h3><p>我们都知道，img 标签支持 onerror 事件，在装载文档或图像的过程中如果发生了错误，就会触发 onerror 事件。可以使用一张提示错误的图片代替显示不了的图片。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;images/logo.png&quot;</span> onerror=<span class="string">&quot;javascript:this.src=&#x27;images/logoError.png&#x27;;&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>当图片不存在时，将触发 onerror，而 onerror 中又为 img 指定一个 logoError.png 图片。也就是说图片存在则显示 logo.png，图片不存在将显示 logoError.png。<br>但是，注意哦，这里有个大坑哦，如果 logoError.png 也不存在，则会继续触发 onerror，导致死循环，页面卡死。而且，就算图片存在，但网络很不通畅，也可能触发 onerror。<br>当然，解决办法是有的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;images/logo.png&quot;</span> onerror=<span class="string">&quot;notfound();&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">notfound</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> img = event.<span class="property">srcElement</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        img.<span class="property">src</span> = <span class="string">&quot;images/logoError.png&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        img.<span class="property">onerror</span> = <span class="literal">null</span>; <span class="comment">//解绑onerror事件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="二、通过vue绑定-onerror-实现"><a href="#二、通过vue绑定-onerror-实现" class="headerlink" title="二、通过vue绑定 onerror 实现"></a>二、通过<a href="https://so.csdn.net/so/search?from=pc_blog_highlight&q=vue">vue</a>绑定 onerror 实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 本质上跟第一种方法是差不多的,这里也会遇到跟第一种方法类似的问题，当默认图也不存在时，图片加载死循环。</span></span><br><span class="line">&lt;img :src=<span class="string">&quot;images/logo.png&quot;</span> :onerror=<span class="string">&quot;defaultImg&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">name</span>: <span class="string">&quot;imgError&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="attr">defaultImg</span>: <span class="string">&#x27;this.src=&quot;&#x27;</span> + <span class="built_in">require</span>(<span class="string">&#x27;images/logoError.png&#x27;</span>) + <span class="string">&#x27;&quot;&#x27;</span> <span class="comment">//默认图地址</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="三、通过-vue-自定义指令"><a href="#三、通过-vue-自定义指令" class="headerlink" title="三、通过 vue 自定义指令"></a>三、通过 vue 自定义指令</h3><p>使用 vue 的指令都感觉好爽，特别的方便，现在自己搞一个，用起来会更爽。</p>
<p>在这之前，先了解下 vue 的自定义指令到底怎么玩，还是很有必要的。<br>这种东西呢，还是看文档吧，文档写得挺详细的。<a href="https://cn.vuejs.org/v2/guide/custom-directive.html">vue 指令</a>。</p>
<p>demo1:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局注册自定义指令，用于判断当前图片是否能够加载成功，可以加载成功则赋值为img的src属性，否则使用默认图片</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&quot;real-img&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">el, binding</span>) &#123;</span><br><span class="line">  <span class="comment">//指令名称为：real-img</span></span><br><span class="line">  <span class="keyword">let</span> imgURL = binding.<span class="property">value</span>; <span class="comment">//获取图片地址</span></span><br><span class="line">  <span class="keyword">if</span> (imgURL) &#123;</span><br><span class="line">    <span class="keyword">let</span> exist = <span class="keyword">await</span> <span class="title function_">imageIsExist</span>(imgURL);</span><br><span class="line">    <span class="keyword">if</span> (exist) &#123;</span><br><span class="line">      el.<span class="title function_">setAttribute</span>(<span class="string">&quot;src&quot;</span>, imgURL);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检测图片是否存在</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">url</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> imageIsExist = <span class="keyword">function</span> (<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">    img.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">complete</span> == <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="literal">true</span>);</span><br><span class="line">        img = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    img.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="literal">false</span>);</span><br><span class="line">      img = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    img.<span class="property">src</span> = url;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后使用的时候就特别方便了，因为是全局注册的，所以每个页面都可以直接使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!--v-real-img 就是刚刚定义的指令，绑定的为真实要显示的图片地址。src为默认图片地址--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/logoError.png&quot;</span> <span class="attr">v-real-img</span>=<span class="string">&quot;images/logo.png&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>使用这种方法还有一个天然的优势，那就是当网速较慢或者图片一次性加载较多的话，可以达到占位图的效果。</p>
<p>demo2:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;errorimg&#x27;</span> ,&#123;</span><br><span class="line">	<span class="comment">//执行时机：绑定了当前指令的元素的所有属性和事件</span></span><br><span class="line">	<span class="title function_">inserted</span>(<span class="params">el</span>)&#123;</span><br><span class="line">		<span class="comment">//获取的是真是的dom元素，可以使用dom的所有事件</span></span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(el)</span><br><span class="line">		el.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">			<span class="comment">//将默认图片赋值给el.src属性</span></span><br><span class="line">			el.<span class="property">src</span> = <span class="string">&#x27;默认图片地址&#x27;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;，</span><br><span class="line">	<span class="comment">//如果有分页，会在第二页的不会渲染，这个时候我们就换个函数</span></span><br><span class="line">	<span class="attr">componentUpdated</span>: <span class="keyword">function</span> (<span class="params">el</span>) &#123;</span><br><span class="line">		el.<span class="property">src</span> = <span class="string">&#x27;默认图片地址&#x27;</span></span><br><span class="line">	&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>自定义指令简写</strong><br>在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子。可以简写为:<br>全局</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&quot;color&quot;</span>, <span class="keyword">function</span> (<span class="params">el, binding</span>) &#123;</span><br><span class="line">  el.<span class="property">style</span>.<span class="property">backgroundColor</span> = binding.<span class="property">value</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>局部</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">directives</span>: &#123;</span><br><span class="line">        <span class="string">&quot;fontweight&quot;</span>:</span><br><span class="line">        	<span class="keyword">function</span> (<span class="params">el, binding</span>) &#123;</span><br><span class="line">             	el.<span class="property">style</span>.<span class="property">fontWeight</span> = binding.<span class="property">value</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>常用meta整理</title>
    <url>/post/709a013c850b/</url>
    <content><![CDATA[<h1 id="常用meta整理"><a href="#常用meta整理" class="headerlink" title="常用meta整理"></a>常用meta整理</h1><h2 id="元素"><a href="#元素" class="headerlink" title="&lt;meta&gt; 元素"></a>&lt;meta&gt; 元素</h2><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>meta标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。</p>
<p><strong>必要属性</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>content</td>
<td>some text</td>
<td>定义与http-equiv或name属性相关的元信息</td>
</tr>
</tbody></table>
<p><strong>可选属性</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>http-equiv</td>
<td>content-type &#x2F; expire &#x2F; refresh &#x2F; set-cookie</td>
<td>把content属性关联到HTTP头部。</td>
</tr>
<tr>
<td>name</td>
<td>author &#x2F; description &#x2F; keywords &#x2F; generator &#x2F; revised &#x2F; others</td>
<td>把 content 属性关联到一个name。</td>
</tr>
<tr>
<td>content</td>
<td>some text</td>
<td>定义用于翻译 content 属性值的格式。</td>
</tr>
</tbody></table>
<h3 id="网页相关"><a href="#网页相关" class="headerlink" title="网页相关"></a>网页相关</h3><ul>
<li><strong>申明编码</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&#x27;utf-8&#x27;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优先使用 IE 最新版本和 Chrome</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 关于X-UA-Compatible --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge,chrome=1&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 推荐 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=6&quot;</span> &gt;</span><span class="comment">&lt;!-- 使用IE6 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=7&quot;</span> &gt;</span><span class="comment">&lt;!-- 使用IE7 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=8&quot;</span> &gt;</span><span class="comment">&lt;!-- 使用IE8 --&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>浏览器内核控制</strong>：国内浏览器很多都是双内核（webkit和Trident），webkit内核高速浏览，IE内核兼容网页和旧版网站。而添加meta标签的网站可以控制浏览器选择何种内核渲染。<a href="http://se.360.cn/v6/help/meta.html">参考文档</a></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">默认用极速核(Chrome)：<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;renderer&quot;</span> <span class="attr">content</span>=<span class="string">&quot;webkit&quot;</span>&gt;</span></span><br><span class="line">默认用ie兼容内核（IE6/7）：<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;renderer&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie-comp&quot;</span>&gt;</span></span><br><span class="line">默认用ie标准内核（IE9/IE10/IE11/取决于用户的IE）：<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;renderer&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie-stand&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>国内双核浏览器默认内核模式如下：</p>
<ol>
<li>搜狗高速浏览器、QQ浏览器：IE内核（兼容模式）</li>
<li>360极速浏览器、遨游浏览器：Webkit内核（极速模式）</li>
</ol>
<ul>
<li><strong>禁止浏览器从本地计算机的缓存中访问页面内容</strong>：这样设定，访问者将无法脱机浏览。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Pragma&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-cache&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Windows 8</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;msapplication-TileColor&quot;</span> <span class="attr">content</span>=<span class="string">&quot;#000&quot;</span>/&gt;</span> <span class="comment">&lt;!-- Windows 8 磁贴颜色 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;msapplication-TileImage&quot;</span> <span class="attr">content</span>=<span class="string">&quot;icon.png&quot;</span>/&gt;</span> <span class="comment">&lt;!-- Windows 8 磁贴图标 --&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>站点适配</strong>：主要用于PC-手机页的对应关系。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;mobile-agent&quot;</span><span class="attr">content</span>=<span class="string">&quot;format=[wml|xhtml|html5]; url=url&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">[wml|xhtml|html5]根据手机页的协议语言，选择其中一种；</span></span><br><span class="line"><span class="comment">url=&quot;url&quot; 后者代表当前PC页所对应的手机页URL，两者必须是一一对应关系。</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>转码申明</strong>：用百度打开网页可能会对其进行转码（比如贴广告），避免转码可添加如下meta。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Cache-Control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-siteapp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>





<h3 id="SEO优化"><a href="#SEO优化" class="headerlink" title="SEO优化"></a>SEO优化</h3><p><a href="http://msdn.microsoft.com/zh-cn/library/ff724016">参考文档</a></p>
<ul>
<li><strong>页面关键词</strong>，每个网页应具有描述该网页内容的一组唯一的关键字。<br>使用人们可能会搜索，并准确描述网页上所提供信息的描述性和代表性关键字及短语。标记内容太短，则搜索引擎可能不会认为这些内容相关。另外标记不应超过 874 个字符。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;your tags&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>页面描述</strong>，每个网页都应有一个不超过 150 个字符且能准确反映网页内容的描述标签。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;150 words&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>搜索引擎索引方式</strong>，robotterms是一组使用逗号(,)分割的值，通常有如下几种取值：none，noindex，nofollow，all，index和follow。确保正确使用nofollow和noindex属性值。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;index,follow&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    all：文件将被检索，且页面上的链接可以被查询；</span></span><br><span class="line"><span class="comment">    none：文件将不被检索，且页面上的链接不可以被查询；</span></span><br><span class="line"><span class="comment">    index：文件将被检索；</span></span><br><span class="line"><span class="comment">    follow：页面上的链接可以被查询；</span></span><br><span class="line"><span class="comment">    noindex：文件将不被检索；</span></span><br><span class="line"><span class="comment">    nofollow：页面上的链接不可以被查询。</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>页面重定向和刷新</strong>：content内的数字代表时间（秒），既多少时间后刷新。如果加url,则会重定向到指定网页（搜索引擎能够自动检测，也很容易被引擎视作误导而受到惩罚）。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;0;url=&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>其他</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;author name&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 定义网页作者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;google&quot;</span> <span class="attr">content</span>=<span class="string">&quot;index,follow&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;googlebot&quot;</span> <span class="attr">content</span>=<span class="string">&quot;index,follow&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;verify&quot;</span> <span class="attr">content</span>=<span class="string">&quot;index,follow&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="移动设备"><a href="#移动设备" class="headerlink" title="移动设备"></a>移动设备</h3><ul>
<li><strong>viewport</strong>：能优化移动浏览器的显示。如果不是响应式网站，不要使用initial-scale或者禁用缩放。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0,minimun-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这是常用的移动meta设置--&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>width：宽度（数值 &#x2F; device-width）（范围从200 到10,000，默认为980 像素）</li>
<li>height：高度（数值 &#x2F; device-height）（范围从223 到10,000）</li>
<li>initial-scale：初始的缩放比例 （范围从&gt;0 到10）</li>
<li>minimum-scale：允许用户缩放到的最小比例</li>
<li>maximum-scale：允许用户缩放到的最大比例</li>
<li>user-scalable：用户是否可以手动缩 (no,yes)</li>
</ol>
<p><strong>注意</strong>，很多人使用initial-scale&#x3D;1到非响应式网站上，这会让网站以100%宽度渲染，用户需要手动移动页面或者缩放。如果和initial-scale&#x3D;1同时使用user-scalable&#x3D;no或maximum-scale&#x3D;1，则用户将不能放大&#x2F;缩小网页来看到全部的内容。</p>
<ul>
<li><strong>WebApp全屏模式</strong>：伪装app，离线应用。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;apple-mobile-web-app-capable&quot;</span> <span class="attr">content</span>=<span class="string">&quot;yes&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 启用 WebApp 全屏模式 --&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>主题颜色</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;theme-color&quot;</span> <span class="attr">content</span>=<span class="string">&quot;#11a8cd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/xugaoyi/image_store/blog/20200221134927.jpg"></p>
<ul>
<li><strong>隐藏状态栏&#x2F;设置状态栏颜色</strong>：只有在开启WebApp全屏模式时才生效。content的值为default | black | black-translucent 。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;apple-mobile-web-app-status-bar-style&quot;</span> <span class="attr">content</span>=<span class="string">&quot;black-translucent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>添加到主屏后的标题</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;apple-mobile-web-app-title&quot;</span> <span class="attr">content</span>=<span class="string">&quot;标题&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>忽略数字自动识别为电话号码</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">&quot;telephone=no&quot;</span> <span class="attr">name</span>=<span class="string">&quot;format-detection&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>忽略识别邮箱</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">&quot;email=no&quot;</span> <span class="attr">name</span>=<span class="string">&quot;format-detection&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>添加智能 App 广告条 Smart App Banner</strong>：告诉浏览器这个网站对应的app，并在页面上显示下载banner(如下图)。<a href="https://developer.apple.com/library/ios/documentation/AppleApplications/Reference/SafariWebContent/PromotingAppswithAppBanners/PromotingAppswithAppBanners.html">参考文档</a></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;apple-itunes-app&quot;</span> <span class="attr">content</span>=<span class="string">&quot;app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/xugaoyi/image_store/blog/20200221134638.png"></p>
<ul>
<li><strong>其他</strong> <a href="http://fex.baidu.com/blog/2014/10/html-head-tags/?qq-pf-to=pcqq.c2c">参考文档</a></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;HandheldFriendly&quot;</span> <span class="attr">content</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 微软的老式浏览器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;MobileOptimized&quot;</span> <span class="attr">content</span>=<span class="string">&quot;320&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- uc强制竖屏 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;screen-orientation&quot;</span> <span class="attr">content</span>=<span class="string">&quot;portrait&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- QQ强制竖屏 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;x5-orientation&quot;</span> <span class="attr">content</span>=<span class="string">&quot;portrait&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- UC强制全屏 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;full-screen&quot;</span> <span class="attr">content</span>=<span class="string">&quot;yes&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- QQ强制全屏 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;x5-fullscreen&quot;</span> <span class="attr">content</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- UC应用模式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;browsermode&quot;</span> <span class="attr">content</span>=<span class="string">&quot;application&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- QQ应用模式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;x5-page-mode&quot;</span> <span class="attr">content</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- windows phone 点击无高光 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;msapplication-tap-highlight&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="一个常用的移动端页面meta设置"><a href="#一个常用的移动端页面meta设置" class="headerlink" title="一个常用的移动端页面meta设置"></a>一个常用的移动端页面meta设置</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0,minimun-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>手摸手教你撸一个脚手架</title>
    <url>/post/ed0f5522714b/</url>
    <content><![CDATA[<h2 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h2><p>vue-cli, create-react-app、react-native-cli 等都是非常优秀的脚手架，通过脚手架，我们可以快速初始化一个项目，无需自己从零开始一步步配置，有效提升开发体验。尽管这些脚手架非常优秀，但是未必是符合我们的实际应用的，我们可以定制一个属于自己的脚手架(或公司通用脚手架)，来提升自己的开发效率。</p>
<blockquote>
<p>脚手架的作用</p>
</blockquote>
<ul>
<li>减少重复性的工作，不需要复制其他项目再删除无关代码，或者从零创建一个项目和文件。</li>
<li>可以根据交互动态生成项目结构和配置文件。</li>
<li>多人协作更为方便，不需要把文件传来传去。</li>
</ul>
<h2 id="实现的功能"><a href="#实现的功能" class="headerlink" title="实现的功能"></a>实现的功能</h2><p>在开始之前，我们需要明确自己的脚手架需要哪些功能。vue init template-name project-name 、create-react-app project-name。我们这次编写的脚手架(eos-cli)具备以下能力(脚手架的名字爱叫啥叫啥，随便写):</p>
<ul>
<li>eos init template-name project-name 根据远程模板，初始化一个项目(远程模板可配置)</li>
<li>eos config set <key> <value> 修改配置信息</li>
<li>eos config get [<key>] 查看配置信息</li>
<li>eos –version 查看当前版本号</li>
<li>eos -h</li>
</ul>
<p>大家可以自行扩展其它的 commander，本篇文章旨在教大家如何实现一个脚手架。</p>
<p>本项目完整代码请戳: <a href="https://github.com/ytking/eos-cli">https://github.com/ytking/eos-cli</a></p>
<p>或</p>
<p>本项目完整代码请戳: <a href="https://github.com/ytking/yang-cli">https://github.com/ytking/yang-cli</a></p>
<h2 id="需要使用的第三方库"><a href="#需要使用的第三方库" class="headerlink" title="需要使用的第三方库"></a>需要使用的第三方库</h2><ul>
<li>babel-cli&#x2F;babel-env: 语法转换</li>
<li>commander: 命令行工具</li>
<li>download-git-repo: 用来下载远程模板</li>
<li>ini: 格式转换</li>
<li>inquirer: 交互式命令行工具</li>
<li>ora: 显示loading动画</li>
<li>chalk: 修改控制台输出内容样式</li>
<li>log-symbols: 显示出 √ 或 × 等的图标</li>
</ul>
<p>关于这些第三方库的说明，可以直接npm上查看相应的说明，此处不一一展开。</p>
<h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p>创建一个空项目(eos-cli)，使用 npm init 进行初始化。</p>
<p><strong>安装依赖</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install babel-cli babel-env chalk commander download-git-repo ini inquirer log-symbols ora</span><br></pre></td></tr></table></figure>
<p><strong>目录结构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── bin</span><br><span class="line">│   └── www             //可执行文件</span><br><span class="line">├── dist</span><br><span class="line">    ├── ...             //生成文件</span><br><span class="line">└── src</span><br><span class="line">    ├── config.js       //管理eos配置文件</span><br><span class="line">    ├── index.js        //主流程入口文件</span><br><span class="line">    ├── init.js         //init command</span><br><span class="line">    ├── main.js         //入口文件</span><br><span class="line">    └── utils</span><br><span class="line">        ├── constants.js //定义常量</span><br><span class="line">        ├── get.js       //获取模板</span><br><span class="line">        └── rc.js        //配置文件</span><br><span class="line">├── .babelrc             //babel配置文件</span><br><span class="line">├── package.json</span><br><span class="line">├── README.md</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>babel 配置</strong></p>
<p>开发使用了ES6语法，使用 babel 进行转义，</p>
<blockquote>
<p>.bablerc</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;: [</span><br><span class="line">        [</span><br><span class="line">            &quot;env&quot;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;targets&quot;: &#123;</span><br><span class="line">                    &quot;node&quot;: &quot;current&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>eos 命令</strong></p>
<p>node.js 内置了对命令行操作的支持，package.json 中的 bin 字段可以定义命令名和关联的执行文件。在 package.json 中添加 bin 字段</p>
<blockquote>
<p>package.json</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;eos-cli&quot;</span>,</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;description&quot;</span>: <span class="string">&quot;脚手架&quot;</span>,</span><br><span class="line">    <span class="string">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;bin&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;eos&quot;</span>: <span class="string">&quot;./bin/www&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;compile&quot;</span>: <span class="string">&quot;babel src -d dist&quot;</span>,</span><br><span class="line">        <span class="string">&quot;watch&quot;</span>: <span class="string">&quot;npm run compile -- --watch&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>www 文件</p>
</blockquote>
<p>行首加入一行 #!&#x2F;usr&#x2F;bin&#x2F;env node 指定当前脚本由node.js进行解析</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /usr/bin/env node</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;../dist/main.js&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>链接到全局环境</strong></p>
<p>开发过程中为了方便调试，在当前的 eos-cli 目录下执行 npm link，将 eos 命令链接到全局环境。</p>
<p><strong>启动项目</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm run watch</span><br></pre></td></tr></table></figure>
<h2 id="处理命令行"><a href="#处理命令行" class="headerlink" title="处理命令行"></a>处理命令行</h2><p>利用 commander 来处理命令行。</p>
<p>main</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> program <span class="keyword">from</span> <span class="string">&#x27;commander&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">VERSION</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./utils/constants&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> apply <span class="keyword">from</span> <span class="string">&#x27;./index&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> chalk <span class="keyword">from</span> <span class="string">&#x27;chalk&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * eos commands</span></span><br><span class="line"><span class="comment"> *    - config</span></span><br><span class="line"><span class="comment"> *    - init </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> actionMap = &#123;</span><br><span class="line">    <span class="attr">init</span>: &#123;</span><br><span class="line">        <span class="attr">description</span>: <span class="string">&#x27;generate a new project from a template&#x27;</span>,</span><br><span class="line">        <span class="attr">usages</span>: [</span><br><span class="line">            <span class="string">&#x27;eos init templateName projectName&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">config</span>: &#123;</span><br><span class="line">        <span class="attr">alias</span>: <span class="string">&#x27;cfg&#x27;</span>,</span><br><span class="line">        <span class="attr">description</span>: <span class="string">&#x27;config .eosrc&#x27;</span>,</span><br><span class="line">        <span class="attr">usages</span>: [</span><br><span class="line">            <span class="string">&#x27;eos config set &lt;k&gt; &lt;v&gt;&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;eos config get &lt;k&gt;&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;eos config remove &lt;k&gt;&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">        </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//other commands</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 init / config 命令</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(actionMap).<span class="title function_">forEach</span>(<span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">    program.<span class="title function_">command</span>(action)</span><br><span class="line">    .<span class="title function_">description</span>(actionMap[action].<span class="property">description</span>)</span><br><span class="line">    .<span class="title function_">alias</span>(actionMap[action].<span class="property">alias</span>) <span class="comment">//别名</span></span><br><span class="line">    .<span class="title function_">action</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;config&#x27;</span>: </span><br><span class="line">                <span class="comment">//配置</span></span><br><span class="line">                <span class="title function_">apply</span>(action, ...process.<span class="property">argv</span>.<span class="title function_">slice</span>(<span class="number">3</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;init&#x27;</span>:</span><br><span class="line">                <span class="title function_">apply</span>(action, ...process.<span class="property">argv</span>.<span class="title function_">slice</span>(<span class="number">3</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="attr">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">help</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;\r\nUsage:&#x27;</span>);</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(actionMap).<span class="title function_">forEach</span>(<span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">        actionMap[action].<span class="property">usages</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">usage</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;  - &#x27;</span> + usage);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">program.<span class="title function_">usage</span>(<span class="string">&#x27;&lt;command&gt; [options]&#x27;</span>);</span><br><span class="line"><span class="comment">// eos -h </span></span><br><span class="line">program.<span class="title function_">on</span>(<span class="string">&#x27;-h&#x27;</span>, help);</span><br><span class="line">program.<span class="title function_">on</span>(<span class="string">&#x27;--help&#x27;</span>, help);</span><br><span class="line"><span class="comment">// eos -V   VERSION 为 package.json 中的版本号</span></span><br><span class="line">program.<span class="title function_">version</span>(<span class="variable constant_">VERSION</span>, <span class="string">&#x27;-V --version&#x27;</span>).<span class="title function_">parse</span>(process.<span class="property">argv</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// eos 不带参数时</span></span><br><span class="line"><span class="keyword">if</span> (!process.<span class="property">argv</span>.<span class="title function_">slice</span>(<span class="number">2</span>).<span class="property">length</span>) &#123;</span><br><span class="line">    program.<span class="title function_">outputHelp</span>(make_green);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">make_green</span>(<span class="params">txt</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> chalk.<span class="title function_">green</span>(txt); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="下载模板"><a href="#下载模板" class="headerlink" title="下载模板"></a>下载模板</h2><p>download-git-repo 支持从 Github、Gitlab 下载远程仓库到本地。</p>
<blockquote>
<p>get.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getAll &#125; <span class="keyword">from</span> <span class="string">&#x27;./rc&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> downloadGit <span class="keyword">from</span> <span class="string">&#x27;download-git-repo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">downloadLocal</span> = <span class="keyword">async</span> (<span class="params">templateName, projectName</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> config = <span class="keyword">await</span> <span class="title function_">getAll</span>();</span><br><span class="line">    <span class="keyword">let</span> api = <span class="string">`<span class="subst">$&#123;config.registry&#125;</span>/<span class="subst">$&#123;templateName&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//projectName 为下载到的本地目录</span></span><br><span class="line">        <span class="title function_">downloadGit</span>(api, projectName, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="title function_">reject</span>(err);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">resolve</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="init-命令"><a href="#init-命令" class="headerlink" title="init 命令"></a>init 命令</h2><p><strong>命令行交互</strong></p>
<p>在用户执行 init 命令后，向用户提出问题，接收用户的输入并作出相应的处理。命令行交互利用 inquirer 来实现:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">inquirer.<span class="title function_">prompt</span>([</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;description&#x27;</span>,</span><br><span class="line">        <span class="attr">message</span>: <span class="string">&#x27;Please enter the project description: &#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;author&#x27;</span>,</span><br><span class="line">        <span class="attr">message</span>: <span class="string">&#x27;Please enter the author name: &#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">]).<span class="title function_">then</span>(<span class="function">(<span class="params">answer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>视觉美化</strong></p>
<p>在用户输入之后，开始下载模板，这时候使用 ora 来提示用户正在下载模板，下载结束之后，也给出提示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ora <span class="keyword">from</span> <span class="string">&#x27;ora&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> loading = <span class="title function_">ora</span>(<span class="string">&#x27;downloading template ...&#x27;</span>);</span><br><span class="line">loading.<span class="title function_">start</span>();</span><br><span class="line"><span class="comment">//download</span></span><br><span class="line">loading.<span class="title function_">succeed</span>(); <span class="comment">//或 loading.fail();</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>init.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; downloadLocal &#125; <span class="keyword">from</span> <span class="string">&#x27;./utils/get&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ora <span class="keyword">from</span> <span class="string">&#x27;ora&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> inquirer <span class="keyword">from</span> <span class="string">&#x27;inquirer&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> chalk <span class="keyword">from</span> <span class="string">&#x27;chalk&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> symbol <span class="keyword">from</span> <span class="string">&#x27;log-symbols&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">init</span> = <span class="keyword">async</span> (<span class="params">templateName, projectName</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">//项目不存在</span></span><br><span class="line">    <span class="keyword">if</span> (!fs.<span class="title function_">existsSync</span>(projectName)) &#123;</span><br><span class="line">        <span class="comment">//命令行交互</span></span><br><span class="line">        inquirer.<span class="title function_">prompt</span>([</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">name</span>: <span class="string">&#x27;description&#x27;</span>,</span><br><span class="line">                <span class="attr">message</span>: <span class="string">&#x27;Please enter the project description: &#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">name</span>: <span class="string">&#x27;author&#x27;</span>,</span><br><span class="line">                <span class="attr">message</span>: <span class="string">&#x27;Please enter the author name: &#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]).<span class="title function_">then</span>(<span class="keyword">async</span> (answer) =&gt; &#123;</span><br><span class="line">            <span class="comment">//下载模板 选择模板</span></span><br><span class="line">            <span class="comment">//通过配置文件，获取模板信息</span></span><br><span class="line">            <span class="keyword">let</span> loading = <span class="title function_">ora</span>(<span class="string">&#x27;downloading template ...&#x27;</span>);</span><br><span class="line">            loading.<span class="title function_">start</span>();</span><br><span class="line">            <span class="title function_">downloadLocal</span>(templateName, projectName).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                loading.<span class="title function_">succeed</span>();</span><br><span class="line">                <span class="keyword">const</span> fileName = <span class="string">`<span class="subst">$&#123;projectName&#125;</span>/package.json`</span>;</span><br><span class="line">                <span class="keyword">if</span>(fs.<span class="title function_">existsSync</span>(fileName))&#123;</span><br><span class="line">                    <span class="keyword">const</span> data = fs.<span class="title function_">readFileSync</span>(fileName).<span class="title function_">toString</span>();</span><br><span class="line">                    <span class="keyword">let</span> json = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(data);</span><br><span class="line">                    json.<span class="property">name</span> = projectName;</span><br><span class="line">                    json.<span class="property">author</span> = answer.<span class="property">author</span>;</span><br><span class="line">                    json.<span class="property">description</span> = answer.<span class="property">description</span>;</span><br><span class="line">                    <span class="comment">//修改项目文件夹中 package.json 文件</span></span><br><span class="line">                    fs.<span class="title function_">writeFileSync</span>(fileName, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(json, <span class="literal">null</span>, <span class="string">&#x27;\t&#x27;</span>), <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(symbol.<span class="property">success</span>, chalk.<span class="title function_">green</span>(<span class="string">&#x27;Project initialization finished!&#x27;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                loading.<span class="title function_">fail</span>();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//项目已经存在</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(symbol.<span class="property">error</span>, chalk.<span class="title function_">red</span>(<span class="string">&#x27;The project already exists&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = init;</span><br></pre></td></tr></table></figure>
<h2 id="config-配置"><a href="#config-配置" class="headerlink" title="config 配置"></a>config 配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eos config set registry vuejs-templates</span><br></pre></td></tr></table></figure>
<p>config 配置，支持我们使用其它仓库的模板，例如，我们可以使用 vuejs-templates 中的仓库作为模板。这样有一个好处：更新模板无需重新发布脚手架，使用者无需重新安装，并且可以自由选择下载目标。</p>
<blockquote>
<p>config.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 管理 .eosrc 文件 (当前用户目录下)</span></span><br><span class="line"><span class="keyword">import</span> &#123; get, set, getAll, remove &#125; <span class="keyword">from</span> <span class="string">&#x27;./utils/rc&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">config</span> = <span class="keyword">async</span> (<span class="params">action, key, value</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;get&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> (key) &#123;</span><br><span class="line">                <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="title function_">get</span>(key);</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> obj = <span class="keyword">await</span> <span class="title function_">getAll</span>();</span><br><span class="line">                <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;obj[key]&#125;</span>`</span>);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;set&#x27;</span>:</span><br><span class="line">            <span class="title function_">set</span>(key, value);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;remove&#x27;</span>:</span><br><span class="line">            <span class="title function_">remove</span>(key);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = config;</span><br></pre></td></tr></table></figure>
<p>?rc.js</p>
<p>.eosrc 文件的增删改查</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">RC</span>, <span class="variable constant_">DEFAULTS</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./constants&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; decode, encode &#125; <span class="keyword">from</span> <span class="string">&#x27;ini&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; promisify &#125; <span class="keyword">from</span> <span class="string">&#x27;util&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> chalk <span class="keyword">from</span> <span class="string">&#x27;chalk&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> exits = <span class="title function_">promisify</span>(fs.<span class="property">exists</span>);</span><br><span class="line"><span class="keyword">const</span> readFile = <span class="title function_">promisify</span>(fs.<span class="property">readFile</span>);</span><br><span class="line"><span class="keyword">const</span> writeFile = <span class="title function_">promisify</span>(fs.<span class="property">writeFile</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//RC 是配置文件</span></span><br><span class="line"><span class="comment">//DEFAULTS 是默认的配置</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">get</span> = <span class="keyword">async</span> (<span class="params">key</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> exit = <span class="keyword">await</span> <span class="title function_">exits</span>(<span class="variable constant_">RC</span>);</span><br><span class="line">    <span class="keyword">let</span> opts;</span><br><span class="line">    <span class="keyword">if</span> (exit) &#123;</span><br><span class="line">        opts = <span class="keyword">await</span> <span class="title function_">readFile</span>(<span class="variable constant_">RC</span>, <span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">        opts = <span class="title function_">decode</span>(opts);</span><br><span class="line">        <span class="keyword">return</span> opts[key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getAll</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> exit = <span class="keyword">await</span> <span class="title function_">exits</span>(<span class="variable constant_">RC</span>);</span><br><span class="line">    <span class="keyword">let</span> opts;</span><br><span class="line">    <span class="keyword">if</span> (exit) &#123;</span><br><span class="line">        opts = <span class="keyword">await</span> <span class="title function_">readFile</span>(<span class="variable constant_">RC</span>, <span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">        opts = <span class="title function_">decode</span>(opts);</span><br><span class="line">        <span class="keyword">return</span> opts;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">set</span> = <span class="keyword">async</span> (<span class="params">key, value</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> exit = <span class="keyword">await</span> <span class="title function_">exits</span>(<span class="variable constant_">RC</span>);</span><br><span class="line">    <span class="keyword">let</span> opts;</span><br><span class="line">    <span class="keyword">if</span> (exit) &#123;</span><br><span class="line">        opts = <span class="keyword">await</span> <span class="title function_">readFile</span>(<span class="variable constant_">RC</span>, <span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">        opts = <span class="title function_">decode</span>(opts);</span><br><span class="line">        <span class="keyword">if</span>(!key) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(chalk.<span class="title function_">red</span>(chalk.<span class="title function_">bold</span>(<span class="string">&#x27;Error:&#x27;</span>)), chalk.<span class="title function_">red</span>(<span class="string">&#x27;key is required&#x27;</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!value) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(chalk.<span class="title function_">red</span>(chalk.<span class="title function_">bold</span>(<span class="string">&#x27;Error:&#x27;</span>)), chalk.<span class="title function_">red</span>(<span class="string">&#x27;value is required&#x27;</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">assign</span>(opts, &#123; [key]: value &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        opts = <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="variable constant_">DEFAULTS</span>, &#123; [key]: value &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">writeFile</span>(<span class="variable constant_">RC</span>, <span class="title function_">encode</span>(opts), <span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">remove</span> = <span class="keyword">async</span> (<span class="params">key</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> exit = <span class="keyword">await</span> <span class="title function_">exits</span>(<span class="variable constant_">RC</span>);</span><br><span class="line">    <span class="keyword">let</span> opts;</span><br><span class="line">    <span class="keyword">if</span> (exit) &#123;</span><br><span class="line">        opts = <span class="keyword">await</span> <span class="title function_">readFile</span>(<span class="variable constant_">RC</span>, <span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">        opts = <span class="title function_">decode</span>(opts);</span><br><span class="line">        <span class="keyword">delete</span> opts[key];</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">writeFile</span>(<span class="variable constant_">RC</span>, <span class="title function_">encode</span>(opts), <span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>npm publish 将本脚手架发布至npm上。其它用户可以通过 npm install eos-cli -g 全局安装。<br>即可使用 eos 命令。</p>
<p><strong>项目地址</strong></p>
<p>本项目完整代码请戳: <a href="https://github.com/ytking/eos-cli">https://github.com/ytking/eos-cli</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>cli</tag>
      </tags>
  </entry>
  <entry>
    <title>大厂JS必考手写题</title>
    <url>/post/b11c6f1c0c11/</url>
    <content><![CDATA[<h2 id="篇一"><a href="#篇一" class="headerlink" title="篇一"></a>篇一</h2><p>🎄 前言</p>
<p>本文主要总结了 2021 年前端提前批和秋招所考察的手写题，题目来源于牛客网前端面经区，统计时间自 3 月初至 10 月底，面经来源于阿里、腾讯、百度、字节、美团、京东、快手、拼多多等 15 家公司，并做了简单的频次划分。</p>
<ul>
<li>⭐⭐⭐⭐⭐: 在 15 家公司面试中出现 10+</li>
<li>⭐⭐⭐⭐：在 15 家公式面试中出现 5-10</li>
<li>⭐⭐⭐：在 15 家公司面试中出现 3-5</li>
<li>无星：出现 1-2</li>
</ul>
<p>题目解析一部分来源于小包的编写，另一部分如果我感觉题目扩展开来更好的话，我就选取部分大佬的博客链接。</p>
<h2 id="🌟-promise"><a href="#🌟-promise" class="headerlink" title="🌟 promise"></a>🌟 promise</h2><h3 id="实现-promise"><a href="#实现-promise" class="headerlink" title="实现 promise"></a>实现 promise</h3><p>考察频率: (⭐⭐⭐⭐⭐)</p>
<p>参考代码[1]</p>
<h3 id="实现-promise-all"><a href="#实现-promise-all" class="headerlink" title="实现 promise.all"></a>实现 promise.all</h3><p>考察频率: (⭐⭐⭐⭐⭐)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">PromiseAll</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(promises)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;promises must be an array&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    promises.<span class="title function_">forEach</span>(<span class="function">(<span class="params">promise, index</span>) =&gt;</span> &#123;</span><br><span class="line">      promise.<span class="title function_">then</span>(</span><br><span class="line">        <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">          result[index] = res;</span><br><span class="line">          count++;</span><br><span class="line">          count === promises.<span class="property">length</span> &amp;&amp; <span class="title function_">resolve</span>(result);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">reject</span>(err);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h3 id="实现-promise-finally"><a href="#实现-promise-finally" class="headerlink" title="实现 promise.finally"></a>实现 promise.finally</h3><p>考察频率: (⭐⭐⭐⭐⭐)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">finally</span> = <span class="keyword">function</span> (<span class="params">cb</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(</span><br><span class="line">    <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title function_">cb</span>()).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title function_">cb</span>()).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h3 id="实现-promise-allSettled"><a href="#实现-promise-allSettled" class="headerlink" title="实现 promise.allSettled"></a>实现 promise.allSettled</h3><p>考察频率: (⭐⭐⭐⭐)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">allSettled</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (promises.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>([]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> _promises = promises.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span></span><br><span class="line">    item <span class="keyword">instanceof</span> <span class="title class_">Promise</span> ? item : <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(item)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> unSettledPromiseCount = _promises.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">    _promises.<span class="title function_">forEach</span>(<span class="function">(<span class="params">promise, index</span>) =&gt;</span> &#123;</span><br><span class="line">      promise.<span class="title function_">then</span>(</span><br><span class="line">        <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">          result[index] = &#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="string">&quot;fulfilled&quot;</span>,</span><br><span class="line">            value,</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          unSettledPromiseCount -= <span class="number">1</span>;</span><br><span class="line">          <span class="comment">// resolve after all are settled</span></span><br><span class="line">          <span class="keyword">if</span> (unSettledPromiseCount === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">          result[index] = &#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="string">&quot;rejected&quot;</span>,</span><br><span class="line">            reason,</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          unSettledPromiseCount -= <span class="number">1</span>;</span><br><span class="line">          <span class="comment">// resolve after all are settled</span></span><br><span class="line">          <span class="keyword">if</span> (unSettledPromiseCount === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h3 id="实现-promise-race"><a href="#实现-promise-race" class="headerlink" title="实现 promise.race"></a>实现 promise.race</h3><p>考察频率: (⭐⭐⭐)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">race</span> = <span class="keyword">function</span> (<span class="params">promiseArr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    promiseArr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">p</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(p).<span class="title function_">then</span>(</span><br><span class="line">        <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(val);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">rejecte</span>(err);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h3 id="来说一下如何串行执行多个-Promise"><a href="#来说一下如何串行执行多个-Promise" class="headerlink" title="来说一下如何串行执行多个 Promise"></a>来说一下如何串行执行多个 Promise</h3><p>参考代码[2]</p>
<h3 id="promise-any"><a href="#promise-any" class="headerlink" title="promise.any"></a>promise.any</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">any</span> = <span class="keyword">function</span> (<span class="params">promiseArr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (promiseArr.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    promiseArr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">p, i</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(p).<span class="title function_">then</span>(</span><br><span class="line">        <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(val);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">          index++;</span><br><span class="line">          <span class="keyword">if</span> (index === promiseArr.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">AggregateError</span>(<span class="string">&quot;All promises were rejected&quot;</span>));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h3 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">resolve</span> = <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="title function_">resolve</span>(value));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h3 id="reject"><a href="#reject" class="headerlink" title="reject"></a>reject</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">reject</span> = <span class="keyword">function</span> (<span class="params">reason</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>(reason));</span><br><span class="line">&#125;;</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h2 id="🐳-Array-篇"><a href="#🐳-Array-篇" class="headerlink" title="🐳 Array 篇"></a>🐳 Array 篇</h2><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><p>考察频率: (⭐⭐⭐⭐⭐)</p>
<h4 id="使用双重-for-和-splice"><a href="#使用双重-for-和-splice" class="headerlink" title="使用双重 for 和 splice"></a>使用双重 <code>for</code> 和 <code>splice</code></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] == arr[j]) &#123;</span><br><span class="line">        <span class="comment">//第一个等同于第二个，splice方法删除第二个</span></span><br><span class="line">        arr.<span class="title function_">splice</span>(j, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 删除后注意回调j</span></span><br><span class="line">        j--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h4 id="使用-indexOf-或-includes-加新数组"><a href="#使用-indexOf-或-includes-加新数组" class="headerlink" title="使用 indexOf 或 includes 加新数组"></a>使用 <code>indexOf</code> 或 <code>includes</code> 加新数组</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用indexof</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> uniqueArr = []; <span class="comment">// 新数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (uniqueArr.<span class="title function_">indexOf</span>(arr[i]) === -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">//indexof返回-1表示在新数组中不存在该元素</span></span><br><span class="line">      uniqueArr.<span class="title function_">push</span>(arr[i]); <span class="comment">//是新数组里没有的元素就push入</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> uniqueArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用includes</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> uniqueArr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">//includes 检测数组是否有某个值</span></span><br><span class="line">    <span class="keyword">if</span> (!uniqueArr.<span class="title function_">includes</span>(arr[i])) &#123;</span><br><span class="line">      uniqueArr.<span class="title function_">push</span>(arr[i]); <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> uniqueArr;</span><br><span class="line">&#125;</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h4 id="sort-排序后，使用快慢指针的思想"><a href="#sort-排序后，使用快慢指针的思想" class="headerlink" title="sort 排序后，使用快慢指针的思想"></a><code>sort</code> 排序后，使用快慢指针的思想</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">var</span> slow = <span class="number">1</span>,</span><br><span class="line">    fast = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (fast &lt; arr.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[fast] != arr[fast - <span class="number">1</span>]) &#123;</span><br><span class="line">      arr[slow++] = arr[fast];</span><br><span class="line">    &#125;</span><br><span class="line">    ++fast;</span><br><span class="line">  &#125;</span><br><span class="line">  arr.<span class="property">length</span> = slow;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<p><code>sort</code> 方法用于从小到大排序(返回一个新数组)，其参数中不带以上回调函数就会在两位数及以上时出现排序错误(如果省略，元素按照转换为的字符串的各个字符的 <code>Unicode</code> 位点进行排序。两位数会变为长度为二的字符串来计算)。</p>
<h4 id="ES6-提供的-Set-去重"><a href="#ES6-提供的-Set-去重" class="headerlink" title="ES6 提供的 Set 去重"></a><code>ES6</code> 提供的 <code>Set</code> 去重</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="title class_">Set</span>(arr);</span><br><span class="line">  <span class="keyword">return</span> [...result];</span><br><span class="line">  <span class="comment">//使用扩展运算符将Set数据结构转为数组</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<p><code>Set</code> 中的元素只会出现一次，即 <code>Set</code> 中的元素是唯一的。</p>
<h4 id="使用哈希表存储元素是否出现-ES6-提供的-map"><a href="#使用哈希表存储元素是否出现-ES6-提供的-map" class="headerlink" title="使用哈希表存储元素是否出现(ES6 提供的 map)"></a>使用哈希表存储元素是否出现(<code>ES6</code> 提供的 <code>map</code>)</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  <span class="keyword">let</span> uniqueArr = <span class="keyword">new</span> <span class="title class_">Array</span>(); <span class="comment">// 数组用于返回结果</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map.<span class="title function_">has</span>(arr[i])) &#123;</span><br><span class="line">      <span class="comment">// 如果有该key值</span></span><br><span class="line">      map.<span class="title function_">set</span>(arr[i], <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      map.<span class="title function_">set</span>(arr[i], <span class="literal">false</span>); <span class="comment">// 如果没有该key值</span></span><br><span class="line">      uniqueArr.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> uniqueArr;</span><br><span class="line">&#125;</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<p><code>map</code> 对象保存键值对，与对象类似。但 <code>map</code> 的键可以是任意类型，对象的键只能是字符串类型。</p>
<p>如果数组中只有数字也可以使用普通对象作为哈希表。</p>
<h4 id="filter-配合-indexOf"><a href="#filter-配合-indexOf" class="headerlink" title="filter 配合 indexOf"></a><code>filter</code> 配合 <code>indexOf</code></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">item, index, arr</span>) &#123;</span><br><span class="line">    <span class="comment">//当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素</span></span><br><span class="line">    <span class="comment">//不是那么就证明是重复项，就舍弃</span></span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">indexOf</span>(item) === index;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<p>这里有可能存在疑问，我来举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>];</span><br><span class="line">arr.<span class="title function_">indexOf</span>(arr[<span class="number">0</span>]) === <span class="number">0</span>; <span class="comment">// 1 的第一次出现</span></span><br><span class="line">arr.<span class="title function_">indexOf</span>(arr[<span class="number">1</span>]) !== <span class="number">1</span>; <span class="comment">// 说明前面曾经出现过1</span></span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h4 id="reduce-配合-includes"><a href="#reduce-配合-includes" class="headerlink" title="reduce 配合 includes"></a><code>reduce</code> 配合 <code>includes</code></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> uniqueArr = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!acc.<span class="title function_">includes</span>(cur)) &#123;</span><br><span class="line">      acc.<span class="title function_">push</span>(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">  &#125;, []); <span class="comment">// []作为回调函数的第一个参数的初始值</span></span><br><span class="line">  <span class="keyword">return</span> uniqueArr;</span><br><span class="line">&#125;</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h3 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h3><p>考察频率: (⭐⭐⭐)</p>
<p>参考代码[3]</p>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>考察频率: (⭐⭐⭐)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myForEach</span> = <span class="keyword">function</span> (<span class="params">callbackFn</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断this是否合法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span> === <span class="literal">null</span> || <span class="variable language_">this</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Cannot read property &#x27;myForEach&#x27; of null&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断callbackFn是否合法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(callbackFn) !== <span class="string">&quot;[object Function]&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(callbackFn + <span class="string">&quot; is not a function&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 取到执行方法的数组对象和传入的this对象</span></span><br><span class="line">  <span class="keyword">var</span> _arr = <span class="variable language_">this</span>,</span><br><span class="line">    thisArg = <span class="variable language_">arguments</span>[<span class="number">1</span>] || <span class="variable language_">window</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; _arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 执行回调函数</span></span><br><span class="line">    callbackFn.<span class="title function_">call</span>(thisArg, _arr[i], i, _arr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>考察频率: (⭐⭐⭐)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myReduce</span> = <span class="keyword">function</span> (<span class="params">callbackFn</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> _arr = <span class="variable language_">this</span>,</span><br><span class="line">    accumulator = <span class="variable language_">arguments</span>[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 判断是否传入初始值</span></span><br><span class="line">  <span class="keyword">if</span> (accumulator === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// 没有初始值的空数组调用reduce会报错</span></span><br><span class="line">    <span class="keyword">if</span> (_arr.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;initVal and Array.length&gt;0 need one&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始值赋值为数组第一个元素</span></span><br><span class="line">    accumulator = _arr[i];</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; _arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 计算结果赋值给初始值</span></span><br><span class="line">    accumulator = <span class="title function_">callbackFn</span>(accumulator, _arr[i], i, _arr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> accumulator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myMap</span> = <span class="keyword">function</span> (<span class="params">callbackFn</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> _arr = <span class="variable language_">this</span>,</span><br><span class="line">    thisArg = <span class="variable language_">arguments</span>[<span class="number">1</span>] || <span class="variable language_">window</span>,</span><br><span class="line">    res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; _arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 存储运算结果</span></span><br><span class="line">    res.<span class="title function_">push</span>(callbackFn.<span class="title function_">call</span>(thisArg, _arr[i], i, _arr));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myFilter</span> = <span class="keyword">function</span> (<span class="params">callbackFn</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> _arr = <span class="variable language_">this</span>,</span><br><span class="line">    thisArg = <span class="variable language_">arguments</span>[<span class="number">1</span>] || <span class="variable language_">window</span>,</span><br><span class="line">    res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; _arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 回调函数执行为true</span></span><br><span class="line">    <span class="keyword">if</span> (callbackFn.<span class="title function_">call</span>(thisArg, _arr[i], i, _arr)) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(_arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h3 id="every"><a href="#every" class="headerlink" title="every"></a>every</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myEvery</span> = <span class="keyword">function</span> (<span class="params">callbackFn</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> _arr = <span class="variable language_">this</span>,</span><br><span class="line">    thisArg = <span class="variable language_">arguments</span>[<span class="number">1</span>] || <span class="variable language_">window</span>;</span><br><span class="line">  <span class="comment">// 开始标识值为true</span></span><br><span class="line">  <span class="comment">// 遇到回调返回false，直接返回false</span></span><br><span class="line">  <span class="comment">// 如果循环执行完毕，意味着所有回调返回值为true，最终结果为true</span></span><br><span class="line">  <span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; _arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 回调函数执行为false，函数中断</span></span><br><span class="line">    <span class="keyword">if</span> (!callbackFn.<span class="title function_">call</span>(thisArg, _arr[i], i, _arr)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;;</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h3 id="some"><a href="#some" class="headerlink" title="some"></a>some</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">mySome</span> = <span class="keyword">function</span> (<span class="params">callbackFn</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> _arr = <span class="variable language_">this</span>,</span><br><span class="line">    thisArg = <span class="variable language_">arguments</span>[<span class="number">1</span>] || <span class="variable language_">window</span>;</span><br><span class="line">  <span class="comment">// 开始标识值为false</span></span><br><span class="line">  <span class="comment">// 遇到回调返回true，直接返回true</span></span><br><span class="line">  <span class="comment">// 如果循环执行完毕，意味着所有回调返回值为false，最终结果为false</span></span><br><span class="line">  <span class="keyword">var</span> flag = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; _arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 回调函数执行为false，函数中断</span></span><br><span class="line">    <span class="keyword">if</span> (callbackFn.<span class="title function_">call</span>(thisArg, _arr[i], i, _arr)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;;</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h3 id="find-findIndex"><a href="#find-findIndex" class="headerlink" title="find&#x2F;findIndex"></a>find&#x2F;findIndex</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myFind</span> = <span class="keyword">function</span> (<span class="params">callbackFn</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> _arr = <span class="variable language_">this</span>,</span><br><span class="line">    thisArg = <span class="variable language_">arguments</span>[<span class="number">1</span>] || <span class="variable language_">window</span>;</span><br><span class="line">  <span class="comment">// 遇到回调返回true，直接返回该数组元素</span></span><br><span class="line">  <span class="comment">// 如果循环执行完毕，意味着所有回调返回值为false，最终结果为undefined</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; _arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 回调函数执行为false，函数中断</span></span><br><span class="line">    <span class="keyword">if</span> (callbackFn.<span class="title function_">call</span>(thisArg, _arr[i], i, _arr)) &#123;</span><br><span class="line">      <span class="keyword">return</span> _arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">indexOf</span>(<span class="params">findVal, beginIndex = <span class="number">0</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">length</span> &lt; <span class="number">1</span> || beginIndex &gt; findVal.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!findVal) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  beginIndex = beginIndex &lt;= <span class="number">0</span> ? <span class="number">0</span> : beginIndex;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = beginIndex; i &lt; <span class="variable language_">this</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>[i] == findVal) <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h3 id="实现-sort"><a href="#实现-sort" class="headerlink" title="实现 sort"></a>实现 sort</h3><p>参考代码[4]</p>
<h2 id="🌊-防抖节流"><a href="#🌊-防抖节流" class="headerlink" title="🌊 防抖节流"></a>🌊 防抖节流</h2><h3 id="实现防抖函数-debounce"><a href="#实现防抖函数-debounce" class="headerlink" title="实现防抖函数 debounce"></a>实现防抖函数 debounce</h3><p>考察频率: (⭐⭐⭐⭐⭐)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait, immediate</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> timeout, result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> debounced = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">      <span class="comment">// 如果已经执行过，不再执行</span></span><br><span class="line">      <span class="keyword">var</span> callNow = !timeout;</span><br><span class="line">      timeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">      &#125;, wait);</span><br><span class="line">      <span class="keyword">if</span> (callNow) result = func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        result = func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">      &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  debounced.<span class="property">cancel</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    timeout = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> debounced;</span><br><span class="line">&#125;</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h3 id="实现节流函数-throttle"><a href="#实现节流函数-throttle" class="headerlink" title="实现节流函数 throttle"></a>实现节流函数 throttle</h3><p>考察频率: (⭐⭐⭐⭐⭐)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第四版</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, wait, options</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> timeout, context, args, result;</span><br><span class="line">  <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (!options) options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> later = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    previous = options.<span class="property">leading</span> === <span class="literal">false</span> ? <span class="number">0</span> : <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">    timeout = <span class="literal">null</span>;</span><br><span class="line">    func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">    <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> throttled = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">    <span class="keyword">if</span> (!previous &amp;&amp; options.<span class="property">leading</span> === <span class="literal">false</span>) previous = now;</span><br><span class="line">    <span class="keyword">var</span> remaining = wait - (now - previous);</span><br><span class="line">    context = <span class="variable language_">this</span>;</span><br><span class="line">    args = <span class="variable language_">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">      <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      previous = now;</span><br><span class="line">      func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">      <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.<span class="property">trailing</span> !== <span class="literal">false</span>) &#123;</span><br><span class="line">      timeout = <span class="built_in">setTimeout</span>(later, remaining);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> throttled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h2 id="⛲-Object-篇"><a href="#⛲-Object-篇" class="headerlink" title="⛲ Object 篇"></a>⛲ Object 篇</h2><h3 id="能不能写一个完整的深拷贝"><a href="#能不能写一个完整的深拷贝" class="headerlink" title="能不能写一个完整的深拷贝"></a>能不能写一个完整的深拷贝</h3><p>考察频率: (⭐⭐⭐⭐⭐)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getType</span> = (<span class="params">obj</span>) =&gt; <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isObject</span> = (<span class="params">target</span>) =&gt;</span><br><span class="line">  (<span class="keyword">typeof</span> target === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> target === <span class="string">&quot;function&quot;</span>) &amp;&amp;</span><br><span class="line">  target !== <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> canTraverse = &#123;</span><br><span class="line">  <span class="string">&quot;[object Map]&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;[object Set]&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;[object Array]&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;[object Object]&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;[object Arguments]&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> mapTag = <span class="string">&quot;[object Map]&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> setTag = <span class="string">&quot;[object Set]&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> boolTag = <span class="string">&quot;[object Boolean]&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> numberTag = <span class="string">&quot;[object Number]&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> stringTag = <span class="string">&quot;[object String]&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> symbolTag = <span class="string">&quot;[object Symbol]&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> dateTag = <span class="string">&quot;[object Date]&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> errorTag = <span class="string">&quot;[object Error]&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> regexpTag = <span class="string">&quot;[object RegExp]&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> funcTag = <span class="string">&quot;[object Function]&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleRegExp</span> = (<span class="params">target</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; source, flags &#125; = target;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> target.<span class="title function_">constructor</span>(<span class="params">source, flags</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleFunc</span> = (<span class="params">func</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 箭头函数直接返回自身</span></span><br><span class="line">  <span class="keyword">if</span> (!func.<span class="property"><span class="keyword">prototype</span></span>) <span class="keyword">return</span> func;</span><br><span class="line">  <span class="keyword">const</span> bodyReg = <span class="regexp">/(?&lt;=&#123;)(.|\n)+(?=&#125;)/m</span>;</span><br><span class="line">  <span class="keyword">const</span> paramReg = <span class="regexp">/(?&lt;=\().+(?=\)\s+&#123;)/</span>;</span><br><span class="line">  <span class="keyword">const</span> funcString = func.<span class="title function_">toString</span>();</span><br><span class="line">  <span class="comment">// 分别匹配 函数参数 和 函数体</span></span><br><span class="line">  <span class="keyword">const</span> param = paramReg.<span class="title function_">exec</span>(funcString);</span><br><span class="line">  <span class="keyword">const</span> body = bodyReg.<span class="title function_">exec</span>(funcString);</span><br><span class="line">  <span class="keyword">if</span> (!body) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (param) &#123;</span><br><span class="line">    <span class="keyword">const</span> paramArr = param[<span class="number">0</span>].<span class="title function_">split</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Function</span>(...paramArr, body[<span class="number">0</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Function</span>(body[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleNotTraverse</span> = (<span class="params">target, tag</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Ctor</span> = target.<span class="property">constructor</span>;</span><br><span class="line">  <span class="keyword">switch</span> (tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">boolTag</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>(<span class="title class_">Boolean</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">valueOf</span>.<span class="title function_">call</span>(target));</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">numberTag</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>(<span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">valueOf</span>.<span class="title function_">call</span>(target));</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">stringTag</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>(<span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">valueOf</span>.<span class="title function_">call</span>(target));</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">symbolTag</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>(<span class="title class_">Symbol</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">valueOf</span>.<span class="title function_">call</span>(target));</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">errorTag</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">dateTag</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Ctor</span>(target);</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">regexpTag</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">handleRegExp</span>(target);</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">funcTag</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">handleFunc</span>(target);</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Ctor</span>(target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">deepClone</span> = (<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isObject</span>(target)) <span class="keyword">return</span> target;</span><br><span class="line">  <span class="keyword">let</span> type = <span class="title function_">getType</span>(target);</span><br><span class="line">  <span class="keyword">let</span> cloneTarget;</span><br><span class="line">  <span class="keyword">if</span> (!canTraverse[type]) &#123;</span><br><span class="line">    <span class="comment">// 处理不能遍历的对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">handleNotTraverse</span>(target, type);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 这波操作相当关键，可以保证对象的原型不丢失！</span></span><br><span class="line">    <span class="keyword">let</span> ctor = target.<span class="property">constructor</span>;</span><br><span class="line">    cloneTarget = <span class="keyword">new</span> <span class="title function_">ctor</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (map.<span class="title function_">get</span>(target)) <span class="keyword">return</span> target;</span><br><span class="line">  map.<span class="title function_">set</span>(target, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (type === mapTag) &#123;</span><br><span class="line">    <span class="comment">//处理Map</span></span><br><span class="line">    target.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, key</span>) =&gt;</span> &#123;</span><br><span class="line">      cloneTarget.<span class="title function_">set</span>(<span class="title function_">deepClone</span>(key, map), <span class="title function_">deepClone</span>(item, map));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (type === setTag) &#123;</span><br><span class="line">    <span class="comment">//处理Set</span></span><br><span class="line">    target.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      cloneTarget.<span class="title function_">add</span>(<span class="title function_">deepClone</span>(item, map));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理数组和对象</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target.<span class="title function_">hasOwnProperty</span>(prop)) &#123;</span><br><span class="line">      cloneTarget[prop] = <span class="title function_">deepClone</span>(target[prop], map);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneTarget;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<p>参考博客[5]</p>
<h3 id="实现-new"><a href="#实现-new" class="headerlink" title="实现 new"></a>实现 new</h3><p>考察频率: (⭐⭐⭐⭐)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createObject</span>(<span class="params">Con</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建新对象obj</span></span><br><span class="line">  <span class="comment">// var obj = &#123;&#125;;也可以</span></span><br><span class="line">  <span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将obj.__proto__ -&gt; 构造函数原型</span></span><br><span class="line">  <span class="comment">// (不推荐)obj.__proto__ = Con.prototype</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj, <span class="title class_">Con</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行构造函数，并接受构造函数返回值</span></span><br><span class="line">  <span class="keyword">const</span> ret = <span class="title class_">Con</span>.<span class="title function_">apply</span>(obj, [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 若构造函数返回值为对象，直接返回该对象</span></span><br><span class="line">  <span class="comment">// 否则返回obj</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">&quot;object&quot;</span> ? ret : obj;</span><br><span class="line">&#125;</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>考察频率: (⭐⭐⭐⭐)</p>
<h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><h4 id="借用构造函数-经典继承"><a href="#借用构造函数-经典继承" class="headerlink" title="借用构造函数(经典继承)"></a>借用构造函数(经典继承)</h4><h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><h4 id="Class-实现继承-补充一下"><a href="#Class-实现继承-补充一下" class="headerlink" title="Class 实现继承(补充一下)"></a>Class 实现继承(补充一下)</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<p>参考代码[6]</p>
<h3 id="实现-object-create"><a href="#实现-object-create" class="headerlink" title="实现 object.create"></a>实现 object.create</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">newCreate</span>(<span class="params">proto, propertiesObject</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> proto !== <span class="string">&quot;object&quot;</span> &amp;&amp; <span class="keyword">typeof</span> proto !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Object prototype may only be an Object: &quot;</span> + proto);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = proto;</span><br><span class="line">  <span class="keyword">const</span> o = <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (propertiesObject !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(propertiesObject).<span class="title function_">forEach</span>(<span class="function">(<span class="params">prop</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> desc = propertiesObject[prop];</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> desc !== <span class="string">&quot;object&quot;</span> || desc === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Object prorotype may only be an Object: &quot;</span> + desc);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(o, prop, desc);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h2 id="🚂-Function-篇"><a href="#🚂-Function-篇" class="headerlink" title="🚂 Function 篇"></a>🚂 Function 篇</h2><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p>考察频率: (⭐⭐⭐⭐)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span> (<span class="params">thisArg</span>) &#123;</span><br><span class="line">  thisArg = thisArg || <span class="variable language_">window</span>;</span><br><span class="line">  thisArg.<span class="property">func</span> = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">const</span> args = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    args.<span class="title function_">push</span>(<span class="string">&quot;arguments[&quot;</span> + i + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="built_in">eval</span>(<span class="string">&quot;thisArg.func(&quot;</span> + args + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  <span class="keyword">delete</span> thisArg.<span class="property">func</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>考察频率: (⭐⭐⭐⭐)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sx_bind</span> = <span class="keyword">function</span> (<span class="params">obj, ...args</span>) &#123;</span><br><span class="line">  obj = obj || <span class="variable language_">window</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> fn = <span class="title class_">Symbol</span>();</span><br><span class="line">  obj[fn] = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">const</span> _this = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">function</span> (<span class="params">...innerArgs</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, _this);</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span> <span class="keyword">instanceof</span> _this) &#123;</span><br><span class="line">      <span class="variable language_">this</span>[fn] = _this;</span><br><span class="line">      <span class="variable language_">this</span>[fn](...[...args, ...innerArgs]);</span><br><span class="line">      <span class="keyword">delete</span> <span class="variable language_">this</span>[fn];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      obj[fn](...[...args, ...innerArgs]);</span><br><span class="line">      <span class="keyword">delete</span> obj[fn];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  res.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p>考察频率: (⭐⭐⭐⭐)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span> (<span class="params">thisArg, arr</span>) &#123;</span><br><span class="line">  thisArg = thisArg || <span class="variable language_">window</span>;</span><br><span class="line">  thisArg.<span class="property">func</span> = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">const</span> args = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    args.<span class="title function_">push</span>(<span class="string">&quot;arr[&quot;</span> + i + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="built_in">eval</span>(<span class="string">&quot;thisArg.func(&quot;</span> + args + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  <span class="keyword">delete</span> thisArg.<span class="property">func</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h3 id="实现柯里化"><a href="#实现柯里化" class="headerlink" title="实现柯里化"></a>实现柯里化</h3><p>考察频率: (⭐⭐⭐)</p>
<p>参考代码[7]</p>
<h3 id="实现链式调用"><a href="#实现链式调用" class="headerlink" title="实现链式调用"></a>实现链式调用</h3><p>参考代码[8]</p>
<h3 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h3><p>参考代码[9]</p>
<h2 id="🌍-ajax-与-jsonp"><a href="#🌍-ajax-与-jsonp" class="headerlink" title="🌍 ajax 与 jsonp"></a>🌍 ajax 与 jsonp</h2><p>考察频率: (⭐⭐⭐)</p>
<h3 id="实现-ajax"><a href="#实现-ajax" class="headerlink" title="实现 ajax"></a>实现 ajax</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">&#123; url = <span class="literal">null</span>, method = <span class="string">&quot;GET&quot;</span>, dataType = <span class="string">&quot;JSON&quot;</span>, <span class="keyword">async</span> = <span class="literal">true</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    xhr.<span class="title function_">open</span>(method, url, <span class="keyword">async</span>);</span><br><span class="line">    xhr.<span class="property">responseType</span> = dataType;</span><br><span class="line">    xhr.<span class="property">onreadystatechange</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="regexp">/^[23]\d&#123;2&#125;$/</span>.<span class="title function_">test</span>(xhr.<span class="property">status</span>)) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> result = xhr.<span class="property">responseText</span>;</span><br><span class="line">        <span class="title function_">resolve</span>(result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.<span class="property">onerror</span> = <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(err);</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.<span class="title function_">send</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h3 id="实现-jsonp"><a href="#实现-jsonp" class="headerlink" title="实现 jsonp"></a>实现 jsonp</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">jsonp</span> = (<span class="params">&#123; url, params, callbackName &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">generateUrl</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> dataSrc = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">      <span class="keyword">if</span> (params.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">        dataSrc += <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>&amp;`</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dataSrc += <span class="string">`callback=<span class="subst">$&#123;callbackName&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;dataSrc&#125;</span>`</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> scriptEle = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">    scriptEle.<span class="property">src</span> = <span class="title function_">generateUrl</span>();</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(scriptEle);</span><br><span class="line">    <span class="variable language_">window</span>[callbackName] = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(data);</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">removeChild</span>(scriptEle);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h2 id="🛫-ES6-篇"><a href="#🛫-ES6-篇" class="headerlink" title="🛫 ES6 篇"></a>🛫 ES6 篇</h2><h3 id="实现-set"><a href="#实现-set" class="headerlink" title="实现 set"></a>实现 set</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Set</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = &#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">has</span>(<span class="params">element</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> element <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">items</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">add</span>(<span class="params">element</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="title function_">has</span>(element)) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">items</span>[element] = element;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">size</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">delete</span>(<span class="params">element</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">has</span>(element)) &#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">items</span>[element];</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">size</span>--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = &#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">values</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> values = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">items</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">        values.<span class="title function_">push</span>(key);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h3 id="实现-map"><a href="#实现-map" class="headerlink" title="实现 map"></a>实现 map</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defaultToString</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (key === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;NULL&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;UNDEFINED&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(key) === <span class="string">&quot;[object Object]&quot;</span> ||</span><br><span class="line">    <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(key) === <span class="string">&quot;[object Array]&quot;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> key.<span class="title function_">toString</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Map</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = &#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">set</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">items</span>[<span class="title function_">defaultToString</span>(key)] = value;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">size</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="title function_">defaultToString</span>(key)];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">has</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="title function_">defaultToString</span>(key)] !== <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">delete</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">items</span>[key];</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">size</span>--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = &#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">keys</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> keys = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">items</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">        keys.<span class="title function_">push</span>(key);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keys;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">values</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> values = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">items</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">        values.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">items</span>[key]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h3 id="实现-es6-的-class"><a href="#实现-es6-的-class" class="headerlink" title="实现 es6 的 class"></a>实现 es6 的 class</h3><p>参考代码[10]</p>
<h2 id="🦉-其他"><a href="#🦉-其他" class="headerlink" title="🦉 其他"></a>🦉 其他</h2><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>考察频率: (⭐⭐⭐⭐)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">instance_of</span>(<span class="params">Case, Constructor</span>) &#123;</span><br><span class="line">  <span class="comment">// 基本数据类型返回false</span></span><br><span class="line">  <span class="comment">// 兼容一下函数对象</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">typeof</span> <span class="title class_">Case</span> != <span class="string">&quot;object&quot;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">Case</span> != <span class="string">&quot;function&quot;</span>) || <span class="title class_">Case</span> == <span class="string">&quot;null&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="title class_">CaseProto</span> = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="title class_">Case</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 查到原型链顶端，仍未查到，返回false</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">CaseProto</span> == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 找到相同的原型</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">CaseProto</span> === <span class="title class_">Constructor</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="title class_">CaseProto</span> = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="title class_">CaseProto</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h3 id="实现千分位分隔符"><a href="#实现千分位分隔符" class="headerlink" title="实现千分位分隔符"></a>实现千分位分隔符</h3><p>考察频率: (⭐⭐⭐)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;100000000000&quot;</span>,</span><br><span class="line">  reg = <span class="regexp">/(?=(\B\d&#123;3&#125;)+$)/g</span>;</span><br><span class="line">str.<span class="title function_">replace</span>(reg, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h3 id="把一个-JSON-对象的-key-从下划线形式（Pascal）转换到小驼峰形式（Camel）"><a href="#把一个-JSON-对象的-key-从下划线形式（Pascal）转换到小驼峰形式（Camel）" class="headerlink" title="把一个 JSON 对象的 key 从下划线形式（Pascal）转换到小驼峰形式（Camel）"></a>把一个 JSON 对象的 key 从下划线形式（Pascal）转换到小驼峰形式（Camel）</h3><p>考察频率: (⭐⭐⭐)</p>
<p>参考代码[11]</p>
<h3 id="实现数据类型判断函数"><a href="#实现数据类型判断函数" class="headerlink" title="实现数据类型判断函数"></a>实现数据类型判断函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myTypeof</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>).<span class="title function_">toLowerCase</span>();</span><br><span class="line">&#125;</span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h3 id="实现数组转树"><a href="#实现数组转树" class="headerlink" title="实现数组转树"></a>实现数组转树</h3><p>参考代码[12]</p>
<h3 id="实现-sleep-函数"><a href="#实现-sleep-函数" class="headerlink" title="实现 sleep 函数"></a>实现 sleep 函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// promise</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sleep</span> = (<span class="params">time</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, time));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">sleep</span>(<span class="number">1000</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sleep</span>(<span class="params">callback, time</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">&quot;function&quot;</span>) <span class="built_in">setTimeout</span>(callback, time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">output</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sleep</span>(output, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">复制代码;</span><br></pre></td></tr></table></figure>

<h3 id="实现发布订阅模式"><a href="#实现发布订阅模式" class="headerlink" title="实现发布订阅模式"></a>实现发布订阅模式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventEmitter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">on</span>(<span class="params">name, fn</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cache</span>[name]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">cache</span>[name].<span class="title function_">push</span>(fn);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">cache</span>[name] = [fn];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">off</span>(<span class="params">name, fn</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> tasks = <span class="variable language_">this</span>.<span class="property">cache</span>[name];</span><br><span class="line">    <span class="keyword">if</span> (tasks) &#123;</span><br><span class="line">      <span class="keyword">const</span> index = tasks.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">f</span>) =&gt;</span> f === fn || f.<span class="property">callback</span> === fn);</span><br><span class="line">      <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        tasks.<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">emit</span>(<span class="params">name, once = <span class="literal">false</span>, ...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cache</span>[name]) &#123;</span><br><span class="line">      <span class="comment">// 创建副本，如果回调函数内继续注册相同事件，会造成死循环</span></span><br><span class="line">      <span class="keyword">let</span> tasks = <span class="variable language_">this</span>.<span class="property">cache</span>[name].<span class="title function_">slice</span>();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> fn <span class="keyword">of</span> tasks) &#123;</span><br><span class="line">        <span class="title function_">fn</span>(...args);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (once) &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">cache</span>[name];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="篇二"><a href="#篇二" class="headerlink" title="篇二"></a>篇二</h2><h3 id="1-call-的实现"><a href="#1-call-的实现" class="headerlink" title="1.call 的实现"></a>1.call 的实现</h3><ul>
<li>第一个参数为 null 或者 undefined 时，this 指向全局对象 window，值为原始值的指向该原始值的自动包装对象，如 String、Number、Boolean</li>
<li>为了避免函数名与上下文(context)的属性发生冲突，使用 Symbol 类型作为唯一值</li>
<li>将函数作为传入的上下文(context)属性执行</li>
<li>函数执行完成后删除该属性</li>
<li>返回执行结果</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span> (<span class="params">context, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> cxt = context || <span class="variable language_">window</span>;</span><br><span class="line">  <span class="comment">//将当前被调用的方法定义在cxt.func上.(为了能以对象调用形式绑定this)</span></span><br><span class="line">  <span class="comment">//新建一个唯一的Symbol变量避免重复</span></span><br><span class="line">  <span class="keyword">let</span> func = <span class="title class_">Symbol</span>();</span><br><span class="line">  cxt[func] = <span class="variable language_">this</span>;</span><br><span class="line">  args = args ? args : [];</span><br><span class="line">  <span class="comment">//以对象调用形式调用func,此时this指向cxt 也就是传入的需要绑定的this指向</span></span><br><span class="line">  <span class="keyword">const</span> res = args.<span class="property">length</span> &gt; <span class="number">0</span> ? cxt[func](...args) : cxt[func]();</span><br><span class="line">  <span class="comment">//删除该方法，不然会对传入对象造成污染（添加该方法）</span></span><br><span class="line">  <span class="keyword">delete</span> cxt[func];</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-apply-的实现"><a href="#2-apply-的实现" class="headerlink" title="2.apply 的实现"></a>2.apply 的实现</h3><ul>
<li>前部分与 call 一样</li>
<li>第二个参数可以不传，但类型必须为数组或者类数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span> (<span class="params">context, args = []</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> cxt = context || <span class="variable language_">window</span>;</span><br><span class="line">  <span class="comment">//将当前被调用的方法定义在cxt.func上.(为了能以对象调用形式绑定this)</span></span><br><span class="line">  <span class="comment">//新建一个唯一的Symbol变量避免重复</span></span><br><span class="line">  <span class="keyword">let</span> func = <span class="title class_">Symbol</span>();</span><br><span class="line">  cxt[func] = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">//以对象调用形式调用func,此时this指向cxt 也就是传入的需要绑定的this指向</span></span><br><span class="line">  <span class="keyword">const</span> res = args.<span class="property">length</span> &gt; <span class="number">0</span> ? cxt[func](...args) : cxt[func]();</span><br><span class="line">  <span class="keyword">delete</span> cxt[func];</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-bind-的实现"><a href="#3-bind-的实现" class="headerlink" title="3.bind 的实现"></a>3.bind 的实现</h3><p>需要考虑：</p>
<ul>
<li>bind() 除了 this 外，还可传入多个参数；</li>
<li>bind 创建的新函数可能传入多个参数；</li>
<li>新函数可能被当做构造函数调用；</li>
<li>函数可能有返回值；</li>
</ul>
<p>实现方法：</p>
<ul>
<li>bind 方法不会立即执行，需要返回一个待执行的函数；（闭包）</li>
<li>实现作用域绑定（apply）</li>
<li>参数传递（apply 的数组传参）</li>
<li>当作为构造函数的时候，进行原型继承</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span> (<span class="params">context, ...args</span>) &#123;</span><br><span class="line">  <span class="comment">//新建一个变量赋值为this，表示当前函数</span></span><br><span class="line">  <span class="keyword">const</span> fn = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">//判断有没有传参进来，若为空则赋值[]</span></span><br><span class="line">  args = args ? args : [];</span><br><span class="line">  <span class="comment">//返回一个newFn函数，在里面调用fn</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">newFn</span>(<span class="params">...newFnArgs</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span> <span class="keyword">instanceof</span> newFn) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">fn</span>(...args, ...newFnArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(context, [...args, ...newFnArgs]);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;小王&quot;</span>,</span><br><span class="line">  age = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;小张&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="variable language_">this</span>.<span class="property">age</span>,</span><br><span class="line">  <span class="attr">myFun</span>: <span class="keyword">function</span> (<span class="params"><span class="keyword">from</span>, to</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; 年龄 &quot;</span> + <span class="variable language_">this</span>.<span class="property">age</span> + <span class="string">&quot;来自 &quot;</span> + <span class="keyword">from</span> + <span class="string">&quot;去往&quot;</span> + to);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> db = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;德玛&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">99</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">obj.<span class="property">myFun</span>.<span class="title function_">myCall</span>(db, <span class="string">&quot;成都&quot;</span>, <span class="string">&quot;上海&quot;</span>); <span class="comment">// 德玛 年龄 99  来自 成都去往上海</span></span><br><span class="line">obj.<span class="property">myFun</span>.<span class="title function_">myApply</span>(db, [<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;上海&quot;</span>]); <span class="comment">// 德玛 年龄 99  来自 成都去往上海</span></span><br><span class="line">obj.<span class="property">myFun</span>.<span class="title function_">myBind</span>(db, <span class="string">&quot;成都&quot;</span>, <span class="string">&quot;上海&quot;</span>)(); <span class="comment">// 德玛 年龄 99  来自 成都去往上海</span></span><br><span class="line">obj.<span class="property">myFun</span>.<span class="title function_">myBind</span>(db, [<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;上海&quot;</span>])(); <span class="comment">// 德玛 年龄 99  来自 成都, 上海去往 undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="4-寄生式组合继承"><a href="#4-寄生式组合继承" class="headerlink" title="4.寄生式组合继承"></a>4.寄生式组合继承</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = obj.<span class="property">name</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = obj.<span class="property">age</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">add</span> = <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;番茄&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person1</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, obj);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sex</span> = obj.<span class="property">sex</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这一步是继承的关键</span></span><br><span class="line"><span class="title class_">Person1</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Person1</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Person1</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person1</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">play</span> = <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Person1</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;鸡蛋&quot;</span>, <span class="attr">age</span>: <span class="number">118</span>, <span class="attr">sex</span>: <span class="string">&quot;男&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="5-ES6-继承"><a href="#5-ES6-继承" class="headerlink" title="5.ES6 继承"></a>5.ES6 继承</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//class 相当于es5中构造函数</span></span><br><span class="line"><span class="comment">//class中定义方法时，前后不能加function，全部定义在class的protopyte属性中</span></span><br><span class="line"><span class="comment">//class中定义的所有方法是不可枚举的</span></span><br><span class="line"><span class="comment">//class中只能定义方法，不能定义对象，变量等</span></span><br><span class="line"><span class="comment">//class和方法内默认都是严格模式</span></span><br><span class="line"><span class="comment">//es5中constructor为隐式属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name = <span class="string">&quot;wang&quot;</span>, age = <span class="string">&quot;27&quot;</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">eat</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span> eat food`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Woman</span> <span class="keyword">extends</span> <span class="title class_ inherited__">People</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name = <span class="string">&quot;ren&quot;</span>, age = <span class="string">&quot;27&quot;</span></span>) &#123;</span><br><span class="line">    <span class="comment">//继承父类属性</span></span><br><span class="line">    <span class="variable language_">super</span>(name, age);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">eat</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//继承父类方法</span></span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">eat</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> wonmanObj = <span class="keyword">new</span> <span class="title class_">Woman</span>(<span class="string">&quot;xiaoxiami&quot;</span>);</span><br><span class="line">wonmanObj.<span class="title function_">eat</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//es5继承先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.apply(this)）。</span></span><br><span class="line"><span class="comment">//es6继承是使用关键字super先创建父类的实例对象this，最后在子类class中修改this。</span></span><br></pre></td></tr></table></figure>

<h3 id="6-new-的实现"><a href="#6-new-的实现" class="headerlink" title="6.new 的实现"></a>6.new 的实现</h3><ul>
<li>一个继承自 Foo.prototype 的新对象被创建。</li>
<li>使用指定的参数调用构造函数 Foo，并将 this 绑定到新创建的对象。new Foo 等同于 new Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况。</li>
<li>由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤 1 创建的对象。</li>
<li>一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Ctor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myNew</span>(<span class="params">ctor,...args</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> ctor !== <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&#x27;myNew function the first param must be a function&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> newObj = <span class="title class_">Object</span>.<span class="title function_">create</span>(ctor.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">//创建一个继承自ctor.prototype的新对象</span></span><br><span class="line">    <span class="keyword">var</span> ctorReturnResult = ctor.<span class="title function_">apply</span>(newObj, args); <span class="comment">//将构造函数ctor的this绑定到newObj中</span></span><br><span class="line">    <span class="keyword">var</span> isObject = <span class="keyword">typeof</span> ctorReturnResult === <span class="string">&#x27;object&#x27;</span> &amp;&amp; ctorReturnResult !== <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> isFunction = <span class="keyword">typeof</span> ctorReturnResult === <span class="string">&#x27;function&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(isObject || isFunction)&#123;</span><br><span class="line">        <span class="keyword">return</span> ctorReturnResult;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="title function_">myNew</span>(<span class="title class_">Ctor</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="7-instanceof-的实现"><a href="#7-instanceof-的实现" class="headerlink" title="7.instanceof 的实现"></a>7.instanceof 的实现</h3><ul>
<li>instanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。</li>
<li>instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。</li>
<li>不能检测基本数据类型，在原型链上的结果未必准确，不能检测 null,undefined</li>
<li>实现：遍历左边变量的原型链，直到找到右边变量的 prototype，如果没有找到，返回 false</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceOf</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> left = a.<span class="property">__proto__</span>;</span><br><span class="line">  <span class="keyword">let</span> right = b.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    left = left.<span class="property">__proto__</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(left), <span class="comment">// 获取对象的原型</span></span><br><span class="line">    prototype = right.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// 获取构造函数的 prototype 对象</span></span><br><span class="line">  <span class="comment">// 判断构造函数的 prototype 对象是否在对象的原型链上</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!proto) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (proto === prototype) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(proto);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-Object-create-的实现"><a href="#8-Object-create-的实现" class="headerlink" title="8.Object.create()的实现"></a>8.Object.create()的实现</h3><ul>
<li>MDN 文档</li>
<li>Object.create()会将参数对象作为一个新创建的空对象的原型, 并返回这个空对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简略版</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myCreate</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="comment">// 新声明一个函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="comment">// 将函数的原型指向obj</span></span><br><span class="line">  C.<span class="property"><span class="keyword">prototype</span></span> = obj;</span><br><span class="line">  <span class="comment">// 返回这个函数的实力化对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//官方版Polyfill</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Object</span>.<span class="property">create</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="property">create</span> = <span class="keyword">function</span> (<span class="params">proto, propertiesObject</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> proto !== <span class="string">&quot;object&quot;</span> &amp;&amp; <span class="keyword">typeof</span> proto !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Object prototype may only be an Object: &quot;</span> + proto);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (proto === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(</span><br><span class="line">        <span class="string">&quot;This browser&#x27;s implementation of Object.create is a shim and doesn&#x27;t support &#x27;null&#x27; as the first argument.&quot;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> propertiesObject !== <span class="string">&quot;undefined&quot;</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(</span><br><span class="line">        <span class="string">&quot;This browser&#x27;s implementation of Object.create is a shim and doesn&#x27;t support a second argument.&quot;</span></span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = proto;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-实现-Object-assign"><a href="#9-实现-Object-assign" class="headerlink" title="9.实现 Object.assign"></a>9.实现 Object.assign</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property">assign2</span> = <span class="keyword">function</span> (<span class="params">target, ...source</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (target == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Cannot convert undefined or null to object&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> ret = <span class="title class_">Object</span>(target);</span><br><span class="line">  source.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">          ret[key] = obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="10-Promise-的实现"><a href="#10-Promise-的实现" class="headerlink" title="10.Promise 的实现"></a>10.Promise 的实现</h3><p>实现 Promise 需要完全读懂 Promise A+ 规范，不过从总体的实现上看，有如下几个点需要考虑到：</p>
<ul>
<li>Promise 本质是一个状态机，且状态只能为以下三种：Pending（等待态）、Fulfilled（执行态）、Rejected（拒绝态），状态的变更是单向的，只能从 Pending -&gt; Fulfilled 或 Pending -&gt; Rejected，状态变更不可逆</li>
<li>then 需要支持链式调用</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line">  callbacks = [];</span><br><span class="line">  state = <span class="string">&quot;pending&quot;</span>; <span class="comment">//增加状态</span></span><br><span class="line">  value = <span class="literal">null</span>; <span class="comment">//保存结果</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="title function_">fn</span>(<span class="variable language_">this</span>.<span class="property">_resolve</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="variable language_">this</span>.<span class="property">_reject</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">_handle</span>(&#123;</span><br><span class="line">        <span class="attr">onFulfilled</span>: onFulfilled || <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">onRejected</span>: onRejected || <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">resolve</span>: resolve,</span><br><span class="line">        <span class="attr">reject</span>: reject,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">_handle</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">push</span>(callback);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> cb =</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&quot;fulfilled&quot;</span> ? callback.<span class="property">onFulfilled</span> : callback.<span class="property">onRejected</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cb) &#123;</span><br><span class="line">      <span class="comment">//如果then中没有传递任何东西</span></span><br><span class="line">      cb = <span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&quot;fulfilled&quot;</span> ? callback.<span class="property">resolve</span> : callback.<span class="property">reject</span>;</span><br><span class="line">      <span class="title function_">cb</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> ret = <span class="title function_">cb</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">    cb = <span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&quot;fulfilled&quot;</span> ? callback.<span class="property">resolve</span> : callback.<span class="property">reject</span>;</span><br><span class="line">    <span class="title function_">cb</span>(ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">_resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; (<span class="keyword">typeof</span> value === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> value === <span class="string">&quot;function&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">var</span> then = value.<span class="property">then</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        then.<span class="title function_">call</span>(value, <span class="variable language_">this</span>.<span class="property">_resolve</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="variable language_">this</span>.<span class="property">_reject</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;fulfilled&quot;</span>; <span class="comment">//改变状态</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value; <span class="comment">//保存结果</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">callback</span>) =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">_handle</span>(callback));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">_reject</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = error;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">callback</span>) =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">_handle</span>(callback));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h4><ul>
<li>Promsie.resolve(value) 可以将任何值转成值为 value 状态是 fulfilled 的 Promise，但如果传入的值本身是 Promise 则会原样返回它。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (value &amp;&amp; value <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &amp;&amp; <span class="keyword">typeof</span> value === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> value.<span class="property">then</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> then = value.<span class="property">then</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">then</span>(resolve);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(value));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h4><ul>
<li>和 Promise.resolve() 类似，Promise.reject() 会实例化一个 rejected 状态的 Promise。但与 Promise.resolve() 不同的是，如果给 Promise.reject() 传递一个 Promise 对象，则这个对象会成为新 Promise 的值。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">reject</span> = <span class="keyword">function</span> (<span class="params">reason</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>(reason));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h4><ul>
<li>传入的所有 Promsie 都是 fulfilled，则返回由他们的值组成的，状态为 fulfilled 的新 Promise；</li>
<li>只要有一个 Promise 是 rejected，则返回 rejected 状态的新 Promsie，且它的值是第一个 rejected 的 Promise 的值；</li>
<li>只要有一个 Promise 是 pending，则返回一个 pending 状态的新 Promise；</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">all</span> = <span class="keyword">function</span> (<span class="params">promiseArr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>,</span><br><span class="line">    result = [];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    promiseArr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">p, i</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(p).<span class="title function_">then</span>(</span><br><span class="line">        <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">          index++;</span><br><span class="line">          result[i] = val;</span><br><span class="line">          <span class="keyword">if</span> (index === promiseArr.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">reject</span>(err);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h4><ul>
<li>Promise.race 会返回一个由所有可迭代实例中第一个 fulfilled 或 rejected 的实例包装后的新实例。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">race</span> = <span class="keyword">function</span> (<span class="params">promiseArr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    promiseArr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">p</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(p).<span class="title function_">then</span>(</span><br><span class="line">        <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(val);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">rejecte</span>(err);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="11-Ajax-的实现"><a href="#11-Ajax-的实现" class="headerlink" title="11.Ajax 的实现"></a>11.Ajax 的实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">url, method, body, headers</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> req = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    req.<span class="title function_">open</span>(methods, url);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> headers) &#123;</span><br><span class="line">      req.<span class="title function_">setRequestHeader</span>(key, headers[key]);</span><br><span class="line">    &#125;</span><br><span class="line">    req.<span class="title function_">onreadystatechange</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (req.<span class="property">readystate</span> == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (req.<span class="property">status</span> &gt;= <span class="string">&quot;200&quot;</span> &amp;&amp; req.<span class="property">status</span> &lt;= <span class="number">300</span>) &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(req.<span class="property">responeText</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="title function_">reject</span>(req);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    req.<span class="title function_">send</span>(body);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-实现防抖函数（debounce）"><a href="#12-实现防抖函数（debounce）" class="headerlink" title="12.实现防抖函数（debounce）"></a>12.实现防抖函数（debounce）</h3><ul>
<li>连续触发在最后一次执行方法，场景：输入框匹配</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">debounce</span> = (<span class="params">fn, time = <span class="number">1000</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> timeLock = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeLock);</span><br><span class="line">    timeLock = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">fn</span>(...args);</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="13-实现节流函数（throttle）"><a href="#13-实现节流函数（throttle）" class="headerlink" title="13.实现节流函数（throttle）"></a>13.实现节流函数（throttle）</h3><ul>
<li>在一定时间内只触发一次，场景：长列表滚动节流</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">throttle</span> = (<span class="params">fn, time = <span class="number">1000</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">      flag = <span class="literal">false</span>;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="title function_">fn</span>(...args);</span><br><span class="line">      &#125;, time);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="14-深拷贝（deepclone）"><a href="#14-深拷贝（deepclone）" class="headerlink" title="14.深拷贝（deepclone）"></a>14.深拷贝（deepclone）</h3><ul>
<li>判断类型，正则和日期直接返回新对象</li>
<li>空或者非对象类型，直接返回原值</li>
<li>考虑循环引用，判断如果 hash 中含有直接返回 hash 中的值</li>
<li>新建一个相应的 new obj.constructor 加入 hash</li>
<li>遍历对象递归（普通 key 和 key 是 symbol 情况）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(obj);</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(obj);</span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="comment">//循环引用的情况</span></span><br><span class="line">  <span class="keyword">if</span> (hash.<span class="title function_">has</span>(obj)) &#123;</span><br><span class="line">    <span class="keyword">return</span> hash.<span class="title function_">get</span>(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//new 一个相应的对象</span></span><br><span class="line">  <span class="comment">//obj为Array，相当于new Array()</span></span><br><span class="line">  <span class="comment">//obj为Object，相当于new Object()</span></span><br><span class="line">  <span class="keyword">let</span> constr = <span class="keyword">new</span> obj.<span class="title function_">constructor</span>(<span class="params"></span>);</span><br><span class="line">  hash.<span class="title function_">set</span>(obj, constr);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      constr[key] = <span class="title function_">deepClone</span>(obj[key], hash);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//考虑symbol的情况</span></span><br><span class="line">  <span class="keyword">let</span> symbolObj = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(obj);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; symbolObj.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(symbolObj[i])) &#123;</span><br><span class="line">      constr[symbolObj[i]] = <span class="title function_">deepClone</span>(obj[symbolObj[i]], hash);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> constr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-数组扁平化的实现-flat"><a href="#15-数组扁平化的实现-flat" class="headerlink" title="15.数组扁平化的实现(flat)"></a>15.数组扁平化的实现(flat)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, [<span class="number">6</span>]]]];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">flat</span>(<span class="title class_">Infinity</span>)); <span class="comment">//flat参数为指定要提取嵌套数组的结构深度，默认值为 1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用reduce实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> prev.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(cur) ? <span class="title function_">fn</span>(cur) : cur);</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-函数柯里化"><a href="#16-函数柯里化" class="headerlink" title="16.函数柯里化"></a>16.函数柯里化</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sumFn</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> sum = <span class="title function_">curry</span>(sumFn);</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">5</span>); <span class="comment">//10</span></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">2</span>, <span class="number">3</span>)(<span class="number">5</span>); <span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> fnLen = fn.<span class="property">length</span>,</span><br><span class="line">    argsLen = args.<span class="property">length</span>;</span><br><span class="line">  <span class="comment">//对比函数的参数和当前传入参数</span></span><br><span class="line">  <span class="comment">//若参数不够就继续递归返回curry</span></span><br><span class="line">  <span class="comment">//若参数够就调用函数返回相应的值</span></span><br><span class="line">  <span class="keyword">if</span> (fnLen &gt; argsLen) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...arg2s</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">curry</span>(fn, ...args, ...arg2s);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fn</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-使用闭包实现每隔一秒打印-1-2-3-4"><a href="#17-使用闭包实现每隔一秒打印-1-2-3-4" class="headerlink" title="17.使用闭包实现每隔一秒打印 1,2,3,4"></a>17.使用闭包实现每隔一秒打印 1,2,3,4</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="keyword">function</span> (<span class="params">i</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(i), <span class="number">1000</span> * i);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-手写一个-jsonp"><a href="#18-手写一个-jsonp" class="headerlink" title="18.手写一个 jsonp"></a>18.手写一个 jsonp</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> jsonp = <span class="keyword">function</span> (<span class="params">url, data</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化url</span></span><br><span class="line">    <span class="keyword">let</span> dataString = url.<span class="title function_">indexOf</span>(<span class="string">&quot;?&quot;</span>) === -<span class="number">1</span> ? <span class="string">&quot;?&quot;</span> : <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> callbackName = <span class="string">`jsonpCB_<span class="subst">$&#123;<span class="built_in">Date</span>.now()&#125;</span>`</span>;</span><br><span class="line">    url += <span class="string">`<span class="subst">$&#123;dataString&#125;</span>callback=<span class="subst">$&#123;callbackName&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">      <span class="comment">// 有请求参数，依次添加到url</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> data) &#123;</span><br><span class="line">        url += <span class="string">`<span class="subst">$&#123;k&#125;</span>=<span class="subst">$&#123;data[k]&#125;</span>`</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> jsNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">    jsNode.<span class="property">src</span> = url;</span><br><span class="line">    <span class="comment">// 触发callback，触发后删除js标签和绑定在window上的callback</span></span><br><span class="line">    <span class="variable language_">window</span>[callbackName] = <span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="variable language_">window</span>[callbackName];</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(jsNode);</span><br><span class="line">      <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(result);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="string">&quot;没有返回数据&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// js加载异常的情况</span></span><br><span class="line">    jsNode.<span class="title function_">addEventListener</span>(</span><br><span class="line">      <span class="string">&quot;error&quot;</span>,</span><br><span class="line">      <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="variable language_">window</span>[callbackName];</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(jsNode);</span><br><span class="line">        <span class="title function_">reject</span>(<span class="string">&quot;JavaScript资源加载失败&quot;</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="literal">false</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 添加js节点到document上时，开始请求</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(jsNode);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">jsonp</span>(<span class="string">&quot;http://192.168.0.103:8081/jsonp&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="string">&quot;heiheihei&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="19-手写一个观察者模式"><a href="#19-手写一个观察者模式" class="headerlink" title="19.手写一个观察者模式"></a>19.手写一个观察者模式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;XXXX&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 被观察者要提供一个接受观察者的方法</span></span><br><span class="line">  <span class="title function_">attach</span>(<span class="params">observer</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">push</span>(observer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 改变被观察着的状态</span></span><br><span class="line">  <span class="title function_">setState</span>(<span class="params">newState</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = newState;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">o</span>) =&gt;</span> &#123;</span><br><span class="line">      o.<span class="title function_">update</span>(newState);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">update</span>(<span class="params">newState</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>say:<span class="subst">$&#123;newState&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被观察者 灯</span></span><br><span class="line"><span class="keyword">let</span> sub = <span class="keyword">new</span> <span class="title class_">Subject</span>(<span class="string">&quot;灯&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> mm = <span class="keyword">new</span> <span class="title class_">Observer</span>(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> jj = <span class="keyword">new</span> <span class="title class_">Observer</span>(<span class="string">&quot;小健&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅 观察者</span></span><br><span class="line">sub.<span class="title function_">attach</span>(mm);</span><br><span class="line">sub.<span class="title function_">attach</span>(jj);</span><br><span class="line"></span><br><span class="line">sub.<span class="title function_">setState</span>(<span class="string">&quot;灯亮了来电了&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="20-EventEmitter-实现"><a href="#20-EventEmitter-实现" class="headerlink" title="20.EventEmitter 实现"></a>20.EventEmitter 实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventEmitter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">on</span>(<span class="params">event, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> callbacks = <span class="variable language_">this</span>.<span class="property">events</span>[event] || [];</span><br><span class="line">    callbacks.<span class="title function_">push</span>(callback);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>[event] = callbacks;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">off</span>(<span class="params">event, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> callbacks = <span class="variable language_">this</span>.<span class="property">events</span>[event];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>[event] = callbacks &amp;&amp; callbacks.<span class="title function_">filter</span>(<span class="function">(<span class="params">fn</span>) =&gt;</span> fn !== callback);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">emit</span>(<span class="params">event, ...args</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> callbacks = <span class="variable language_">this</span>.<span class="property">events</span>[event];</span><br><span class="line">    callbacks.<span class="title function_">forEach</span>(<span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">fn</span>(...args);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">once</span>(<span class="params">event, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> wrapFun = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">      <span class="title function_">callback</span>(...args);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">off</span>(event, wrapFun);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">on</span>(event, wrapFun);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="21-生成随机数的各种方法？"><a href="#21-生成随机数的各种方法？" class="headerlink" title="21.生成随机数的各种方法？"></a>21.生成随机数的各种方法？</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getRandom</span>(<span class="params">min, max</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (max - min)) + min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="22-如何实现数组的随机排序？"><a href="#22-如何实现数组的随机排序？" class="headerlink" title="22.如何实现数组的随机排序？"></a>22.如何实现数组的随机排序？</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">454</span>, <span class="number">34</span>, <span class="number">324</span>, <span class="number">32</span>];</span><br><span class="line">arr.<span class="title function_">sort</span>(randomSort);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">randomSort</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">random</span>() &gt; <span class="number">0.5</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23-写一个通用的事件侦听器函数。"><a href="#23-写一个通用的事件侦听器函数。" class="headerlink" title="23.写一个通用的事件侦听器函数。"></a>23.写一个通用的事件侦听器函数。</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">EventUtils</span> = &#123;</span><br><span class="line">  <span class="comment">// 视能力分别使用dom0||dom2||IE方式 来绑定事件</span></span><br><span class="line">  <span class="comment">// 添加事件</span></span><br><span class="line">  <span class="attr">addEvent</span>: <span class="keyword">function</span> (<span class="params">element, type, handler</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (element.<span class="property">addEventListener</span>) &#123;</span><br><span class="line">      element.<span class="title function_">addEventListener</span>(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.<span class="property">attachEvent</span>) &#123;</span><br><span class="line">      element.<span class="title function_">attachEvent</span>(<span class="string">&quot;on&quot;</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">&quot;on&quot;</span> + type] = handler;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 移除事件</span></span><br><span class="line">  <span class="attr">removeEvent</span>: <span class="keyword">function</span> (<span class="params">element, type, handler</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (element.<span class="property">removeEventListener</span>) &#123;</span><br><span class="line">      element.<span class="title function_">removeEventListener</span>(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.<span class="property">detachEvent</span>) &#123;</span><br><span class="line">      element.<span class="title function_">detachEvent</span>(<span class="string">&quot;on&quot;</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">&quot;on&quot;</span> + type] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 获取事件目标</span></span><br><span class="line">  <span class="attr">getTarget</span>: <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> event.<span class="property">target</span> || event.<span class="property">srcElement</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event</span></span><br><span class="line">  <span class="attr">getEvent</span>: <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> event || <span class="variable language_">window</span>.<span class="property">event</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获）</span></span><br><span class="line">  <span class="attr">stopPropagation</span>: <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">stopPropagation</span>) &#123;</span><br><span class="line">      event.<span class="title function_">stopPropagation</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.<span class="property">cancelBubble</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 取消事件的默认行为</span></span><br><span class="line">  <span class="attr">preventDefault</span>: <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">preventDefault</span>) &#123;</span><br><span class="line">      event.<span class="title function_">preventDefault</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.<span class="property">returnValue</span> = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="24-使用迭代的方式实现-flatten-函数。"><a href="#24-使用迭代的方式实现-flatten-函数。" class="headerlink" title="24.使用迭代的方式实现 flatten 函数。"></a>24.使用迭代的方式实现 flatten 函数。</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, [<span class="number">7</span>, [<span class="number">8</span>]]]];</span><br><span class="line"><span class="comment">/** * 使用递归的方式处理 * wrap 内保</span></span><br><span class="line"><span class="comment">存结果 ret * 返回一个递归函数 **/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">wrap</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ret = [];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">flat</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">of</span> a) &#123;</span><br><span class="line">      <span class="keyword">if</span> (item.<span class="property">constructor</span> === <span class="title class_">Array</span>) &#123;</span><br><span class="line">        ret.<span class="title function_">concat</span>(<span class="title function_">flat</span>(item));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret.<span class="title function_">push</span>(item);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">wrap</span>()(arr));</span><br></pre></td></tr></table></figure>

<h3 id="25-怎么实现一个-sleep"><a href="#25-怎么实现一个-sleep" class="headerlink" title="25.怎么实现一个 sleep"></a>25.怎么实现一个 sleep</h3><ul>
<li>sleep 函数作用是让线程休眠，等到指定时间在重新唤起。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sleep</span>(<span class="params">delay</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> start = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>() - start &lt; delay) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">  <span class="title function_">sleep</span>(<span class="number">2000</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>();</span><br></pre></td></tr></table></figure>

<h3 id="26-实现正则切分千分位（10000-10-000）"><a href="#26-实现正则切分千分位（10000-10-000）" class="headerlink" title="26.实现正则切分千分位（10000 &#x3D;&gt; 10,000）"></a>26.实现正则切分千分位（10000 &#x3D;&gt; 10,000）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无小数点</span></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="string">&quot;1321434322222&quot;</span>;</span><br><span class="line">num1.<span class="title function_">replace</span>(<span class="regexp">/(\d)(?=(\d&#123;3&#125;)+$)/g</span>, <span class="string">&quot;$1,&quot;</span>);</span><br><span class="line"><span class="comment">//有小数点</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="string">&quot;342243242322.3432423&quot;</span>;</span><br><span class="line">num2.<span class="title function_">replace</span>(<span class="regexp">/(\d)(?=(\d&#123;3&#125;)+\.)/g</span>, <span class="string">&quot;$1,&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="27-对象数组去重"><a href="#27-对象数组去重" class="headerlink" title="27.对象数组去重"></a>27.对象数组去重</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">输入: [</span><br><span class="line">  &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>, <span class="attr">a</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">d</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;,</span><br><span class="line">];</span><br><span class="line">输出: [</span><br><span class="line">  &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">d</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<ul>
<li>首先写一个函数把对象中的 key 排序，然后再转成字符串</li>
<li>遍历数组利用 Set 将转为字符串后的对象去重</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">objSort</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> newObj = &#123;&#125;;</span><br><span class="line">  <span class="comment">//遍历对象，并将key进行排序</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)</span><br><span class="line">    .<span class="title function_">sort</span>()</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">      newObj[key] = obj[key];</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="comment">//将排序好的数组转成字符串</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(newObj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="title function_">objSort</span>(arr[i]);</span><br><span class="line">    set.<span class="title function_">add</span>(str);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将数组中的字符串转回对象</span></span><br><span class="line">  arr = [...set].<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(item);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="28-解析-URL-Params-为对象"><a href="#28-解析-URL-Params-为对象" class="headerlink" title="28.解析 URL Params 为对象"></a>28.解析 URL Params 为对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> url =</span><br><span class="line">  <span class="string">&quot;http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled&quot;</span>;</span><br><span class="line"><span class="title function_">parseParam</span>(url);</span><br><span class="line"><span class="comment">/* 结果</span></span><br><span class="line"><span class="comment">&#123; user: &#x27;anonymous&#x27;,</span></span><br><span class="line"><span class="comment">  id: [ 123, 456 ], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型</span></span><br><span class="line"><span class="comment">  city: &#x27;北京&#x27;, // 中文需解码</span></span><br><span class="line"><span class="comment">  enabled: true, // 未指定值得 key 约定为 true</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">parseParam</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> paramsStr = <span class="regexp">/.+\?(.+)$/</span>.<span class="title function_">exec</span>(url)[<span class="number">1</span>]; <span class="comment">// 将 ? 后面的字符串取出来</span></span><br><span class="line">  <span class="keyword">const</span> paramsArr = paramsStr.<span class="title function_">split</span>(<span class="string">&quot;&amp;&quot;</span>); <span class="comment">// 将字符串以 &amp; 分割后存到数组中</span></span><br><span class="line">  <span class="keyword">let</span> paramsObj = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 将 params 存到对象中</span></span><br><span class="line">  paramsArr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">param</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/=/</span>.<span class="title function_">test</span>(param)) &#123;</span><br><span class="line">      <span class="comment">// 处理有 value 的参数</span></span><br><span class="line">      <span class="keyword">let</span> [key, val] = param.<span class="title function_">split</span>(<span class="string">&quot;=&quot;</span>); <span class="comment">// 分割 key 和 value</span></span><br><span class="line">      val = <span class="built_in">decodeURIComponent</span>(val); <span class="comment">// 解码</span></span><br><span class="line">      val = <span class="regexp">/^\d+$/</span>.<span class="title function_">test</span>(val) ? <span class="built_in">parseFloat</span>(val) : val; <span class="comment">// 判断是否转为数字</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (paramsObj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">        <span class="comment">// 如果对象有 key，则添加一个值</span></span><br><span class="line">        paramsObj[key] = [].<span class="title function_">concat</span>(paramsObj[key], val);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果对象没有这个 key，创建 key 并设置值</span></span><br><span class="line">        paramsObj[key] = val;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 处理没有 value 的参数</span></span><br><span class="line">      paramsObj[param] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> paramsObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="29-模板引擎实现"><a href="#29-模板引擎实现" class="headerlink" title="29.模板引擎实现"></a>29.模板引擎实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> template = <span class="string">&quot;我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;姓名&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">render</span>(template, data); <span class="comment">// 我是姓名，年龄18，性别undefined</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">template, data</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> reg = <span class="regexp">/\&#123;\&#123;(\w+)\&#125;\&#125;/</span>; <span class="comment">// 模板字符串正则</span></span><br><span class="line">  <span class="keyword">if</span> (reg.<span class="title function_">test</span>(template)) &#123;</span><br><span class="line">    <span class="comment">// 判断模板里是否有模板字符串</span></span><br><span class="line">    <span class="keyword">const</span> name = reg.<span class="title function_">exec</span>(template)[<span class="number">1</span>]; <span class="comment">// 查找当前模板里第一个模板字符串的字段</span></span><br><span class="line">    template = template.<span class="title function_">replace</span>(reg, data[name]); <span class="comment">// 将第一个模板字符串渲染</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">render</span>(template, data); <span class="comment">// 递归的渲染并返回渲染后的结构</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> template; <span class="comment">// 如果模板没有模板字符串直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="30-转化为驼峰命名"><a href="#30-转化为驼峰命名" class="headerlink" title="30.转化为驼峰命名"></a>30.转化为驼峰命名</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&quot;get-element-by-id&quot;</span>;</span><br><span class="line"><span class="comment">// 转化为 getElementById</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> s.<span class="title function_">replace</span>(<span class="regexp">/-\w/g</span>, <span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x.<span class="title function_">slice</span>(<span class="number">1</span>).<span class="title function_">toUpperCase</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="31-查找字符串中出现最多的字符和个数"><a href="#31-查找字符串中出现最多的字符和个数" class="headerlink" title="31.查找字符串中出现最多的字符和个数"></a>31.查找字符串中出现最多的字符和个数</h3><ul>
<li>例: abbcccddddd -&gt; 字符最多的是 d，出现了 5 次</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abcabcabcbbccccc&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> char = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使其按照一定的次序排列</span></span><br><span class="line">str = str.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">sort</span>().<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">// &quot;aaabbbbbcccccccc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义正则表达式</span></span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(\w)\1+/g</span>;</span><br><span class="line">str.<span class="title function_">replace</span>(re, <span class="function">(<span class="params">$0, $1</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (num &lt; $0.<span class="property">length</span>) &#123;</span><br><span class="line">    num = $0.<span class="property">length</span>;</span><br><span class="line">    char = $1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`字符最多的是<span class="subst">$&#123;char&#125;</span>，出现了<span class="subst">$&#123;num&#125;</span>次`</span>);</span><br></pre></td></tr></table></figure>

<h3 id="32-图片懒加载"><a href="#32-图片懒加载" class="headerlink" title="32.图片懒加载"></a>32.图片懒加载</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> imgList = [...<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;img&quot;</span>)];</span><br><span class="line"><span class="keyword">let</span> length = imgList.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> imgLazyLoad = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> deleteIndexList = [];</span><br><span class="line">    imgList.<span class="title function_">forEach</span>(<span class="function">(<span class="params">img, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> rect = img.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line">      <span class="keyword">if</span> (rect.<span class="property">top</span> &lt; <span class="variable language_">window</span>.<span class="property">innerHeight</span>) &#123;</span><br><span class="line">        img.<span class="property">src</span> = img.<span class="property">dataset</span>.<span class="property">src</span>;</span><br><span class="line">        deleteIndexList.<span class="title function_">push</span>(index);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count === length) &#123;</span><br><span class="line">          <span class="variable language_">document</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;scroll&quot;</span>, imgLazyLoad);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    imgList = imgList.<span class="title function_">filter</span>(<span class="function">(<span class="params">img, index</span>) =&gt;</span> !deleteIndexList.<span class="title function_">includes</span>(index));</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里最好加上防抖处理</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;scroll&quot;</span>, imgLazyLoad);</span><br></pre></td></tr></table></figure>

<p>有些重复的，可做参考 ⭐ 。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>阮一峰ES6入门学习笔记</title>
    <url>/post/d6c2d8fc1a5a/</url>
    <content><![CDATA[<h1 id="阮一峰ES6入门学习笔记"><a href="#阮一峰ES6入门学习笔记" class="headerlink" title="阮一峰ES6入门学习笔记"></a>阮一峰ES6入门学习笔记</h1><h2 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h2><ul>
<li><p><code>let</code>只会在命令所在代码块内生效</p>
</li>
<li><p>在<code>for</code>循环中使用<code>let</code>，会在设置循环变量的地方建立一个父作用域（即<code>for</code>代码块内依旧可以声明同名变量</p>
</li>
<li><p>相比较<code>var</code>，<code>let</code>不能在声明之前使用</p>
</li>
<li><p>只要块级作用域中存在<code>let</code>，那么外部的同名变量就被屏蔽，这时候如果在声明前使用，会进入『暂时性死区』，将该变量看做不存在</p>
</li>
<li><p>如果存在暂时性死区，那么无论是调用该变量还是使用<code>typeof</code>都会抛出<code>ReferenceError</code></p>
</li>
<li><p><code>let</code>不允许同一变量的重复声明</p>
</li>
<li><p>外层块级作用域的变量可以在内层块级作用域被访问</p>
</li>
<li><p>块级作用域可以替代匿名立即执行函数表达式（匿名IIFE）实现不污染外部变量的效果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IIFE 写法</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 块级作用域写法</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数可以在块级作用域内声明，但只能在作用域内被调用（ES6），ES5之前的版本会污染外部同名函数</p>
</li>
<li><p>块级作用域必须包含括号</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种写法，报错</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法，不报错</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>const</code>的作用域与<code>let</code>基本一致</p>
</li>
<li><p><code>const</code>只能保证变量所指向的内存地址不被改变，因此如果<code>const</code>指向了一个对象，那么对象中的内容依旧可以修改，但对象本身不能被覆盖&#x2F;删除。</p>
<blockquote>
<p>如果真的需要冻结对象，应该使用<code>Object.freeze</code>方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规模式时，下面一行不起作用；</span></span><br><span class="line"><span class="comment">// 严格模式时，该行会报错</span></span><br><span class="line">foo.<span class="property">prop</span> = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 彻底冻结一个对象及其所有属性</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">constantize</span> = (<span class="params">obj</span>) =&gt; &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">freeze</span>(obj);</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>( <span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;object&#x27;</span> ) &#123;</span><br><span class="line">      <span class="title function_">constantize</span>( obj[key] );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>const</code>和<code>let</code>不能被<code>delete</code>删除，因为两者均属于不可设置属性</p>
</li>
<li><p>顶层对象在浏览器和Node中分别指<code>window</code>和<code>global</code>，在ES5中顶层对象的属性和全局变量是等价的</p>
</li>
<li><p>ES2020引入了<code>globalThis</code>作为顶层对象，这样就可以在任何环境下拿到全局<code>this</code></p>
</li>
</ul>
<h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><ul>
<li><p>ES6允许对变量进行解构赋值，只要左右两边模式相同就可以一一对应，如果解构失败，失败的值等于<code>undefined</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line">foo <span class="comment">// 1</span></span><br><span class="line">bar <span class="comment">// 2</span></span><br><span class="line">baz <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>];</span><br><span class="line">third <span class="comment">// &quot;baz&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">head <span class="comment">// 1</span></span><br><span class="line">tail <span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">x <span class="comment">// &quot;a&quot;</span></span><br><span class="line">y <span class="comment">// undefined</span></span><br><span class="line">z <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>只要数据结构拥有<code>Iterator</code>接口，就都可以使用数组形式的解构赋值</p>
</li>
<li><p>解构赋值允许指定默认值，但默认值只有当对应位置为<code>undefined</code>（严格等于）才能生效</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="literal">undefined</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解构赋值的默认值是惰性求值的，只有在用到的时候才会被求值</p>
</li>
<li><p>解构赋值的默认值可以引用解构赋值的其他变量（但必须是已经声明的变量）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [];     <span class="comment">// x=1; y=1</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">2</span>];    <span class="comment">// x=2; y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// x=1; y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = [];     <span class="comment">// ReferenceError: y is not defined</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解构赋值也可以用于对象，但是变量必须与属性同名才能取到相应的值，否则为<code>undefined</code></p>
</li>
<li><p>对象解构可以方便的提取现有对象的方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">let</span> &#123; log, sin, cos &#125; = <span class="title class_">Math</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">const</span> &#123; log &#125; = <span class="variable language_">console</span>;</span><br><span class="line"><span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果变量名和属性名不一致，需要指定属性名</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">baz <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">first</span>: <span class="string">&#x27;hello&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;world&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">first</span>: f, <span class="attr">last</span>: l &#125; = obj;</span><br><span class="line">f <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line">l <span class="comment">// &#x27;world&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解构也可以用于嵌套的对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">p</span>: [</span><br><span class="line">    <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">    &#123; <span class="attr">y</span>: <span class="string">&#x27;World&#x27;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的p是模式名，不是变量，不会被赋值</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line"><span class="comment">// 如果要赋值，需要额外加一个p</span></span><br><span class="line"><span class="keyword">let</span> &#123; p, <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line">y <span class="comment">// &quot;World&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对象的解构赋值可以取到继承的属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj1, obj2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; foo &#125; = obj1;</span><br><span class="line">foo <span class="comment">// &quot;bar&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对象的解构也可以指定默认值</p>
</li>
<li><p>字符串也可以被解构赋值（因为字符串属于可迭代对象）</p>
</li>
<li><p>只要等号右边的值不是对象&#x2F;数组，就会先将其转换为对象，因此<code>undefined</code>和<code>null</code>是不能被解构赋值的</p>
</li>
<li><p>函数参数也可以被解构赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">[x, y]</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数参数也可以使用默认值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 情况1（为第一个参数中的x/y指定默认值）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">move</span>(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line"><span class="title function_">move</span>(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></span><br><span class="line"><span class="title function_">move</span>(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line"><span class="title function_">move</span>(); <span class="comment">// [0, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况2（为move的参数指定默认值，只要参数为undefined，就会触发默认值）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">move</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">move</span>(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line"><span class="title function_">move</span>(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, undefined]</span></span><br><span class="line"><span class="title function_">move</span>(&#123;&#125;); <span class="comment">// [undefined, undefined]</span></span><br><span class="line"><span class="title function_">move</span>(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用途</p>
<ul>
<li>交换变量的值（无需新增变量）</li>
<li>从函数返回多个值</li>
<li>为函数调用增加参数名称</li>
<li>提取JSON中的数据</li>
<li>作为函数参数的默认值</li>
<li>遍历Map结构</li>
<li>导入模块中的指定方法（最常用）</li>
</ul>
</li>
</ul>
<h2 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h2><ul>
<li><p>字符串拥有遍历器接口，可以被循环遍历（支持大于<code>0xFFFF</code>的码点比如Emoji）</p>
</li>
<li><p>模板字符串</p>
<ul>
<li><p>使用反引号代替单双引号，可以嵌入模板字符串（可以当做普通字符串、也可以当做多行字符串、还可以插入变量）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通字符串</span></span><br><span class="line"><span class="string">`In JavaScript &#x27;\n&#x27; is a line-feed.`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多行字符串</span></span><br><span class="line"><span class="string">`In JavaScript this is</span></span><br><span class="line"><span class="string"> not legal.`</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`string text line 1</span></span><br><span class="line"><span class="string">string text line 2`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串中嵌入变量</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Bob&quot;</span>, time = <span class="string">&quot;today&quot;</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果需要过滤换行符号，可以加一个<code>trim()</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#list&#x27;</span>).<span class="title function_">html</span>(<span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;first&lt;/li&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;second&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>.<span class="title function_">trim</span>());</span><br></pre></td></tr></table></figure>
</li>
<li><p>嵌入变量需要把变量名加入<code>$&#123;&#125;</code>里面，括号里面可以放入任意的JavaScript表达式，甚至可以调用函数，但不能调用没声明的变量</p>
</li>
<li><p>模板字符串可以嵌套使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">tmpl</span> = addrs =&gt; <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;table&gt;</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;addrs.map(addr =&gt; <span class="string">`</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.first&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.last&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  `</span>).join(<span class="string">&#x27;&#x27;</span>)&#125;</span></span></span><br><span class="line"><span class="string">  &lt;/table&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>模板字符串可以作为函数被调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">func</span> = (<span class="params">name</span>) =&gt; <span class="string">`Hello <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br><span class="line"><span class="title function_">func</span>(<span class="string">&#x27;Jack&#x27;</span>) <span class="comment">// &quot;Hello Jack!&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="字符串的新增方法"><a href="#字符串的新增方法" class="headerlink" title="字符串的新增方法"></a>字符串的新增方法</h2><ul>
<li><p><code>includes()</code>：是否包含参数字符串</p>
</li>
<li><p><code>startsWith()</code>：是否在原字符串的头部</p>
</li>
<li><p><code>endsWith()</code>：是否在原字符串的尾部</p>
<blockquote>
<p>这三个方法都支持使用第二个参数表示开始搜索的位置，其中endsWith是针对前n个字符，而其他两个方法针对从n到结束</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">s.<span class="title function_">startsWith</span>(<span class="string">&#x27;world&#x27;</span>, <span class="number">6</span>) <span class="comment">// true</span></span><br><span class="line">s.<span class="title function_">endsWith</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">5</span>) <span class="comment">// true</span></span><br><span class="line">s.<span class="title function_">includes</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">6</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>repeat()</code>表示将原字符串重复n次</p>
</li>
<li><p><code>padStart()</code>和<code>padEnd()</code>表示在头部或尾部使用指定字符串补全</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">5</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;ababx&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">4</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;abax&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.<span class="title function_">padEnd</span>(<span class="number">5</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;xabab&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.<span class="title function_">padEnd</span>(<span class="number">4</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;xaba&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>最常见的用途是为指定的数值补全指定位数，或是提示字符串格式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;1&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">10</span>, <span class="string">&#x27;0&#x27;</span>) <span class="comment">// &quot;0000000001&quot;</span></span><br><span class="line"><span class="string">&#x27;12&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">10</span>, <span class="string">&#x27;0&#x27;</span>) <span class="comment">// &quot;0000000012&quot;</span></span><br><span class="line"><span class="string">&#x27;123456&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">10</span>, <span class="string">&#x27;0&#x27;</span>) <span class="comment">// &quot;0000123456&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;12&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">10</span>, <span class="string">&#x27;YYYY-MM-DD&#x27;</span>) <span class="comment">// &quot;YYYY-MM-12&quot;</span></span><br><span class="line"><span class="string">&#x27;09-12&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">10</span>, <span class="string">&#x27;YYYY-MM-DD&#x27;</span>) <span class="comment">// &quot;YYYY-09-12&quot;</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>ES2019</code>新增了<code>trimStart()</code>和<code>trimEnd()</code>两个方法，和<code>trim()</code>一致，消除头部和尾部的空格，不会修改原始字符串</p>
</li>
</ul>
<h2 id="正则的扩展"><a href="#正则的扩展" class="headerlink" title="正则的扩展"></a>正则的扩展</h2><ul>
<li><p>正则表达式的初始化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;xyz&#x27;</span>, <span class="string">&#x27;i&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/xyz/i</span>;</span><br><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="regexp">/xyz/i</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="regexp">/abc/ig</span>, <span class="string">&#x27;i&#x27;</span>) <span class="comment">// ES6引入，ig被覆盖为i</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串的正则方法</p>
<ul>
<li><code>match()</code></li>
<li><code>replace()</code></li>
<li><code>search()</code></li>
<li><code>split()</code></li>
</ul>
</li>
<li><p>正则表达式的<code>u</code>修饰符（ES6引入），用于扩展到所有Unicode字符</p>
<ul>
<li>包含双Unicode码字符（如Emoji）</li>
<li>包含\u{0xFFFF}以上的Unicode码</li>
<li>包含同字但不同Unicode码的情况（如K可以使用<code>\u&#123;004B&#125;</code>或<code>\u&#123;212A&#125;</code>表示）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/^.<span class="property">$</span>/u.<span class="title function_">test</span>(<span class="string">&quot;😂&quot;</span>)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">/^.<span class="property">$</span>/.<span class="title function_">test</span>(<span class="string">&quot;😂&quot;</span>)</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>正则表达式的<code>y</code>修饰符（ES6引入），要求这一次匹配必须从上一次匹配的头部开始（粘连&#x2F;sticky）</p>
</li>
<li><p>ES6引入了正则表达式的<code>flags</code>属性，可以返回当前所设置的所有修饰符</p>
</li>
<li><p>ES2018引入了<code>s</code>修饰符，使得点号可以匹配任意单个字符，可以使用<code>dotAll</code>属性进行访问</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> re = <span class="regexp">/foo.bar/</span>s;</span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="comment">// const re = new RegExp(&#x27;foo.bar&#x27;, &#x27;s&#x27;);</span></span><br><span class="line"></span><br><span class="line">re.<span class="title function_">test</span>(<span class="string">&#x27;foo\nbar&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">re.<span class="property">dotAll</span> <span class="comment">// true</span></span><br><span class="line">re.<span class="property">flags</span> <span class="comment">// &#x27;s&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>先行断言和后行断言</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先行断言</span></span><br><span class="line">/\d+(?=%)/.<span class="title function_">exec</span>(<span class="string">&#x27;100% of US presidents have been male&#x27;</span>)  <span class="comment">// [&quot;100&quot;]</span></span><br><span class="line">/\d+(?!%)/.<span class="title function_">exec</span>(<span class="string">&#x27;that’s all 44 of them&#x27;</span>)                 <span class="comment">// [&quot;44&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 后行断言</span></span><br><span class="line">/(?&lt;=\$)\d+<span class="regexp">/.exec(&#x27;Benjamin Franklin is on the $100 bill&#x27;)  /</span><span class="regexp">/ [&quot;100&quot;]</span></span><br><span class="line"><span class="regexp">/</span>(?&lt;!\$)\d+<span class="regexp">/.exec(&#x27;it’s is worth about €90&#x27;)                /</span><span class="regexp">/ [&quot;90&quot;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Unicode属性类（匹配某一类的所有Unicode字符）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> regexGreekSymbol = <span class="regexp">/\p&#123;Script=Greek&#125;/u</span>;</span><br><span class="line">regexGreekSymbol.<span class="title function_">test</span>(<span class="string">&#x27;π&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/^\p&#123;Decimal_Number&#125;+$/u</span>;</span><br><span class="line">regex.<span class="title function_">test</span>(<span class="string">&#x27;𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/^\p&#123;Number&#125;+$/u</span>;</span><br><span class="line">regex.<span class="title function_">test</span>(<span class="string">&#x27;²³¹¼½¾&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">regex.<span class="title function_">test</span>(<span class="string">&#x27;㉛㉜㉝&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">regex.<span class="title function_">test</span>(<span class="string">&#x27;ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配所有空格</span></span><br><span class="line">\p&#123;<span class="title class_">White</span>_Space&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配各种文字的所有字母，等同于 Unicode 版的 \w</span></span><br><span class="line">[\p&#123;<span class="title class_">Alphabetic</span>&#125;\p&#123;<span class="title class_">Mark</span>&#125;\p&#123;<span class="title class_">Decimal</span>_Number&#125;\p&#123;<span class="title class_">Connector</span>_Punctuation&#125;\p&#123;<span class="title class_">Join</span>_Control&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \W</span></span><br><span class="line">[^\p&#123;<span class="title class_">Alphabetic</span>&#125;\p&#123;<span class="title class_">Mark</span>&#125;\p&#123;<span class="title class_">Decimal</span>_Number&#125;\p&#123;<span class="title class_">Connector</span>_Punctuation&#125;\p&#123;<span class="title class_">Join</span>_Control&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配 Emoji</span></span><br><span class="line">/\p&#123;<span class="title class_">Emoji</span>_Modifier_Base&#125;\p&#123;<span class="title class_">Emoji</span>_Modifier&#125;?|\p&#123;<span class="title class_">Emoji</span>_Presentation&#125;|\p&#123;<span class="title class_">Emoji</span>&#125;\uFE0F/gu</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配所有的箭头字符</span></span><br><span class="line"><span class="keyword">const</span> regexArrows = <span class="regexp">/^\p&#123;Block=Arrows&#125;+$/u</span>;</span><br><span class="line">regexArrows.<span class="title function_">test</span>(<span class="string">&#x27;←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>组匹配和具名组匹配</p>
<ul>
<li><p>使用括号注明捕获组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">RE_DATE</span> = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matchObj = <span class="variable constant_">RE_DATE</span>.<span class="title function_">exec</span>(<span class="string">&#x27;1999-12-31&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> year = matchObj[<span class="number">1</span>]; <span class="comment">// 1999</span></span><br><span class="line"><span class="keyword">const</span> month = matchObj[<span class="number">2</span>]; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">const</span> day = matchObj[<span class="number">3</span>]; <span class="comment">// 31</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ES2018引入具名组匹配，允许给匹配组命名</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">RE_DATE</span> = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matchObj = <span class="variable constant_">RE_DATE</span>.<span class="title function_">exec</span>(<span class="string">&#x27;1999-12-31&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> year = matchObj.<span class="property">groups</span>.<span class="property">year</span>; <span class="comment">// 1999</span></span><br><span class="line"><span class="keyword">const</span> month = matchObj.<span class="property">groups</span>.<span class="property">month</span>; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">const</span> day = matchObj.<span class="property">groups</span>.<span class="property">day</span>; <span class="comment">// 31</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以将具名组匹配和解构赋值相结合</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">groups</span>: &#123;one, two&#125;&#125; = <span class="regexp">/^(?&lt;one&gt;.*):(?&lt;two&gt;.*)$/u</span>.<span class="title function_">exec</span>(<span class="string">&#x27;foo:bar&#x27;</span>);</span><br><span class="line">one  <span class="comment">// foo</span></span><br><span class="line">two  <span class="comment">// bar</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>还可以与字符串替换结合</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;2015-01-02&#x27;</span>.<span class="title function_">replace</span>(re, <span class="string">&#x27;$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;&#x27;</span>)</span><br><span class="line"><span class="comment">// &#x27;02/01/2015&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>可以引用前面的某个普通组&#x2F;具名组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">RE_TWICE</span> = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;$/</span>;</span><br><span class="line"><span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!abc&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!ab&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字引用也是有效的</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">RE_TWICE</span> = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;!\1$/</span>;</span><br><span class="line"><span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!abc!abc&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!abc!ab&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以通过<code>exec()</code>返回后的<code>indices</code>属性拿到每个匹配的开始和结束位置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="string">&#x27;zabbcdef&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> re = <span class="regexp">/ab+(cd)/</span>;</span><br><span class="line"><span class="keyword">const</span> result = re.<span class="title function_">exec</span>(text);</span><br><span class="line"></span><br><span class="line">result.<span class="property">indices</span> <span class="comment">// [ [ 1, 6 ], [ 4, 6 ] ]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>还可以通过<code>indices</code>属性的<code>groups</code>属性拿到一个包含具名组信息和开始&#x2F;结束位置的对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="string">&#x27;zabbcdef&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> re = <span class="regexp">/ab+(?&lt;Z&gt;cd)/</span>;</span><br><span class="line"><span class="keyword">const</span> result = re.<span class="title function_">exec</span>(text);</span><br><span class="line"></span><br><span class="line">result.<span class="property">indices</span>.<span class="property">groups</span> <span class="comment">// &#123; Z: [ 4, 6 ] &#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ES2020引入了<code>String.prototype.matchAll()</code>方法，可以一次性取出所有匹配，但会一个遍历器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">&#x27;test1test2test3&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g 修饰符加不加都可以</span></span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/t(e)(st(\d?))/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> match <span class="keyword">of</span> string.<span class="title function_">matchAll</span>(regex)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(match);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2test3&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2test3&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;test3&quot;, &quot;e&quot;, &quot;st3&quot;, &quot;3&quot;, index: 10, input: &quot;test1test2test3&quot;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历器转为数组的方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[...string.<span class="title function_">matchAll</span>(regex)]</span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(string.<span class="title function_">matchAll</span>(regex))</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h2><ul>
<li><p>ES6规范了二进制&#x2F;八进制分别用<code>0b</code>和<code>0o</code>表示</p>
</li>
<li><p>使用<code>Number()</code>构造函数将不同进制的数字规范为十进制</p>
</li>
<li><p>ES6在Number对象上新增了<code>Number.isFinite()</code>和<code>Number.isNaN()</code>两个方法，相比较全局的同名方法，Number的这两个方法</p>
</li>
<li><p>ES6将<code>parseInt()</code>和<code>parseFloat()</code>移植到了Number对象中，使得语言逐步模块化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="property">parseInt</span> === <span class="built_in">parseInt</span> <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">parseFloat</span> === <span class="built_in">parseFloat</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Number.isInteger()</code>可以用来判断一个数值是否为整数，但是对于<code>20.0</code>也会返回True（因为JavaScript内对浮点数和整数的存储方法相同）</p>
<blockquote>
<p>因为JavaScript内部使用64位双精度存储数字，因此该方法可能会存在误判：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="property">parseInt</span> === <span class="built_in">parseInt</span> <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">parseFloat</span> === <span class="built_in">parseFloat</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>Number.EPSILON</code>表示最小精度的数字，用于为浮点数计算设置一个误差范围</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span></span><br><span class="line"><span class="comment">// 0.30000000000000004</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> - <span class="number">0.3</span></span><br><span class="line"><span class="comment">// 5.551115123125783e-17</span></span><br><span class="line"></span><br><span class="line"><span class="number">5.551115123125783e-17</span>.<span class="title function_">toFixed</span>(<span class="number">20</span>)</span><br><span class="line"><span class="comment">// &#x27;0.00000000000000005551&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">withinErrorMargin</span> (left, right) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(left - right) &lt; <span class="title class_">Number</span>.<span class="property">EPSILON</span> * <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span> <span class="comment">// false</span></span><br><span class="line"><span class="title function_">withinErrorMargin</span>(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.1</span> + <span class="number">1.3</span> === <span class="number">2.4</span> <span class="comment">// false</span></span><br><span class="line"><span class="title function_">withinErrorMargin</span>(<span class="number">1.1</span> + <span class="number">1.3</span>, <span class="number">2.4</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Number.isSafeInteger()</code>属性用于判断是否存在溢出情况</p>
</li>
<li><p><code>Math.trunc()</code>方法用于去除小数部分，返回整数部分，是<code>Math.ceil()</code>和<code>Math.floor()</code>的结合</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="property">trunc</span> = <span class="title class_">Math</span>.<span class="property">trunc</span> || <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x &lt; <span class="number">0</span> ? <span class="title class_">Math</span>.<span class="title function_">ceil</span>(x) : <span class="title class_">Math</span>.<span class="title function_">floor</span>(x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>Math.sign()</code>可以用于判断一个数到底是正数、负数还是0</p>
</li>
<li><p><code>Math.cbrt()</code>可以用于计算一个数的立方根</p>
</li>
<li><p><code>Math.clz32()</code>可以用于计算一个32位无符号<strong>整数</strong>内存在多少个前导0</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">clz32</span>(<span class="number">0</span>) <span class="comment">// 32</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">clz32</span>(<span class="number">1</span>) <span class="comment">// 31</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">clz32</span>(<span class="number">1000</span>) <span class="comment">// 22</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">clz32</span>(<span class="number">0b01000000000000000000000000000000</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">clz32</span>(<span class="number">0b00100000000000000000000000000000</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>Math.log10()</code>可以返回10为底的x的对数</p>
</li>
<li><p><code>Math.log2()</code>可以返回以2为底的x的对数</p>
</li>
<li><p>ES2016引入了指数运算符（<code>**</code>），但是和其他语言不一样，它是右结合的</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于 2 ** (3 ** 2)</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span> ** <span class="number">2</span></span><br><span class="line"><span class="comment">// 512</span></span><br><span class="line"></span><br><span class="line">a **= <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 相当于a = a * a</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>ES2020引入了一个新的数据类型<code>BigInt</code>来解决这个问题，可以存储任何位数的整数，在声明字面量时添加后缀n来声明，也可以通过<code>BitInt()</code>构造方法将其他类型的值转换为<code>BitInt</code></p>
</li>
</ul>
<h2 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h2><ul>
<li><p>ES6之后函数参数可以引入默认值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">x, y = <span class="string">&#x27;World&#x27;</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// Hello World</span></span><br><span class="line"><span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;China&#x27;</span>) <span class="comment">// Hello China</span></span><br><span class="line"><span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用参数默认值时，函数不能有同名参数</p>
</li>
<li><p>可以与解构赋值的默认值结合使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// undefined 5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>区分默认值两种写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">m1</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">m2</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数没有参数的情况</span></span><br><span class="line"><span class="title function_">m1</span>() <span class="comment">// [0, 0]</span></span><br><span class="line"><span class="title function_">m2</span>() <span class="comment">// [0, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x 和 y 都有值的情况</span></span><br><span class="line"><span class="title function_">m1</span>(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;) <span class="comment">// [3, 8]</span></span><br><span class="line"><span class="title function_">m2</span>(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;) <span class="comment">// [3, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x 有值，y 无值的情况</span></span><br><span class="line"><span class="title function_">m1</span>(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;) <span class="comment">// [3, 0]</span></span><br><span class="line"><span class="title function_">m2</span>(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;) <span class="comment">// [3, undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x 和 y 都无值的情况</span></span><br><span class="line"><span class="title function_">m1</span>(&#123;&#125;) <span class="comment">// [0, 0];</span></span><br><span class="line"><span class="title function_">m2</span>(&#123;&#125;) <span class="comment">// [undefined, undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">m1</span>(&#123;<span class="attr">z</span>: <span class="number">3</span>&#125;) <span class="comment">// [0, 0]</span></span><br><span class="line"><span class="title function_">m2</span>(&#123;<span class="attr">z</span>: <span class="number">3</span>&#125;) <span class="comment">// [undefined, undefined]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>只有尾部的参数才能有默认值</p>
</li>
<li><p>函数的<code>length</code>参数指定的是期望传入的参数个数，不计包含默认值的参数（因为不期望能传入）</p>
</li>
<li><p>ES6引入rest参数替代之前的arguments变量实现可变参数</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">...values</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments变量的写法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sortNumbers</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 使用Array.prototype.slice.call将参数转换为数组</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>).<span class="title function_">sort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rest参数的写法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sortNumbers</span> = (<span class="params">...numbers</span>) =&gt; numbers.<span class="title function_">sort</span>();</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>函数的<code>name</code>属性可以返回函数名</p>
</li>
<li><p>箭头函数的四个注意点：</p>
<ul>
<li><code>this</code>指向定义时所在的对象，而不是使用时所在的对象</li>
<li>不可以当做构造函数使用（不能使用new命令）</li>
<li>没有<code>arguments</code>对象，但是可以使用rest参数实现可变参数</li>
<li>没有<code>yield</code>命令，不能当做<code>Generator</code>函数</li>
</ul>
</li>
<li><p>不适合使用箭头函数的地方</p>
<ul>
<li>定义对象的方法，这里的this会指向全局对象，因为对象不属于作用域</li>
<li>this的值动态变化（例如响应事件时，因为事件的this一般是触发事件的对象，不是某个固定的对象）</li>
</ul>
</li>
<li><p>尾调用优化（目前只有Safari支持，可以节省内存，直达内层函数的调用帧，但是要求严格模式开启）</p>
</li>
<li><p>尾递归优化（存储递归的结果，不会发生栈溢出，所有满足ES6规范的客户端都要支持）</p>
</li>
<li><p>递归函数的改写</p>
<ul>
<li>对于需要状态参数的递归函数，可以用另一个caller将其包裹，保持API的友好</li>
</ul>
</li>
<li><p>ES2019要求函数的<code>toString()</code>方法必须返回函数本身的所有代码（包括注释、空格）</p>
</li>
<li><p>ES2019允许<code>catch</code>语句省略参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125; <span class="keyword">catch</span> &#123; <span class="comment">// 如果用不上err不用再写</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="关于this-apply-call-bind"><a href="#关于this-apply-call-bind" class="headerlink" title="关于this&#x2F;apply&#x2F;call&#x2F;bind"></a>关于this&#x2F;apply&#x2F;call&#x2F;bind</h3><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><ul>
<li><p>默认指向最后<strong>调用</strong>它的那个对象</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;windowsName&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;Cherry&#x27;</span>;</span><br><span class="line">  <span class="title function_">innerFunction</span>();</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">innerFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);      <span class="comment">// windowsName</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>()</span><br><span class="line"><span class="comment">// 这时候fn()的this是window</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>箭头函数中永远指向定义时候的this，不受调用干扰</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;windowsName&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Cherry&#x27;</span>,</span><br><span class="line">  <span class="comment">// innerFunction的this为fn</span></span><br><span class="line">  <span class="attr">innerFunction</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 此处继承innerFunction的this</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.<span class="title function_">innerFunction</span>()</span><br></pre></td></tr></table></figure>

<p>箭头函数本身没有this，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined</p>
</blockquote>
</li>
<li><p>使用<code>that = this</code>来指定this</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;windowsName&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line"></span><br><span class="line">  name : <span class="string">&quot;Cherry&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">func1</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)     </span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">func2</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>( <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    	<span class="comment">// 指定后that就变成了a而不是window</span></span><br><span class="line">      that.<span class="title function_">func1</span>()</span><br><span class="line">    &#125;,<span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.<span class="title function_">func2</span>()       <span class="comment">// Cherry</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h4 id="apply-call-bind"><a href="#apply-call-bind" class="headerlink" title="apply&#x2F;call&#x2F;bind"></a>apply&#x2F;call&#x2F;bind</h4><ul>
<li><p>使用这三个函数也可以来改变<code>this</code>的指向</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">func2</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(  <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">func1</span>()</span><br><span class="line">  &#125;.<span class="title function_">apply</span>(a),<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">func2</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(  <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">func1</span>()</span><br><span class="line">  &#125;.<span class="title function_">call</span>(a),<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">func2</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(  <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">func1</span>()</span><br><span class="line">  &#125;.<span class="title function_">bind</span>(a)(),<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>apply</code>调用一个函数，传入this值和数组包裹的参数列表</p>
</li>
<li><p><code>call</code>调用一个函数，传入this值和单独的若干个参数</p>
</li>
<li><p><code>bind</code>创建一个新的函数，传入this和预置参数，被调用的时候可以传入新的参数，附加在预置参数之后</p>
</li>
</ul>
<h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><ul>
<li><p>扩展运算符，可以理解为<code>rest</code>参数的逆运算，将一个数组转换为逗号分割的参数序列</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// 1, 2, 3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>扩展运算符可以代替<code>apply</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5 的写法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f.<span class="title function_">apply</span>(<span class="literal">null</span>, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="title function_">f</span>(...args);</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 的写法</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">max</span>(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>);</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">  </span><br><span class="line"><span class="comment">// ES5的 写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span>.<span class="title function_">apply</span>(arr1, arr2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr1.<span class="title function_">push</span>(...arr2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>扩展运算符还可以用来复制数组（深拷贝）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> a2 = [...a1];</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> [...a2] = a1;</span><br></pre></td></tr></table></figure>
</li>
<li><p>扩展运算符还可以合并数组（深拷贝）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 的合并数组</span></span><br><span class="line">arr1.<span class="title function_">concat</span>(arr2, arr3);</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的合并数组</span></span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>扩展运算符还可以生成数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">rest  <span class="comment">// [2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [];</span><br><span class="line">first <span class="comment">// undefined</span></span><br><span class="line">rest  <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="string">&quot;foo&quot;</span>];</span><br><span class="line">first  <span class="comment">// &quot;foo&quot;</span></span><br><span class="line">rest   <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>扩展运算符可以打散所有可迭代对象，比如ES6的字符串（可以实现按Unicode字符打散）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[...<span class="string">&quot;😂😂&quot;</span>] <span class="comment">// (2) [&quot;😂&quot;, &quot;😂&quot;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Array.from()</code>方法可以将可遍历对象转换为真正的数组，效果和扩展运算符类似，但是<code>Array.from()</code>方法只要求有<code>length</code>属性，扩展运算符要求满足<code>Symbol.iterator</code>接口</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [].<span class="property">slice</span>.<span class="title function_">call</span>(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Array.of()</code>用于将一堆值转换为一个数组，为了弥补<code>Array()</code>函数构造函数的不足</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>) <span class="comment">// [3]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>).<span class="property">length</span> <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>() <span class="comment">// []</span></span><br><span class="line"><span class="title class_">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br><span class="line"><span class="title class_">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3, 11, 8]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Array.copyWithin()</code>方法可以原地覆盖成员，三个参数分别为替换开始位置，读取开始位置（可以为负数），结束读取位置（可以为负数）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将3号位复制到0号位</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].<span class="title function_">copyWithin</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// [4, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -2相当于3号位，-1相当于4号位</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].<span class="title function_">copyWithin</span>(<span class="number">0</span>, -<span class="number">2</span>, -<span class="number">1</span>)</span><br><span class="line"><span class="comment">// [4, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将3号位复制到0号位</span></span><br><span class="line">[].<span class="property">copyWithin</span>.<span class="title function_">call</span>(&#123;<span class="attr">length</span>: <span class="number">5</span>, <span class="number">3</span>: <span class="number">1</span>&#125;, <span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// &#123;0: 1, 3: 1, length: 5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将2号位到数组结束，复制到0号位</span></span><br><span class="line"><span class="keyword">let</span> i32a = <span class="keyword">new</span> <span class="title class_">Int32Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">i32a.<span class="title function_">copyWithin</span>(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// Int32Array [3, 4, 5, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于没有部署 TypedArray 的 copyWithin 方法的平台</span></span><br><span class="line"><span class="comment">// 需要采用下面的写法</span></span><br><span class="line">[].<span class="property">copyWithin</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Int32Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]), <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// Int32Array [4, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>find()</code>和<code>findIndex()</code>，接收回调函数，直到找到一个返回值为True的成员&#x2F;成员位置，如果没有则返回undefined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回调函数可以有三个参数，分别为当前值，当前位置，原完整数组</span></span><br><span class="line"><span class="comment">// 两个方法都可以接受第二个参数，用于绑定回调函数的this对象</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].<span class="title function_">findIndex</span>(<span class="keyword">function</span>(<span class="params">value, index, arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">v</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> v &gt; <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;;</span><br><span class="line">[<span class="number">10</span>, <span class="number">12</span>, <span class="number">26</span>, <span class="number">15</span>].<span class="title function_">find</span>(f, person);    <span class="comment">// 26</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这两个方法可以识别NaN，但<code>indexOf()</code>方法不行</p>
</blockquote>
</li>
<li><p><code>fill()</code>方法可以填充数组，有三个参数分别为填充的值、填充的起始位置、填充的结束位置，但是如果填充的类型是对象，那么所有对象都指向同一内存地址</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">3</span>).<span class="title function_">fill</span>(&#123;<span class="attr">name</span>: <span class="string">&quot;Mike&quot;</span>&#125;);</span><br><span class="line">arr[<span class="number">0</span>].<span class="property">name</span> = <span class="string">&quot;Ben&quot;</span>;</span><br><span class="line">arr</span><br><span class="line"><span class="comment">// [&#123;name: &quot;Ben&quot;&#125;, &#123;name: &quot;Ben&quot;&#125;, &#123;name: &quot;Ben&quot;&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">3</span>).<span class="title function_">fill</span>([]);</span><br><span class="line">arr[<span class="number">0</span>].<span class="title function_">push</span>(<span class="number">5</span>);</span><br><span class="line">arr</span><br><span class="line"><span class="comment">// [[5], [5], [5]]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数组实例的<code>keys()</code> <code>values()</code> <code>entries()</code>分别生成三个迭代器对象，用于迭代键、值、键值对，如果不使用<code>for of</code>循环，可以手动调用遍历器对象的<code>next()</code>方法进行遍历       </p>
</li>
<li><p>ES2016引入了<code>includes()</code>方法，相比较<code>indexOf()</code>方法更直观，第一个参数是搜索值，第二个参数是搜索的起始位置，使用的是严格相等运算符进行判断，不会出现<code>[NaN].indexOf(NaN)</code>返回-1的情况</p>
<blockquote>
<p>注意和Map&amp;&amp;Set的has方法区分开来</p>
</blockquote>
</li>
</ul>
<h3 id="展平数组的若干方法"><a href="#展平数组的若干方法" class="headerlink" title="展平数组的若干方法"></a>展平数组的若干方法</h3><ul>
<li><p>常规递归方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flattenMd</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> result=[]</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr[i])) &#123;</span><br><span class="line">                <span class="title function_">flatten</span>(arr[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">flatten</span>(arr);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>], <span class="number">6</span>], <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flattenMd</span>(arr));[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> ];</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组concat+递归</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">flatten = <span class="keyword">function</span> (<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">plane, toBeFlatten</span>) =&gt;</span> (plane.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(toBeFlatten) ? <span class="title function_">flatten</span>(toBeFlatten) : toBeFlatten)), []);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用ES6的展开符号递归</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepFlatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    flatten = <span class="function">(<span class="params">arr</span>)=&gt;</span> [].<span class="title function_">concat</span>(...arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">flatten</span>(arr.<span class="title function_">map</span>(<span class="function"><span class="params">x</span>=&gt;</span><span class="title class_">Array</span>.<span class="title function_">isArray</span>(x)? <span class="title function_">deepFlatten</span>(x): x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组的join和split（只适用于数字数组）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flattenMd</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> arr.<span class="title function_">join</span>().<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>);   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr=[<span class="string">&#x27;1&#x27;</span>, [<span class="literal">null</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>], &#123;<span class="attr">K</span>:<span class="number">1</span>&#125;], <span class="literal">undefined</span>, <span class="number">8</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flattenMd</span>(arr));<span class="comment">//[ &#x27;1&#x27;, &#x27;&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;[object Object]&#x27;, &#x27;&#x27;, &#x27;8&#x27; ]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ES6的<code>Array.prototype.flat()</code>方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].<span class="title function_">flat</span>()</span><br><span class="line"><span class="comment">// [1, 2, 3, [4, 5]]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].<span class="title function_">flat</span>(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>]]].<span class="title function_">flat</span>(<span class="title class_">Infinity</span>)</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ES6的<code>Array.prototype.flatMap()</code>方法（结合了<code>flat()</code>和<code>map()</code>，但是只能展开一层数组，而且返回的还是一个嵌套数组）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="title function_">flatMap</span>(<span class="function"><span class="params">x</span> =&gt;</span> [[x * <span class="number">2</span>]])</span><br><span class="line"><span class="comment">// [[2], [4], [6], [8]]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h2><ul>
<li><p>属性可以简写（使用大括号包围）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">x</span>: x, <span class="attr">y</span>: y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// Object &#123;x: 1, y: 2&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方法也可以简写（在Vue.js里面有用到）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  <span class="title function_">method</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>JS模块也使用到了简写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ms = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getItem</span> (key) &#123;</span><br><span class="line">  <span class="keyword">return</span> key <span class="keyword">in</span> ms ? ms[key] : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setItem</span> (key, value) &#123;</span><br><span class="line">  ms[key] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clear</span> () &#123;</span><br><span class="line">  ms = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123; getItem, setItem, clear &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">getItem</span>: getItem,</span><br><span class="line">  <span class="attr">setItem</span>: setItem,</span><br><span class="line">  <span class="attr">clear</span>: clear</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>但是构造函数不能简写</p>
</li>
<li><p>JavaScript定义对象的属性有两种方法，但是如果用大括号定义对象只能用方法1</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">obj.<span class="property">foo</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line">obj[<span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;bc&#x27;</span>] = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法也可以拥有<code>name</code>属性，返回方法的名字，但是匿名函数返回<code>anonymous</code>，<code>bind</code>方法创造的函数，名字前会加一个<code>bound </code></p>
</li>
<li><p>ES6引入了<code>super</code>关键字，指向原型对象，但是只能用在方法里</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="variable language_">super</span>.<span class="property">foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="function">() =&gt;</span> <span class="variable language_">super</span>.<span class="property">foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="property">foo</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>super</code>关键字等同于<code>Object.getPrototypeOf(this).foo</code>（属性）或<code>Object.getPrototypeOf(this).foo.call(this)</code>（方法）</p>
</li>
<li><p>ES2020引入链式判断运算符（和Swift类似），如果条件都不满足，返回<code>undefined</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstName = message?.<span class="property">body</span>?.<span class="property">user</span>?.<span class="property">firstName</span> || <span class="string">&#x27;default&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> fooValue = myForm.<span class="title function_">querySelector</span>(<span class="string">&#x27;input[name=foo]&#x27;</span>)?.<span class="property">value</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>链式判断运算符可以用于调用一个可能不存在的对象，利用它如果不为真就不会求值的特性</p>
</li>
<li><p>ES2020引入了一个新的Null判断运算符<code>??</code>，对比<code>||</code>，只有左侧的值为<code>null</code>和<code>undefined</code>才能返回右侧的值，而不像<code>||</code>对<code>false</code>和<code>0</code>也生效</p>
</li>
</ul>
<h3 id="对象的各种方法"><a href="#对象的各种方法" class="headerlink" title="对象的各种方法"></a>对象的各种方法</h3><ul>
<li>初始化方法<ul>
<li><code>Object.assign()</code>合并两个对象，返回目标对象，同名对象后来者后覆盖，可以用于深拷贝</li>
<li><code>Object.create()</code>创建一个新对象，可以用于继承</li>
</ul>
</li>
<li>配置属性<ul>
<li><code>Object.defineProperty()</code>给对象添加一个属性，并指定该属性的配置</li>
<li><code>Object.defineProperties()</code>给对象添加多个属性，并分别指定它们的配置</li>
</ul>
</li>
<li>获取属性<ul>
<li><code>Object.getOwnPropertyDescriptor(obj, prop)</code>可以获取到方法中某个属性的描述对象</li>
<li><code>Object.getOwnPropertyNames(obj)</code>可以获取到对象自身所有属性（不含<code>Symbol</code>，但是包含不可枚举属性）的键名</li>
<li><code>Object.getOwnPropertySymbols(obj)</code>可以获取到自身所有<code>Symbol</code>属性的键名</li>
<li><code>for...in</code>循环遍历对象自身的可枚举属性（不含<code>Symbol</code>属性）</li>
<li><code>Object.entries()</code>返回对象自身可枚举属性的键值对数组（二维数组），和<code>for...in</code>返回内容相同</li>
<li><code>Object.keys()</code>获取对象自身所有属性（不含<code>Symbol</code>和不可枚举属性）</li>
<li><code>Reflect.ownKeys(obj)</code>获取所有键名（包含<code>Symbol</code>和不可枚举属性）</li>
<li><code>Object.prototype.toString()</code>返回对象的字符串表示</li>
</ul>
</li>
<li>配置状态<ul>
<li><code>Object.preventExtensions()</code>阻止对象的任何扩展</li>
<li><code>Object.freeze()</code>阻止对象被修改</li>
<li><code>Object.seal()</code>阻止其他代码删除对象的属性（使用<code>delete</code>关键字）</li>
<li><code>Object.setPrototypeOf()</code>设置对象的原型</li>
</ul>
</li>
<li>获取状态<ul>
<li><code>Object.prototype.hasOwnProperty()</code>某个对象是否有非继承的指定属性</li>
<li><code>Object.prototype.isPrototypeOf()</code>指定对象是否在本对象的原型链中</li>
<li><code>Object.is()</code>判断两个值是否相同（内存&#x2F;字面量相同）</li>
</ul>
</li>
</ul>
<h2 id="Set和Map数据结构"><a href="#Set和Map数据结构" class="headerlink" title="Set和Map数据结构"></a>Set和Map数据结构</h2><ul>
<li><p>Set结构有以下属性和方法</p>
<ul>
<li><code>Set.prototype.size</code>返回Set实例的成员总数</li>
<li><code>Set.prototype.add(value)</code>添加某个值，返回<code>Set</code>本身</li>
<li><code>Set.prototype.delete(value)</code>删除一个值，返回bool（删除是否成功）</li>
<li><code>Set.prototype.has(value)</code>返回一个布尔值，表示该值是否为<code>Set</code>的成员</li>
<li><code>Set.prototype.clear()</code>清除所有成员，没有返回值</li>
<li>四个遍历方法：<ul>
<li><code>Set.prototype.keys()</code>返回键名遍历器</li>
<li><code>Set.prototype.values()</code>返回键值的遍历器</li>
<li><code>Set.prototype.entries()</code>返回键值对的遍历器</li>
<li><code>Set.prototype.forEach()</code>使用回调函数遍历成员</li>
</ul>
</li>
</ul>
</li>
<li><p><code>Map</code>相对于<code>Object</code>，键可以为任何类型，提供了值-值的对应，属性&#x2F;方法和<code>Set</code>基本一致</p>
</li>
</ul>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><ul>
<li>本质上是一个容器，存储着未来才会结束的事件<ul>
<li>对象状态不受外界影响，只有自身能定义自身的状态，外部无法改变</li>
<li>一旦状态改变，就不会再改变</li>
</ul>
</li>
<li><code>Promise</code>新建之后会立即执行，因此一般会使用一个函数将其包裹起来，不会直接<code>new Promise</code>赋值给一个变量</li>
<li><code>Promise</code>一般会在<code>resolve()</code>或者<code>reject()</code>之后继续执行下面的代码，将其放在本轮事件循环的结尾，留到最后执行，因此为了避免出现问题，一般会使用<code>return resolve()</code>的方式</li>
<li><code>Promise</code>的<code>then</code>会接收来自前者的返回值，因此可以附加多个<code>then</code>实现链式操作</li>
<li><code>catch</code>其实是<code>then(undefined, function)</code>的别名，用于专门捕获错误</li>
<li><code>finally</code>可以用于处理善后，无论触发<code>then</code>还是<code>catch</code>都会被调用</li>
<li><code>Promise.all()</code>用于将多个Promise实例包装成一个新的Promise实例，必须所有实例变为<code>fulfilled</code>或者是其中任意一个变为<code>rejected</code>才会调用<code>Promise.all</code>方法后面的回调函数</li>
<li><code>Promise.race()</code>和<code>all()</code>类似，但是只要有一个实例率先改变状态，就会调用后面的回调函数，可以用于超时的实现（其中一个实例会在超时后<code>reject</code>）</li>
<li><code>Promise.allSettled()</code>需要等所有参数实例返回结果（无论是<code>rejected</code>还是<code>resolved</code>，才会调用后面的回调函数（ES2020引入）</li>
<li><code>Promise.resolve()</code> 、<code>Promise.reject()</code>可以将现有对象转换为<code>Promise</code>对象</li>
</ul>
<h2 id="Iterator-for…of"><a href="#Iterator-for…of" class="headerlink" title="Iterator&amp;for…of"></a>Iterator&amp;for…of</h2><ul>
<li><p>Iterator本质就是不断调用对象的<code>next()</code>方法</p>
</li>
<li><p>一个数据结构只要有<code>Symbol.iterator</code>属性（本质上是一个遍历器生成函数），就可以被认为是可遍历的，在TypeScript中可以看得更直观</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Iterable</span> &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() : <span class="title class_">Iterator</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">  <span class="title function_">next</span>(value?: <span class="built_in">any</span>) : <span class="title class_">IterationResult</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IterationResult</span> &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="built_in">any</span>,</span><br><span class="line">  <span class="attr">done</span>: <span class="built_in">boolean</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>原生具有<code>Iterator</code>接口的数据结构有</p>
<ul>
<li><code>Array</code></li>
<li><code>Map</code></li>
<li><code>Set</code></li>
<li><code>String</code></li>
<li><code>TypedArray</code></li>
<li>函数的<code>arguments</code>对象</li>
<li><code>NodeList</code>对象</li>
</ul>
</li>
<li><p>遍历器对象还可以有<code>return()</code>方法，来保证迭代提前退出（break或者出错）的时候资源被释放</p>
</li>
</ul>
<h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><ul>
<li>在函数名前带星号注明生成器，遇到<code>yield</code>就返回其后的值，直到遇到<code>return</code></li>
<li>可以为一个生成器赋值<code>Symbol.iterator</code>属性使其具有<code>Iterator</code>接口</li>
<li><code>next()</code>方法如果带一个参数，这个参数就会被当做上一个yield的返回值</li>
<li><code>yield*</code>可以在一个函数内执行另一个生成器，混合两者结果输出</li>
<li>Generator可以实现异步&#x2F;协程</li>
</ul>
<h2 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h2><ul>
<li><code>async</code>函数相比较<code>Generator</code>，自带执行器，会自动调用<code>next</code>方法</li>
<li>函数前加<code>async</code>声明该函数是<code>async</code>函数，函数中使用<code>await</code>跳出函数，返回Promise对象</li>
<li><code>async</code>的错误处理机制<ul>
<li>包含多个<code>await</code>的函数中，只要有一个出现错误，整个Promise对象就会被<code>reject</code>，因此最好把<code>await</code>命令放在<code>try...catch</code>中</li>
</ul>
</li>
</ul>
<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><ul>
<li>Class的出现是为了简化原型链，将原型链包装成语法糖</li>
<li>Class中所有方法都是不可枚举的（ES5的原型因为是Object，可以被枚举）</li>
<li>Class构造器和原型一样，是<code>constructor()</code>，但Class不能被直接调用，必须使用new</li>
<li>静态方法需要在前面显式加入<code>static</code>，此时this指向类而不是实例。静态属性同理</li>
<li>继承方法使用<code>extends</code>，访问父类使用<code>super</code></li>
<li>实例属性可以放在class顶层，和其他语言类似</li>
<li>私有方法&#x2F;属性在名称前加井号</li>
<li>Class的继承必须显式调用父类构造器，而且要在调用父类构造器之后才能修改自身属性</li>
</ul>
<h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><ul>
<li><p>CommonJS使用<code>require()</code>语法，运行时加载所需的方法，再使用大括号进行解构</p>
</li>
<li><p>ES6模块使用<code>import</code>语法，直接导入此前已经<code>export</code>过的对象&#x2F;方法</p>
</li>
<li><p>ES6模块默认启动严格模式</p>
</li>
<li><p>模块使用<code>export</code>输出，必须输出接口（因为<code>import</code>时会对接口进行解构）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以输出变量</span></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">&#x27;Michael&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">&#x27;Jackson&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; firstName, lastName, year &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以输出函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">multiply</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以对输出的内容重命名</span></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  v1 <span class="keyword">as</span> streamV1,</span><br><span class="line">  v2 <span class="keyword">as</span> streamV2,</span><br><span class="line">  v2 <span class="keyword">as</span> streamLatestVersion</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>模块不能在块级作用域中被导出，否则会违背ES6模块设计（静态优化）</p>
</li>
<li><p>模块输入需要使用对象解构语法或者星号（星号不能导出默认方法），可以用as为模块重命名</p>
</li>
<li><p><code>export default</code>可以避免使用库的时候不知道导出的对象叫什么名字，这样<code>import</code>时可以指定任意名字</p>
</li>
<li><p>可以从其他模块<code>export</code>它们的接口：<code>export &#123; foo as myFoo &#125; from &#39;my_module&#39;;</code>，对于功能复杂的模块，可以专门设置一个文件负责导出所有子模块</p>
</li>
<li><p><code>import</code>不能按需加载，但是<code>import()</code>可以，其本质是一个Promise对象</p>
</li>
<li><p><code>Module</code>的加载</p>
<ul>
<li><code>&lt;script&gt;</code>可以带一个<code>async</code>或者<code>defer</code>属性，前者在JS加载完之后立刻执行（不管是否渲染完毕）阻塞页面渲染，后者等待页面渲染完毕再执行</li>
<li>浏览器加载ES6模块需要在<code>&lt;script&gt;</code>里带一个<code>type=&quot;module&quot;</code>属性，此时加载默认为<code>defer</code>模式，不会阻塞浏览器</li>
</ul>
</li>
</ul>
<h2 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h2><ul>
<li>ArrayBuffer最初设计目的是为了提升性能，允许开发者以数组下标的方式直接访问内存</li>
<li>ArrayBuffer包含三部分：<ul>
<li>ArrayBuffer对象，提供了一批通用接口用于操作内存</li>
<li>TypedArray视图，包含常用数据结构</li>
<li>DataView视图，用于自定义各种复合类型，类似于结构体</li>
</ul>
</li>
<li>ArrayBuffer对象构造函数接受整数，代表字节数：<code>const buf = new ArrayBuffer(32);</code>构造32字节内存区域，每个字节的值都为0</li>
<li>使用ArrayBuffer需要先分配内存，再将内存赋予指定视图，然后才能操作视图</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>项目性能优化方案</title>
    <url>/post/32284b6cc564/</url>
    <content><![CDATA[<p>Vue 项目性能优化方案</p>
<p><strong>前言</strong></p>
<p>Vue 框架通过数据双向绑定和虚拟 DOM 技术，帮我们处理了前端开发中最脏最累的 DOM 操作部分， 我们不再需要去考虑如何操作 DOM 以及如何最高效地操作 DOM；但 Vue 项目中仍然存在项目首屏优化、Webpack 编译配置优化等问题，所以我们仍然需要去关注 Vue 项目性能方面的优化，使项目具有更高效的性能、更好的用户体验。本文是作者通过实际项目的优化实践进行总结而来，希望读者读完本文，有一定的启发思考，从而对自己的项目进行优化起到帮助。本文内容分为以下三部分组成：</p>
<ul>
<li><p>Vue 代码层面的优化；</p>
</li>
<li><p>webpack 配置层面的优化；</p>
</li>
<li><p>基础的 Web 技术层面的优化。</p>
</li>
</ul>
<h2 id="一、代码层面的优化"><a href="#一、代码层面的优化" class="headerlink" title="一、代码层面的优化"></a>一、代码层面的优化</h2><h3 id="1-1、v-if-和-v-show-区分使用场景"><a href="#1-1、v-if-和-v-show-区分使用场景" class="headerlink" title="1.1、v-if 和 v-show 区分使用场景"></a>1.1、v-if 和 v-show 区分使用场景</h3><p><strong>v-if</strong> 是 真正 的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>
<p><strong>v-show</strong> 就简单得多， 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换。</p>
<p>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p>
<h3 id="1-2、computed-和-watch-区分使用场景"><a href="#1-2、computed-和-watch-区分使用场景" class="headerlink" title="1.2、computed 和 watch 区分使用场景"></a>1.2、computed 和 watch 区分使用场景</h3><p><strong>computed</strong>： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；</p>
<p><strong>watch</strong>： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p>
<p>运用场景：</p>
<p>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</p>
<p>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p>
<h3 id="1-3、v-for-遍历必须为-item-添加-key，且避免同时使用-v-if"><a href="#1-3、v-for-遍历必须为-item-添加-key，且避免同时使用-v-if" class="headerlink" title="1.3、v-for 遍历必须为 item 添加 key，且避免同时使用 v-if"></a>1.3、v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</h3><p>（1）v-for 遍历必须为 item 添加 key</p>
<p>在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。</p>
<p>（2）v-for 遍历避免同时使用 v-if</p>
<p>v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。</p>
<p>推荐：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;  </span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;user in activeUsers&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;user.id&quot;</span>&gt;</span>&#123;&#123; user.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">  <span class="attr">computed</span>: &#123;  </span><br><span class="line">    <span class="attr">activeUsers</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">users</span>.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">user</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> user.<span class="property">isActive</span>    </span><br><span class="line">      &#125;)  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>不推荐：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;user in users&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;user.isActive&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;user.id&quot;</span>&gt;</span>&#123;&#123; user.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<h3 id="1-4、长列表性能优化"><a href="#1-4、长列表性能优化" class="headerlink" title="1.4、长列表性能优化"></a>1.4、长列表性能优化</h3><p>Vue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止 Vue 劫持我们的数据呢？可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="function">() =&gt;</span> (&#123; <span class="attr">users</span>: &#123;&#125; &#125;),</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> users = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&quot;/api/users&quot;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">users</span> = <span class="title class_">Object</span>.<span class="title function_">freeze</span>(users);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-5、事件的销毁"><a href="#1-5、事件的销毁" class="headerlink" title="1.5、事件的销毁"></a>1.5、事件的销毁</h3><p>Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。如果在 js 内</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">created</span>(<span class="params"></span>) &#123;  <span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="variable language_">this</span>.<span class="property">click</span>, <span class="literal">false</span>)&#125;,</span><br><span class="line"><span class="title function_">beforeDestroy</span>(<span class="params"></span>) &#123;  <span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="variable language_">this</span>.<span class="property">click</span>, <span class="literal">false</span>)&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6、图片资源懒加载"><a href="#1-6、图片资源懒加载" class="headerlink" title="1.6、图片资源懒加载"></a>1.6、图片资源懒加载</h3><p>对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样对于页面加载性能上会有很大的提升，也提高了用户体验。我们在项目中使用 Vue 的 vue-lazyload 插件：</p>
<p>（1）安装插件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install vue-lazyload --save-dev</span><br></pre></td></tr></table></figure>

<p>（2）在入口文件 man.js 中引入并使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">VueLazyload</span> <span class="keyword">from</span> <span class="string">&quot;vue-lazyload&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>然后再 vue 中直接使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueLazyload</span>);</span><br></pre></td></tr></table></figure>

<p>或者添加自定义选项</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueLazyload</span>, &#123;</span><br><span class="line">  <span class="attr">preLoad</span>: <span class="number">1.3</span>,</span><br><span class="line">  <span class="attr">error</span>: <span class="string">&quot;dist/error.png&quot;</span>,</span><br><span class="line">  <span class="attr">loading</span>: <span class="string">&quot;dist/loading.gif&quot;</span>,</span><br><span class="line">  <span class="attr">attempt</span>: <span class="number">1</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>（3）在 vue 文件中将 img 标签的 src 属性直接改为 v-lazy ，从而将图片显示方式更改为懒加载显示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;img v-lazy=<span class="string">&quot;/static/img/1.png&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>以上为 vue-lazyload 插件的简单使用，如果要看插件的更多参数选项，可以查看 vue-lazyload 的 github 地址。</p>
<h3 id="1-7、路由懒加载"><a href="#1-7、路由懒加载" class="headerlink" title="1.7、路由懒加载"></a>1.7、路由懒加载</h3><p>Vue 是单页面应用，可能会有很多的路由引入 ，这样使用 webpcak 打包后的文件很大，当进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来。</p>
<p>路由懒加载：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Foo</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="string">&#x27;./Foo.vue&#x27;</span>)<span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">    <span class="attr">routes</span>: [&#123; <span class="attr">path</span>: <span class="string">&#x27;/foo&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Foo</span> &#125;]</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="1-8、第三方插件的按需引入"><a href="#1-8、第三方插件的按需引入" class="headerlink" title="1.8、第三方插件的按需引入"></a>1.8、第三方插件的按需引入</h3><p>我们在项目中经常会需要引入第三方插件，如果我们直接引入整个插件，会导致项目的体积太大，我们可以借助 babel-plugin-component ，然后可以只引入需要的组件，以达到减小项目体积的目的。以下为项目中引入 element-ui 组件库为例：</p>
<p>（1）首先，安装 babel-plugin-component ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">npm install babel-plugin-component -D</span><br></pre></td></tr></table></figure>

<p>（2）然后，将 .babelrc 修改为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">  <span class="string">&quot;presets&quot;</span>: [[<span class="string">&quot;es2015&quot;</span>, &#123; <span class="string">&quot;modules&quot;</span>: <span class="literal">false</span> &#125;]],  </span><br><span class="line">  <span class="string">&quot;plugins&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;component&quot;</span>,  </span><br><span class="line">      &#123;</span><br><span class="line">      <span class="string">&quot;libraryName&quot;</span>: <span class="string">&quot;element-ui&quot;</span>,</span><br><span class="line">      <span class="string">&quot;styleLibraryName&quot;</span>: <span class="string">&quot;theme-chalk&quot;</span> </span><br><span class="line">      &#125;    </span><br><span class="line">    ]  </span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）在 main.js 中引入部分组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;<span class="keyword">import</span> &#123; <span class="title class_">Button</span>, <span class="title class_">Select</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span>;</span><br><span class="line"> <span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Button</span>) <span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Select</span>)</span><br></pre></td></tr></table></figure>

<h3 id="1-9、优化无限列表性能"><a href="#1-9、优化无限列表性能" class="headerlink" title="1.9、优化无限列表性能"></a>1.9、优化无限列表性能</h3><p>如果你的应用存在非常长或者无限滚动的列表，那么需要采用 窗口化 的技术来优化性能，只需要渲染少部分区域的内容，减少重新渲染组件和创建 dom 节点的时间。你可以参考以下开源项目 vue-virtual-scroll-list 和 vue-virtual-scroller 来优化这种无限列表的场景的。</p>
<h3 id="1-10、服务端渲染-SSR-or-预渲染"><a href="#1-10、服务端渲染-SSR-or-预渲染" class="headerlink" title="1.10、服务端渲染 SSR or 预渲染"></a>1.10、服务端渲染 SSR or 预渲染</h3><p>服务端渲染是指 Vue 在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的 html 片段直接返回给客户端这个过程就叫做服务端渲染。</p>
<p>（1）服务端渲染的优点：</p>
<p>更好的 SEO：因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</p>
<p>更快的内容到达时间（首屏加载更快）：SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；</p>
<p>（2）服务端渲染的缺点：</p>
<p>更多的开发条件限制：例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</p>
<p>更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源，因此如果你预料在高流量环境下使用，请准备相应的服务器负载，并明智地采用缓存策略。</p>
<p>如果你的项目的 SEO 和 首屏渲染是评价项目的关键指标，那么你的项目就需要服务端渲染来帮助你实现最佳的初始加载性能和 SEO，具体的 Vue SSR 如何实现，可以参考作者的另一篇文章《Vue SSR 踩坑之旅》。如果你的 Vue 项目只需改善少数营销页面（例如 &#x2F;， &#x2F;about， &#x2F;contact 等）的 SEO，那么你可能需要预渲染，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点，具体你可以使用 prerender-spa-plugin 就可以轻松地添加预渲染 。</p>
<h2 id="二、Webpack-层面的优化"><a href="#二、Webpack-层面的优化" class="headerlink" title="二、Webpack 层面的优化"></a>二、Webpack 层面的优化</h2><h3 id="2-1、Webpack-对图片进行压缩"><a href="#2-1、Webpack-对图片进行压缩" class="headerlink" title="2.1、Webpack 对图片进行压缩"></a>2.1、Webpack 对图片进行压缩</h3><p>在 vue 项目中除了可以在 webpack.base.conf.js 中 url-loader 中设置 limit 大小来对图片处理，对小于 limit 的图片转化为 base64 格式，其余的不做操作。所以对有些较大的图片资源，在请求资源的时候，加载会很慢，我们可以用 image-webpack-loader 来压缩图片：</p>
<p>（1）首先，安装 image-webpack-loader ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install image-webpack-loader --save-dev</span><br></pre></td></tr></table></figure>

<p>（2）然后，在 webpack.base.conf.js 中进行配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;  <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,  <span class="attr">use</span>:[    &#123;    <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,    <span class="attr">options</span>: &#123;      <span class="attr">limit</span>: <span class="number">10000</span>,      <span class="attr">name</span>: utils.<span class="title function_">assetsPath</span>(<span class="string">&#x27;img/[name].[hash:7].[ext]&#x27;</span>)      &#125;    &#125;,    &#123;      <span class="attr">loader</span>: <span class="string">&#x27;image-webpack-loader&#x27;</span>,      <span class="attr">options</span>: &#123;        <span class="attr">bypassOnDebug</span>: <span class="literal">true</span>,      &#125;    &#125;  ]&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2、减少-ES6-转为-ES5-的冗余代码"><a href="#2-2、减少-ES6-转为-ES5-的冗余代码" class="headerlink" title="2.2、减少 ES6 转为 ES5 的冗余代码"></a>2.2、减少 ES6 转为 ES5 的冗余代码</h3><p>Babel 插件会在将 ES6 代码转换成 ES5 代码时会注入一些辅助函数，例如下面的 ES6 代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HelloWebpack</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码再被转换成能正常运行的 ES5 代码时需要以下两个辅助函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">babel - runtime / helpers / createClass; <span class="comment">// 用于实现 class 语法babel-runtime/helpers/inherits  // 用于实现 extends 语法</span></span><br></pre></td></tr></table></figure>

<p>在默认情况下， Babel 会在每个输出文件中内嵌这些依赖的辅助函数代码，如果多个源代码文件都依赖这些辅助函数，那么这些辅助函数的代码将会出现很多次，造成代码冗余。为了不让这些辅助函数的代码重复出现，可以在依赖它们时通过 require(‘babel-runtime&#x2F;helpers&#x2F;createClass’) 的方式导入，这样就能做到只让它们出现一次。babel-plugin-transform-runtime 插件就是用来实现这个作用的，将相关辅助函数进行替换成导入语句，从而减小 babel 编译出来的代码的文件大小。</p>
<p>（1）首先，安装 babel-plugin-transform-runtime ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install babel-plugin-transform-runtime --save-dev</span><br></pre></td></tr></table></figure>

<p>（2）然后，修改 .babelrc 配置文件为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;plugins&quot;</span>: [    <span class="string">&quot;transform-runtime&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>如果要看插件的更多详细内容，可以查看 babel-plugin-transform-runtime 的 详细介绍。</p>
<h3 id="2-3、提取公共代码"><a href="#2-3、提取公共代码" class="headerlink" title="2.3、提取公共代码"></a>2.3、提取公共代码</h3><p>如果项目中没有去将每个页面的第三方库和公共模块提取出来，则项目会存在以下问题：</p>
<p>相同的资源被重复加载，浪费用户的流量和服务器的成本。</p>
<p>每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。</p>
<p>所以我们需要将多个页面的公共代码抽离成单独的文件，来优化以上问题 。Webpack 内置了专门用于提取多个 Chunk 中的公共部分的插件 CommonsChunkPlugin，我们在项目中 CommonsChunkPlugin 的配置如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 所有在 package.json 里面依赖的包，都会被打包进 vendor.js 这个文件中。</span></span><br><span class="line"><span class="keyword">new</span> webpack.<span class="property">optimize</span>.<span class="title class_">CommonsChunkPlugin</span>(&#123;  </span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;vendor&#x27;</span>,  <span class="attr">minChunks</span>: <span class="keyword">function</span>(<span class="params"><span class="variable language_">module</span>, count</span>) &#123;    </span><br><span class="line">    <span class="keyword">return</span> (      </span><br><span class="line">      <span class="variable language_">module</span>.<span class="property">resource</span> &amp;&amp;<span class="regexp">/\.js$/</span>.<span class="title function_">test</span>(<span class="variable language_">module</span>.<span class="property">resource</span>) &amp;&amp;<span class="variable language_">module</span>.<span class="property">resource</span>.<span class="title function_">indexOf</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;../node_modules&#x27;</span>)) === <span class="number">0</span>    </span><br><span class="line">    );  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;),</span><br><span class="line"><span class="comment">// 抽取出代码模块的映射关系new webpack.optimize.CommonsChunkPlugin(&#123;  name: &#x27;manifest&#x27;,  chunks: [&#x27;vendor&#x27;]&#125;)</span></span><br></pre></td></tr></table></figure>

<p>如果要看插件的更多详细内容，可以查看 CommonsChunkPlugin 的 详细介绍。</p>
<h3 id="2-4、模板预编译"><a href="#2-4、模板预编译" class="headerlink" title="2.4、模板预编译"></a>2.4、模板预编译</h3><p>当使用 DOM 内模板或 JavaScript 内的字符串模板时，模板会在运行时被编译为渲染函数。通常情况下这个过程已经足够快了，但对性能敏感的应用还是最好避免这种用法。</p>
<p>预编译模板最简单的方式就是使用单文件组件——相关的构建设置会自动把预编译处理好，所以构建好的代码已经包含了编译出来的渲染函数而不是原始的模板字符串。</p>
<p>如果你使用 webpack，并且喜欢分离 JavaScript 和模板文件，你可以使用 vue-template-loader，它也可以在构建过程中把模板文件转换成为 JavaScript 渲染函数。</p>
<h3 id="2-5、提取组件的-CSS"><a href="#2-5、提取组件的-CSS" class="headerlink" title="2.5、提取组件的 CSS"></a>2.5、提取组件的 CSS</h3><p>当使用单文件组件时，组件内的 CSS 会以 style 标签的方式通过 JavaScript 动态注入。这有一些小小的运行时开销，如果你使用服务端渲染，这会导致一段 “无样式内容闪烁 (fouc) ” 。将所有组件的 CSS 提取到同一个文件可以避免这个问题，也会让 CSS 更好地进行压缩和缓存。</p>
<p>查阅这个构建工具各自的文档来了解更多：</p>
<p>webpack + vue-loader ( vue-cli 的 webpack 模板已经预先配置好)</p>
<p>Browserify + vueify</p>
<p>Rollup + rollup-plugin-vue</p>
<h3 id="2-6、优化-SourceMap"><a href="#2-6、优化-SourceMap" class="headerlink" title="2.6、优化 SourceMap"></a>2.6、优化 SourceMap</h3><p>我们在项目进行打包后，会将开发中的多个文件代码打包到一个文件中，并且经过压缩、去掉多余的空格、babel 编译化后，最终将编译得到的代码会用于线上环境，那么这样处理后的代码和源代码会有很大的差别，当有 bug 的时候，我们只能定位到压缩处理后的代码位置，无法定位到开发环境中的代码，对于开发来说不好调式定位问题，因此 sourceMap 出现了，它就是为了解决不好调式代码问题的。</p>
<p>SourceMap 的可选值如下（+ 号越多，代表速度越快，- 号越多，代表速度越慢, o 代表中等速度 ）</p>
<p>开发环境推荐：cheap-module-eval-source-map</p>
<p>生产环境推荐：cheap-module-source-map</p>
<p>原因如下：</p>
<p>cheap：源代码中的列信息是没有任何作用，因此我们打包后的文件不希望包含列相关信息，只有行信息能建立打包前后的依赖关系。因此不管是开发环境或生产环境，我们都希望添加 cheap 的基本类型来忽略打包前后的列信息；</p>
<p>module ：不管是开发环境还是正式环境，我们都希望能定位到 bug 的源代码具体的位置，比如说某个 Vue 文件报错了，我们希望能定位到具体的 Vue 文件，因此我们也需要 module 配置；</p>
<p>soure-map ：source-map 会为每一个打包后的模块生成独立的 soucemap 文件 ，因此我们需要增加 source-map 属性；</p>
<p>eval-source-map：eval 打包代码的速度非常快，因为它不生成 map 文件，但是可以对 eval 组合使用 eval-source-map 使用会将 map 文件以 DataURL 的形式存在打包后的 js 文件中。在正式环境中不要使用 eval-source-map, 因为它会增加文件的大小，但是在开发环境中，可以试用下，因为他们打包的速度很快。</p>
<p>2.7、构建结果输出分析<br>Webpack 输出的代码可读性非常差而且文件非常大，让我们非常头疼。为了更简单、直观地分析输出结果，社区中出现了许多可视化分析工具。这些工具以图形的方式将结果更直观地展示出来，让我们快速了解问题所在。接下来讲解我们在 Vue 项目中用到的分析工具：webpack-bundle-analyzer 。</p>
<p>我们在项目中 webpack.prod.conf.js 进行配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (config.<span class="property">build</span>.<span class="property">bundleAnalyzerReport</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="title class_">BundleAnalyzerPlugin</span> =</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&quot;webpack-bundle-analyzer&quot;</span>).<span class="property">BundleAnalyzerPlugin</span>;</span><br><span class="line">  webpackConfig.<span class="property">plugins</span>.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">BundleAnalyzerPlugin</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行 $ npm run build –report 后生成分析报告如下：</p>
<h3 id="2-8、Vue-项目的编译优化"><a href="#2-8、Vue-项目的编译优化" class="headerlink" title="2.8、Vue 项目的编译优化"></a>2.8、Vue 项目的编译优化</h3><p>如果你的 Vue 项目使用 Webpack 编译，需要你喝一杯咖啡的时间，那么也许你需要对项目的 Webpack 配置进行优化，提高 Webpack 的构建效率。具体如何进行 Vue 项目的 Webpack 构建优化，可以参考作者的另一篇文章《 Vue 项目 Webpack 优化实践》</p>
<h2 id="三、基础的-Web-技术优化"><a href="#三、基础的-Web-技术优化" class="headerlink" title="三、基础的 Web 技术优化"></a>三、基础的 Web 技术优化</h2><h3 id="3-1、开启-gzip-压缩"><a href="#3-1、开启-gzip-压缩" class="headerlink" title="3.1、开启 gzip 压缩"></a>3.1、开启 gzip 压缩</h3><p>gzip 是 GNUzip 的缩写，最早用于 UNIX 系统的文件压缩。HTTP 协议上的 gzip 编码是一种用来改进 web 应用程序性能的技术，web 服务器和客户端（浏览器）必须共同支持 gzip。目前主流的浏览器，Chrome，firefox，IE 等都支持该协议。常见的服务器如 Apache，Nginx，IIS 同样支持，gzip 压缩效率非常高，通常可以达到 70% 的压缩率，也就是说，如果你的网页有 30K，压缩之后就变成了 9K 左右</p>
<p>以下我们以服务端使用我们熟悉的 express 为例，开启 gzip 非常简单，相关步骤如下：</p>
<p>安装：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install compression --save</span><br></pre></td></tr></table></figure>

<p>添加代码逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> compression = <span class="built_in">require</span>(<span class="string">&quot;compression&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> app = <span class="title function_">express</span>();</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">compression</span>());</span><br></pre></td></tr></table></figure>

<p>重启服务，观察网络面板里面的 response header，如果看到红圈里的字段则表明 gzip 开启成功。</p>
<h3 id="3-2、浏览器缓存"><a href="#3-2、浏览器缓存" class="headerlink" title="3.2、浏览器缓存"></a>3.2、浏览器缓存</h3><p>为了提高用户加载页面的速度，对静态资源进行缓存是非常必要的，根据是否需要重新向服务器发起请求来分类，将 HTTP 缓存规则分为两大类（强制缓存，对比缓存），如果对缓存机制还不是了解很清楚的，可以参考作者写的关于 HTTP 缓存的文章《深入理解 HTTP 缓存机制及原理》，这里不再赘述。</p>
<h3 id="3-3、CDN-的使用"><a href="#3-3、CDN-的使用" class="headerlink" title="3.3、CDN 的使用"></a>3.3、CDN 的使用</h3><p>浏览器从服务器上下载 CSS、js 和图片等文件时都要和服务器连接，而大部分服务器的带宽有限，如果超过限制，网页就半天反应不过来。而 CDN 可以通过不同的域名来加载文件，从而使下载文件的并发连接数大大增加，且 CDN 具有更好的可用性，更低的网络延迟和丢包率 。</p>
<h3 id="3-4、使用-Chrome-Performance-查找性能瓶颈"><a href="#3-4、使用-Chrome-Performance-查找性能瓶颈" class="headerlink" title="3.4、使用 Chrome Performance 查找性能瓶颈"></a>3.4、使用 Chrome Performance 查找性能瓶颈</h3><p>Chrome 的 Performance 面板可以录制一段时间内的 js 执行细节及时间。使用 Chrome 开发者工具分析页面性能的步骤如下。</p>
<ul>
<li><p>1、打开 Chrome 开发者工具，切换到 Performance 面板</p>
</li>
<li><p>2、点击 Record 开始录制</p>
</li>
<li><p>3、刷新页面或展开某个节点</p>
</li>
<li><p>4、点击 Stop 停止录制</p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基础</title>
    <url>/post/2708b90f67a7/</url>
    <content><![CDATA[<blockquote>
<p>说明：本章内容为博主在原教程基础上添加自己的学习笔记，来源<a href="https://wangdoc.com/javascript/">https://wangdoc.com/javascript/</a>，教程版权归原作者所有。</p>
</blockquote>
<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="一、JS的一些名词概念"><a href="#一、JS的一些名词概念" class="headerlink" title="一、JS的一些名词概念"></a>一、JS的一些名词概念</h2><h4 id="什么是作用域？"><a href="#什么是作用域？" class="headerlink" title="什么是作用域？"></a>什么是作用域？</h4><p>变量存在的范围。</p>
<p>可分为全局作用域和函数作用域，ES6新增块级作用域。</p>
<h4 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h4><p>闭包就是能够读取其他函数内部变量的函数。</p>
<ul>
<li>闭包的形式：函数内部定义函数</li>
<li>本质上闭包就是将函数内部和外部连接起来的一座桥梁</li>
</ul>
<p>闭包的作用：</p>
<ul>
<li>可以读取函数内部变量</li>
<li>让这些变量始终保持在内存中，即闭包可以使得它诞生的环境一直存在。</li>
<li>封装对象的私有属性和私有方法</li>
</ul>
<h4 id="什么是构造函数？"><a href="#什么是构造函数？" class="headerlink" title="什么是构造函数？"></a>什么是构造函数？</h4><p>用于构造(生成)实例的一个函数，使实例拥有构造函数内定于的属性和方法。</p>
<h4 id="什么是实例对象？"><a href="#什么是实例对象？" class="headerlink" title="什么是实例对象？"></a>什么是实例对象？</h4><p>实例对象就是通过new 构造函数生成的，拥有构造函数内定于的属性和方法的一个对象。</p>
<h4 id="什么是this？"><a href="#什么是this？" class="headerlink" title="什么是this？"></a>什么是this？</h4><p>就是属性或方法当前所在的对象，指向当前运行环境（对象）</p>
<h4 id="什么是原型？"><a href="#什么是原型？" class="headerlink" title="什么是原型？"></a>什么是原型？</h4><p>每个函数都有一个prototype属性，指向一个对象，该对象称为原型对象。</p>
<h4 id="什么是原型链？"><a href="#什么是原型链？" class="headerlink" title="什么是原型链？"></a>什么是原型链？</h4><p>所有对象都有自己的原型对象，由于原型对象也是对象，因此它也有自己的原型，这就会形成一个原型链。</p>
<p>最顶层的原型是Object.prototype。</p>
<blockquote>
<p>读取对象属性时，JS会先在对象自身上找，找到就直接返回，如果找不到，会到原型上找，如果还是找不到，就会去原型的原型上找，最终会到最顶层的Object.prototype上找，还是找不到就会返回undefined。</p>
</blockquote>
<h4 id="什么是constructor？"><a href="#什么是constructor？" class="headerlink" title="什么是constructor？"></a>什么是constructor？</h4><p>prototype原型对象都有一个constructor属性，默认指向prototype对象所在的构造函数。</p>
<h4 id="什么是包装对象？"><a href="#什么是包装对象？" class="headerlink" title="什么是包装对象？"></a>什么是包装对象？</h4><p>包装对象指的是将原始类型（数字、字符串、布尔值）进行实例化。</p>
<h2 id="二、数据类型的转换"><a href="#二、数据类型的转换" class="headerlink" title="二、数据类型的转换"></a>二、数据类型的转换</h2><h3 id="1、强制（手动）转换"><a href="#1、强制（手动）转换" class="headerlink" title="1、强制（手动）转换"></a>1、强制（手动）转换</h3><p> 强制转换主要指使用<code>Number()</code>、<code>String()</code>和<code>Boolean()</code>三个函数，手动将各种类型的值，分别转换成<strong>数字、字符串、布尔值</strong>。</p>
<h4 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数值：转换后还是原来的值</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="number">324</span>) <span class="comment">// 324</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串：如果可以被解析为数值，则转换为相应的数值</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;324&#x27;</span>) <span class="comment">// 324</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串：如果不可以被解析为数值，返回 NaN</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;324abc&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空字符串转为0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔值：true 转成 1，false 转成 0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">false</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined：转成 NaN</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null：转成0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;) <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Number</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Number</span>([<span class="number">5</span>]) <span class="comment">// 5</span></span><br><span class="line"><span class="title class_">Number</span>([]) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用parseInt()转数组</span></span><br><span class="line"><span class="built_in">parseInt</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h4 id="String"><a href="#String" class="headerlink" title="String()"></a>String()</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原始类型的转换</span></span><br><span class="line"><span class="title class_">String</span>(<span class="number">123</span>) <span class="comment">// &quot;123&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">// &quot;abc&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">true</span>) <span class="comment">// &quot;true&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">undefined</span>) <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">null</span>) <span class="comment">// &quot;null&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的转换</span></span><br><span class="line"><span class="title class_">String</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;) <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="title class_">String</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// &quot;1,2,3&quot;</span></span><br><span class="line"><span class="title class_">String</span>([]) <span class="comment">// &quot;&quot;  空字符串</span></span><br><span class="line"><span class="title class_">String</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;) <span class="comment">// &quot;function()&#123;&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean()"></a>Boolean()</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 除了这五个为false，其他都为true</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="title class_">NaN</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="title class_">Boolean</span>(&#123;&#125;) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Boolean</span>([]) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">false</span>)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="string">&#x27; &#x27;</span>) <span class="comment">// true // 注意字符串内有个空格</span></span><br></pre></td></tr></table></figure>

<h3 id="2、自动转换"><a href="#2、自动转换" class="headerlink" title="2、自动转换"></a>2、自动转换</h3><p>下面介绍自动转换，它是<strong>以强制转换为基础的</strong>。</p>
<p>遇到以下三种情况时，JavaScript 会自动转换数据类型，即转换是自动完成的，用户不可见。</p>
<p>第一种情况，<strong>不同类型的数据互相运算</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">123</span> + <span class="string">&#x27;abc&#x27;</span> <span class="comment">// &quot;123abc&quot;</span></span><br></pre></td></tr></table></figure>

<p> 第二种情况，<strong>对非布尔值类型的数据求布尔值</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;abc&#x27;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;  <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<p> 第三种情况，<strong>对非数值类型的值使用一元运算符（即<code>+</code>和<code>-</code>）</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+ &#123;<span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>&#125; <span class="comment">// NaN</span></span><br><span class="line">- [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。比如，某个位置预期为字符串，就调用<code>String</code>函数进行转换。如果该位置即可以是字符串，也可能是数值，那么默认转为数值。</p>
<p>由于自动转换具有不确定性，而且不易除错，建议在预期为布尔值、数值、字符串的地方，全部使用<code>Boolean</code>、<code>Number</code>和<code>String</code>函数进行显式转换。</p>
<h4 id="自动转换为布尔值（Boolean）"><a href="#自动转换为布尔值（Boolean）" class="headerlink" title="自动转换为布尔值（Boolean）"></a>自动转换为布尔值（Boolean）</h4><p>JavaScript 遇到预期为布尔值的地方（比如<code>if</code>语句的条件部分），就会将非布尔值的参数自动转换为布尔值。系统内部会自动调用<code>Boolean</code>函数。</p>
<p>因此除了以下五个值，其他都是自动转为<code>true</code>。</p>
<ul>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>+0</code>或<code>-0</code></li>
<li><code>NaN</code></li>
<li><code>&#39;&#39;</code>（空字符串）</li>
</ul>
<p>下面这个例子中，条件部分的每个值都相当于<code>false</code>，使用否定运算符后，就变成了<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !<span class="literal">undefined</span></span><br><span class="line">  &amp;&amp; !<span class="literal">null</span></span><br><span class="line">  &amp;&amp; !<span class="number">0</span></span><br><span class="line">  &amp;&amp; !<span class="title class_">NaN</span></span><br><span class="line">  &amp;&amp; !<span class="string">&#x27;&#x27;</span></span><br><span class="line">) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">&#125; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>下面两种写法，有时也用于将一个表达式转为布尔值。它们内部调用的也是<code>Boolean</code>函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 三元运算符</span></span><br><span class="line">expression ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取反运算符</span></span><br><span class="line">!! expression</span><br></pre></td></tr></table></figure>



<h4 id="自动转换为字符串（String）"><a href="#自动转换为字符串（String）" class="headerlink" title="自动转换为字符串（String）"></a>自动转换为字符串（String）</h4><p>JavaScript 遇到预期为字符串的地方，就会将非字符串的值自动转为字符串。<strong>具体规则是，先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串</strong>。</p>
<p>字符串的自动转换，<strong>主要发生在字符串的加法运算时</strong>。当一个值为字符串，另一个值为非字符串，则后者转为字符串。</p>
<h5 id="所有类型的值与字符串相加都会变成字符串"><a href="#所有类型的值与字符串相加都会变成字符串" class="headerlink" title="所有类型的值与字符串相加都会变成字符串"></a>所有类型的值与字符串相加都会变成字符串</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="number">1</span> <span class="comment">// &#x27;51&#x27;</span></span><br><span class="line"> <span class="number">1</span>  + <span class="string">&#x27;5&#x27;</span> <span class="comment">// &#x27;15&#x27;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">true</span> <span class="comment">// &quot;5true&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">false</span> <span class="comment">// &quot;5false&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + &#123;&#125; <span class="comment">// &quot;5[object Object]&quot;</span></span><br><span class="line"> <span class="number">5</span> + &#123;&#125; <span class="comment">// &quot;5[object Object]&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + [] <span class="comment">// &quot;5&quot;</span></span><br><span class="line"> <span class="number">5</span> + [] <span class="comment">// &quot;5&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="keyword">function</span> (<span class="params"></span>)&#123;&#125; <span class="comment">// &quot;5function ()&#123;&#125;&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">undefined</span> <span class="comment">// &quot;5undefined&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">null</span> <span class="comment">// &quot;5null&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id=""><a href="#" class="headerlink" title=""></a></h5><p>这种自动转换不注意的话很容易出错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">width</span>: <span class="string">&#x27;100&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">width</span> + <span class="number">20</span> <span class="comment">// &quot;10020&quot;</span></span><br><span class="line"><span class="title function_">parerInt</span>(obj.<span class="property">width</span>) + <span class="number">20</span> <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，开发者可能期望返回<code>120</code>，但是由于自动转换，实际上返回了一个字符<code>10020</code>。正确做法是先把字符串转成数字。</p>
<h4 id="自动转换为数值（Number）"><a href="#自动转换为数值（Number）" class="headerlink" title="自动转换为数值（Number）"></a>自动转换为数值（Number）</h4><p>JavaScript 遇到预期为数值的地方，就会将参数值自动转换为数值。系统内部会自动调用<code>Number</code>函数。</p>
<h5 id="除加号与字符串运行会转成字符串外，其他运行基本都会自动转成数值"><a href="#除加号与字符串运行会转成字符串外，其他运行基本都会自动转成数值" class="headerlink" title="除加号与字符串运行会转成字符串外，其他运行基本都会自动转成数值"></a>除加号与字符串运行会转成字符串外，其他运行基本都会自动转成数值</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;5&#x27;</span> - <span class="string">&#x27;2&#x27;</span> <span class="comment">// 3</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> * <span class="string">&#x27;2&#x27;</span> <span class="comment">// 10</span></span><br><span class="line"><span class="literal">true</span> - <span class="number">1</span>  <span class="comment">// 0</span></span><br><span class="line"><span class="literal">false</span> - <span class="number">1</span> <span class="comment">// -1</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> - <span class="number">1</span>   <span class="comment">// 0</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> * []    <span class="comment">// 0</span></span><br><span class="line"><span class="literal">false</span> / <span class="string">&#x27;5&#x27;</span> <span class="comment">// 0</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span> - <span class="number">1</span>   <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">null</span> + <span class="number">1</span> <span class="comment">// 1</span></span><br><span class="line"><span class="literal">undefined</span> + <span class="number">1</span> <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="literal">true</span>+<span class="literal">true</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，运算符两侧的运算子，都被转成了数值。</p>
<blockquote>
<p>注意：<code>null</code>转为数值时为<code>0</code>，而<code>undefined</code>转为数值时为<code>NaN</code>。</p>
</blockquote>
<p><strong>数值与布尔值、null也会转为数值</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span>+<span class="literal">true</span> <span class="comment">// 6</span></span><br><span class="line"><span class="number">5</span>+<span class="literal">false</span> <span class="comment">// 5</span></span><br><span class="line"><span class="number">5</span>+<span class="literal">null</span> <span class="comment">//5</span></span><br></pre></td></tr></table></figure>



<p>一元运算符也会把运算子转成数值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+<span class="string">&#x27;abc&#x27;</span> <span class="comment">// NaN</span></span><br><span class="line">-<span class="string">&#x27;abc&#x27;</span> <span class="comment">// NaN</span></span><br><span class="line">+<span class="literal">true</span> <span class="comment">// 1</span></span><br><span class="line">-<span class="literal">false</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>



<h2 id="三、错误处理机制"><a href="#三、错误处理机制" class="headerlink" title="三、错误处理机制"></a>三、错误处理机制</h2><h3 id="1、Error实例对象"><a href="#1、Error实例对象" class="headerlink" title="1、Error实例对象"></a>1、Error实例对象</h3><p>JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供<code>Error</code>构造函数，所有抛出的错误都是这个构造函数的实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> err = <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">err.<span class="property">message</span> <span class="comment">// &quot;出错了&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，我们调用<code>Error</code>构造函数，生成一个实例对象<code>err</code>。<code>Error</code>构造函数接受一个参数，表示错误提示，可以从实例的<code>message</code>属性读到这个参数。<strong>抛出<code>Error</code>实例对象以后，整个程序就中断在发生错误的地方，不再往下执行</strong>。</p>
<p>JavaScript 语言标准只提到，<code>Error</code>实例对象必须有<code>message</code>属性，表示出错时的提示信息，没有提到其他属性。大多数 JavaScript 引擎，对<code>Error</code>实例还提供<code>name</code>和<code>stack</code>属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。</p>
<ul>
<li><strong>message</strong>：错误提示信息</li>
<li><strong>name</strong>：错误名称（非标准属性）</li>
<li><strong>stack</strong>：错误的堆栈（非标准属性）</li>
</ul>
<p>使用<code>name</code>和<code>message</code>这两个属性，可以对发生什么错误有一个大概的了解。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> err = <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (err.<span class="property">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">name</span> + <span class="string">&#x27;: &#x27;</span> + err.<span class="property">message</span>); <span class="comment">// Error: 出错了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>stack</code>属性用来查看错误发生时的堆栈。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throwit</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">catchit</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title function_">throwit</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">stack</span>); <span class="comment">// print stack trace</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">catchit</span>()</span><br><span class="line"><span class="comment">// Error</span></span><br><span class="line"><span class="comment">//    at throwit (~/examples/throwcatch.js:9:11) // 堆栈的最内层throwit函数</span></span><br><span class="line"><span class="comment">//    at catchit (~/examples/throwcatch.js:3:9) // 向外一层catchit函数</span></span><br><span class="line"><span class="comment">//    at repl:1:5 // 函数的运行环境</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆栈信息说明</span></span><br><span class="line"><span class="comment">// Error 错误</span></span><br><span class="line"><span class="comment">//    at throwit 在throwit方法 (~/examples/throwcatch.js:9:11) 文件名：第几行：第几个字符</span></span><br><span class="line"><span class="comment">//    at catchit 在catchit方法 (~/examples/throwcatch.js:3:9) 文件名：第几行：第几个字符</span></span><br><span class="line"><span class="comment">//    at repl:1:5 // 函数的运行环境</span></span><br></pre></td></tr></table></figure>

<p> 上面代码中，错误堆栈的最内层是<code>throwit</code>函数，然后是<code>catchit</code>函数，最后是函数的运行环境。</p>
<h3 id="2、原生错误类型"><a href="#2、原生错误类型" class="headerlink" title="2、原生错误类型"></a>2、原生错误类型</h3><p> <code>Error</code>实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在<code>Error</code>的6个派生对象。</p>
<h4 id="SyntaxError-对象（语法错误）"><a href="#SyntaxError-对象（语法错误）" class="headerlink" title="SyntaxError 对象（语法错误）"></a>SyntaxError 对象（语法错误）</h4><p> <code>SyntaxError</code>对象是解析代码时发生的<strong>语法错误</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量名错误</span></span><br><span class="line"><span class="keyword">var</span> 1a;</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class="line"><span class="comment">// 语法错误：无效或意外的标记符号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缺少括号</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="property">log</span> <span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Unexpected string</span></span><br><span class="line"><span class="comment">// 语法错误：意外的字符串</span></span><br></pre></td></tr></table></figure>

<p>上面代码的错误，都是在语法解析阶段就可以发现，所以会抛出<code>SyntaxError</code>。第一个错误提示是“token 非法”，第二个错误提示是“字符串不符合要求”。</p>
<h4 id="ReferenceError-对象（引用错误）"><a href="#ReferenceError-对象（引用错误）" class="headerlink" title="ReferenceError 对象（引用错误）"></a>ReferenceError 对象（引用错误）</h4><p> <code>ReferenceError</code>对象是<strong>引用一个不存在的变量时发生的错误</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用一个不存在的变量</span></span><br><span class="line">unknownVariable</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: unknownVariable is not defined</span></span><br><span class="line"><span class="comment">// 引用错误： unknownVariable 没有定义</span></span><br></pre></td></tr></table></figure>

<p>另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者<code>this</code>赋值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等号左侧不是变量</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>() = <span class="number">1</span></span><br><span class="line"><span class="comment">// Uncaught ReferenceError: Invalid left-hand side in assignment</span></span><br><span class="line"><span class="comment">// 引用错误： 赋值中左边是无效的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// this 对象不能手动赋值</span></span><br><span class="line"><span class="variable language_">this</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// ReferenceError: Invalid left-hand side in assignment</span></span><br><span class="line"><span class="comment">// 引用错误：  赋值中左边是无效的</span></span><br></pre></td></tr></table></figure>

<p>上面代码对函数<code>console.log</code>的运行结果和<code>this</code>赋值，结果都引发了<code>ReferenceError</code>错误。</p>
<h4 id="RangeError-对象（范围错误）"><a href="#RangeError-对象（范围错误）" class="headerlink" title="RangeError 对象（范围错误）"></a>RangeError 对象（范围错误）</h4><p> <code>RangeError</code>对象是一个值<strong>超出有效范围时发生的错误</strong>。主要有几种情况，一是数组长度为负数，二是<code>Number</code>对象的方法参数超出范围，以及函数堆栈超过最大值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组长度不得为负数</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Array</span>(-<span class="number">1</span>)</span><br><span class="line"><span class="comment">// Uncaught RangeError: Invalid array length</span></span><br><span class="line"><span class="comment">// 范围错误：无效的数组长度</span></span><br></pre></td></tr></table></figure>



<h4 id="TypeError-对象（类型错误）"><a href="#TypeError-对象（类型错误）" class="headerlink" title="TypeError 对象（类型错误）"></a>TypeError 对象（类型错误）</h4><p> <code>TypeError</code>对象是<strong>变量或参数不是预期类型时发生的错误</strong>。比如，对字符串、布尔值、数值等原始类型的值使用<code>new</code>命令，就会抛出这种错误，因为<code>new</code>命令的参数应该是一个构造函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="number">123</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: number is not a function</span></span><br><span class="line"><span class="comment">// 类型错误： 数字不是一个函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="title function_">unknownMethod</span>()</span><br><span class="line"><span class="comment">// Uncaught TypeError: obj.unknownMethod is not a function</span></span><br><span class="line"><span class="comment">// 类型错误：obj.unknownMethod 不是一个函数</span></span><br></pre></td></tr></table></figure>

<p>上面代码的第二种情况，调用对象不存在的方法，也会抛出<code>TypeError</code>错误，因为<code>obj.unknownMethod</code>的值是<code>undefined</code>，而不是一个函数。</p>
<h4 id="URIError-对象-（URI错误）"><a href="#URIError-对象-（URI错误）" class="headerlink" title="URIError 对象 （URI错误）"></a>URIError 对象 （URI错误）</h4><p><code>URIError</code>对象是 <strong>URI 相关函数的参数不正确时抛出的错误</strong>，主要涉及<code>encodeURI()</code>、<code>decodeURI()</code>、<code>encodeURIComponent()</code>、<code>decodeURIComponent()</code>、<code>escape()</code>和<code>unescape()</code>这六个函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">decodeURI</span>(<span class="string">&#x27;%2&#x27;</span>)</span><br><span class="line"><span class="comment">// URIError: URI malformed</span></span><br></pre></td></tr></table></figure>



<h4 id="EvalError-对象-（eval错误）"><a href="#EvalError-对象-（eval错误）" class="headerlink" title="EvalError 对象 （eval错误）"></a>EvalError 对象 （eval错误）</h4><p><code>eval</code>函数没有被正确执行时，会抛出<code>EvalError</code>错误。该<strong>错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。</strong></p>
<h4 id="总结（开发者手动使用）"><a href="#总结（开发者手动使用）" class="headerlink" title="总结（开发者手动使用）"></a>总结（开发者手动使用）</h4><p>以上这6种派生错误，连同原始的<code>Error</code>对象，都是构造函数。<strong>开发者可以使用它们，手动生成错误对象的实例</strong>。这些构造函数都接受一个参数，代表错误提示信息（message）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> err1 = <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;出错了！&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> err2 = <span class="keyword">new</span> <span class="title class_">RangeError</span>(<span class="string">&#x27;出错了，变量超出有效范围！&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> err3 = <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;出错了，变量类型无效！&#x27;</span>);</span><br><span class="line"></span><br><span class="line">err1.<span class="property">message</span> <span class="comment">// &quot;出错了！&quot;</span></span><br><span class="line">err2.<span class="property">message</span> <span class="comment">// &quot;出错了，变量超出有效范围！&quot;</span></span><br><span class="line">err3.<span class="property">message</span> <span class="comment">// &quot;出错了，变量类型无效！&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="3、自定义错误"><a href="#3、自定义错误" class="headerlink" title="3、自定义错误"></a>3、自定义错误</h3><p> 除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">UserError</span>(<span class="params">message</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">message</span> = message || <span class="string">&#x27;默认信息&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;UserError&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">UserError</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Error</span>(); <span class="comment">// 原型继承 Error对象</span></span><br><span class="line"><span class="title class_">UserError</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">UserError</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">UserError</span>(<span class="string">&#x27;这是自定义的错误！&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码自定义一个错误对象<code>UserError</code>，让它继承<code>Error</code>对象。然后，就可以生成这种自定义类型的错误了。</p>
<h3 id="4、throw-语句-（中断程序并抛出错误）"><a href="#4、throw-语句-（中断程序并抛出错误）" class="headerlink" title="4、throw 语句 （中断程序并抛出错误）"></a>4、throw 语句 （中断程序并抛出错误）</h3><p> <code>throw</code>语句的作用是<strong>手动中断程序执行，抛出一个错误</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;x 必须为正数&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught Error: x 必须为正数</span></span><br></pre></td></tr></table></figure>

<p> 上面代码中，如果变量<code>x</code>小于等于<code>0</code>，就手动抛出一个错误，告诉用户<code>x</code>的值不正确，整个程序就会在这里中断执行。可以看到，<code>throw</code>抛出的错误就是它的参数，这里是一个<code>Error</code>实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">UserError</span>(<span class="params">message</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">message</span> = message || <span class="string">&#x27;默认信息&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;UserError&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UserError</span>(<span class="string">&#x27;出错了！&#x27;</span>);</span><br><span class="line"><span class="comment">// Uncaught UserError &#123;message: &quot;出错了！&quot;, name: &quot;UserError&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p> 上面代码中，<code>throw</code>抛出的是一个<code>UserError</code>实例。</p>
<p>实际上，<code>throw</code>可以抛出任何类型的值。也就是说，它的参数可以是任何值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抛出一个字符串</span></span><br><span class="line"><span class="keyword">throw</span> <span class="string">&#x27;Error！&#x27;</span>;</span><br><span class="line"><span class="comment">// Uncaught Error！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出一个数值</span></span><br><span class="line"><span class="keyword">throw</span> <span class="number">42</span>;</span><br><span class="line"><span class="comment">// Uncaught 42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出一个布尔值</span></span><br><span class="line"><span class="keyword">throw</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// Uncaught true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出一个对象</span></span><br><span class="line"><span class="keyword">throw</span> &#123;</span><br><span class="line">  <span class="attr">toString</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Error!&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Uncaught &#123;toString: ƒ&#125;</span></span><br></pre></td></tr></table></figure>

<p> 对于 JavaScript 引擎来说，<strong>遇到<code>throw</code>语句，程序就中止了</strong>。引擎会接收到<code>throw</code>抛出的信息，可能是一个错误实例，也可能是其他类型的值。</p>
<h3 id="5、try…catch-结构（捕获错误，对错误进行处理，不中断）"><a href="#5、try…catch-结构（捕获错误，对错误进行处理，不中断）" class="headerlink" title="5、try…catch 结构（捕获错误，对错误进行处理，不中断）"></a>5、try…catch 结构（捕获错误，对错误进行处理，不中断）</h3><p> 一旦发生错误，程序就中止执行了。JavaScript 提供了<code>try...catch</code>结构，<strong>允许对错误进行处理</strong>，选择是否往下执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;出错了!&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">name</span> + <span class="string">&quot;: &quot;</span> + e.<span class="property">message</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">stack</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Error: 出错了!</span></span><br><span class="line"><span class="comment">//   at &lt;anonymous&gt;:3:9</span></span><br><span class="line"><span class="comment">//   ...</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>try</code>代码块抛出错误（上例用的是<code>throw</code>语句），JavaScript 引擎就立即把代码的执行，转到<code>catch</code>代码块，或者说错误被<code>catch</code>代码块捕获了。<code>catch</code>接受一个参数，表示<code>try</code>代码块抛出的值。</p>
<p>如果你不确定某些代码是否会报错，就可以把它们放在<code>try...catch</code>代码块之中，便于进一步对错误进行处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">f</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="comment">// 处理错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果函数<code>f</code>执行报错，就会进行<code>catch</code>代码块，接着对错误进行处理。</p>
<p><code>catch</code>代码块捕获错误之后，<strong>程序不会中断</strong>，会按照正常流程继续执行下去。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&quot;出错了&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>);</span><br><span class="line"><span class="comment">// 111</span></span><br><span class="line"><span class="comment">// 222</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>try</code>代码块抛出的错误，被<code>catch</code>代码块捕获后，程序会继续向下执行。</p>
<p><code>catch</code>代码块之中，还可以再抛出错误，甚至使用嵌套的<code>try...catch</code>结构。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> n;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e &lt;= <span class="number">50</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught 100</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>catch</code>代码之中又抛出了一个错误。</p>
<p>为了<strong>捕捉不同类型的错误</strong>，<code>catch</code>代码块之中可以加入判断语句。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  foo.<span class="title function_">bar</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e <span class="keyword">instanceof</span> <span class="title class_">EvalError</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">name</span> + <span class="string">&quot;: &quot;</span> + e.<span class="property">message</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> <span class="title class_">RangeError</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">name</span> + <span class="string">&quot;: &quot;</span> + e.<span class="property">message</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>catch</code>捕获错误之后，会判断错误类型（<code>EvalError</code>还是<code>RangeError</code>），进行不同的处理。</p>
<h3 id="6、finally-代码块（在try-catch最后，必执行的）"><a href="#6、finally-代码块（在try-catch最后，必执行的）" class="headerlink" title="6、finally 代码块（在try..catch最后，必执行的）"></a>6、finally 代码块（在try..catch最后，必执行的）</h3><p> <code>try...catch</code>结构允许在最后添加一个<code>finally</code>代码块，表示<strong>不管是否出现错误，都必需在最后运行的语句</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">cleansUp</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;出错了……&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;此行不会执行&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123; <span class="comment">// 不管有没有出错都会执行finally</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;完成清理工作&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;此行不会执行&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">cleansUp</span>()</span><br><span class="line"><span class="comment">// 完成清理工作</span></span><br><span class="line"><span class="comment">// Uncaught Error: 出错了……</span></span><br><span class="line"><span class="comment">//    at cleansUp (&lt;anonymous&gt;:3:11)</span></span><br><span class="line"><span class="comment">//    at &lt;anonymous&gt;:10:1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于没有catch语句，所以会打印出错误信息，并中断除finally以外的代码。</span></span><br><span class="line"><span class="comment">// 如果有catch语句则会执行catch内的代码块，而不会打印错误信息。且不会中断代码。</span></span><br></pre></td></tr></table></figure>

<p> 上面代码中，由于没有<code>catch</code>语句块，一旦发生错误，代码就会中断执行。中断执行之前，会先执行<code>finally</code>代码块，然后再向用户提示报错信息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">idle</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;result&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;FINALLY&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">idle</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// FINALLY</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>try</code>代码块没有发生错误，而且里面还包括<code>return</code>语句，但是<code>finally</code>代码块依然会执行。而且，这个函数的返回值还是<code>result</code>。</p>
<p>下面的例子说明，<code>return</code>语句的执行是排在<code>finally</code>代码之前，只是等<code>finally</code>代码执行完毕后才返回。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">countUp</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">countUp</span>()</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line">count</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码说明，<code>return</code>语句里面的<code>count</code>的值，是在<code>finally</code>代码块运行之前就获取了。</p>
<p>下面是<code>finally</code>代码块用法的<strong>典型场景</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">openFile</span>(); <span class="comment">// 打开文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">writeFile</span>(<span class="title class_">Data</span>); <span class="comment">// 写入文件</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="title function_">handleError</span>(e); <span class="comment">// 如果写入出错这处理错误</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="title function_">closeFile</span>();<span class="comment">// 不管是否出错都会执行关闭文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码首先打开一个文件，然后在<code>try</code>代码块中写入文件，如果没有发生错误，则运行<code>finally</code>代码块关闭文件；一旦发生错误，则先使用<code>catch</code>代码块处理错误，再使用<code>finally</code>代码块关闭文件。</p>
<p>下面的例子充分反映了<code>try...catch...finally</code>这三者之间的<strong>执行顺序</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;bug&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 这句原本会延迟到 finally 代码块结束再执行</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>); <span class="comment">// 不会运行</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 这句会覆盖掉前面那句 return</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>); <span class="comment">// 不会运行</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>); <span class="comment">// 不会运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">f</span>();</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">result</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>catch</code>代码块结束执行之前，会先执行<code>finally</code>代码块。</p>
<p><code>catch</code>代码块之中，触发转入<code>finally</code>代码块的标志，不仅有<code>return</code>语句，还有<code>throw</code>语句。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;出错了！&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕捉到内部错误&#x27;</span>);</span><br><span class="line">    <span class="keyword">throw</span> e; <span class="comment">// 这句原本会等到finally结束再执行</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 直接返回</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">f</span>(); <span class="comment">// 接收到返回值false，并没有接收到错误</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="comment">// 此处不会执行</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;caught outer &quot;bogus&quot;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  捕捉到内部错误</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，进入<code>catch</code>代码块之后，一遇到<code>throw</code>语句，就会去执行<code>finally</code>代码块，其中有<code>return false</code>语句，因此就直接返回了，不再会回去执行<code>catch</code>代码块剩下的部分了。</p>
<p><code>try</code>代码块内部，还可以再使用<code>try</code>代码块。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    consle.<span class="title function_">log</span>(<span class="string">&#x27;Hello world!&#x27;</span>); <span class="comment">// 报错，console拼错</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Finally&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Will I run?&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(error.<span class="property">message</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Finally</span></span><br><span class="line"><span class="comment">// consle is not defined</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>try</code>里面还有一个<code>try</code>。内层的<code>try</code>报错（<code>console</code>拼错了），这时会执行内层的<code>finally</code>代码块，然后抛出错误，被外层的<code>catch</code>捕获。</p>
<h2 id="四、console对象"><a href="#四、console对象" class="headerlink" title="四、console对象"></a>四、console对象</h2><h3 id="console-time-，console-timeEnd-（用于计算程序的用时）"><a href="#console-time-，console-timeEnd-（用于计算程序的用时）" class="headerlink" title="console.time()，console.timeEnd() （用于计算程序的用时）"></a>console.time()，console.timeEnd() （用于计算程序的用时）</h3><p>这两个方法用于计时，可以算出一个操作所花费的准确时间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.time(&#x27;Array initialize&#x27;);</span><br><span class="line"></span><br><span class="line">var array= new Array(1000000);</span><br><span class="line">for (var i = array.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">  array[i] = new Object();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.timeEnd(&#x27;Array initialize&#x27;);</span><br><span class="line">// Array initialize: 1914.481ms</span><br></pre></td></tr></table></figure>

<p><code>time</code>方法表示计时开始，<code>timeEnd</code>方法表示计时结束。它们的参数是计时器的名称。调用<code>timeEnd</code>方法之后，控制台会显示“计时器名称: 所耗费的时间”。</p>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>学习文档：<a href="https://wangdoc.com/javascript/">https://wangdoc.com/javascript/</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript面向对象编程</title>
    <url>/post/c263b14e4d89/</url>
    <content><![CDATA[<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="一、实例对象与new命令"><a href="#一、实例对象与new命令" class="headerlink" title="一、实例对象与new命令"></a>一、实例对象与new命令</h2><h3 id="1、对象是什么"><a href="#1、对象是什么" class="headerlink" title="1、对象是什么"></a>1、对象是什么</h3><p>面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。</p>
<p>每一个对象都是<strong>功能中心</strong>，具有明确分工，可以完成<strong>接受信息、处理数据、发出信息</strong>等任务。对象<strong>可以复用</strong>，通过继承机制还<strong>可以定制</strong>。因此，面向对象编程具有<strong>灵活、代码可复用、高度模块化</strong>等特点，容易维护和开发，比起由一系列函数或指令组成的传统的<strong>过程式编程</strong>（procedural programming），更适合多人合作的<strong>大型软件项目</strong>。</p>
<p>那么，“对象”（object）到底是什么？我们从两个层次来理解。</p>
<p><strong>（1）对象是单个实物的抽象。</strong></p>
<p>一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个与远程服务器的连接也可以是对象。当<strong>实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。</strong></p>
<p><strong>（2）对象是一个容器，封装了属性（property）和方法（method）。</strong></p>
<p><strong>属性</strong>是对象的状态，<strong>方法</strong>是对象的行为（完成某种任务）。比如，我们可以把动物抽象为<code>animal</code>对象，使用“属性”记录具体是那一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123; <span class="comment">// 对象</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="comment">// 属性</span></span><br><span class="line">    <span class="attr">interest</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">// 方法(行为)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;正在喝酒&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.<span class="title function_">interest</span>() <span class="comment">// 张三正在喝酒</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 真实世界： 有一个人，名字叫张三，他正在喝酒。</span></span><br><span class="line"><span class="comment">// 对象模拟： 一个人抽象为一个对象person，对象是一个容器，内部封装了属性name叫张三，他正在喝酒封装成方法interest</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2、构造函数"><a href="#2、构造函数" class="headerlink" title="2、构造函数"></a>2、构造函数</h3><p>面向对象编程的第一步，就是要生成对象。前面说过，对象是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成。</p>
<p>典型的面向对象编程语言（比如 C++ 和 Java），都有“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是，JavaScript 语言的对象体系，不是基于“类”的，而是<strong>基于构造函数（constructor）和原型链（prototype）</strong>。</p>
<p>JavaScript 语言<strong>使用构造函数（constructor）作为对象的模板</strong>。</p>
<p><strong>所谓”构造函数”，就是专门用来生成实例对象的函数</strong>。</p>
<p>它就是对象的模板，描述实例对象的基本结构。</p>
<p>一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。</p>
<p>构造函数就是一个普通的函数，但是有自己的特征和用法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Vehicle</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">price</span> = <span class="number">1000</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Vehicle</code>就是构造函数。为了与普通函数区别，构造函数名字的第一个字母通常大写。</p>
<p>构造函数的特点有两个。</p>
<ul>
<li>函数体内部使用了<code>this</code>关键字，代表了所要生成的对象实例。</li>
<li>生成对象的时候，必须使用<code>new</code>命令。</li>
</ul>
<p>下面先介绍<code>new</code>命令。</p>
<h3 id="3、new命令"><a href="#3、new命令" class="headerlink" title="3、new命令"></a>3、new命令</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p> <code>new</code>命令的作用：<strong>执行构造函数，返回一个实例对象</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Vehicle</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">price</span> = <span class="number">1000</span>; <span class="comment">// this指向实例对象v</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> <span class="title class_">Vehicle</span>();  <span class="comment">// new 执行一个构造函数，返回一个实例对象给v</span></span><br><span class="line">v.<span class="property">price</span> <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure>

<p>上面代码通过<code>new</code>命令，让构造函数<code>Vehicle</code>生成一个实例对象，保存在变量<code>v</code>中。这个新生成的实例对象，从构造函数<code>Vehicle</code>得到了<code>price</code>属性。<code>new</code>命令执行时，构造函数内部的<code>this</code>，就代表了新生成的实例对象，<code>this.price</code>表示实例对象有一个<code>price</code>属性，值是1000。</p>
<p> 使用<code>new</code>命令时，根据需要，<strong>构造函数也可以接受参数</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Vehicle</span> = <span class="keyword">function</span> (<span class="params">p</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">price</span> = p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> <span class="title class_">Vehicle</span>(<span class="number">500</span>); <span class="comment">// new 命令时，构造函数可以接受参数</span></span><br></pre></td></tr></table></figure>

<p><code>new</code>命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也<strong>可以不带括号</strong>。下面两行代码是等价的，但是为了表示这里是函数调用，<strong>推荐使用括号</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 推荐的写法</span></span><br><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> <span class="title class_">Vehicle</span>();</span><br><span class="line"><span class="comment">// 不推荐的写法</span></span><br><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> <span class="title class_">Vehicle</span>;</span><br></pre></td></tr></table></figure>

<p>一个很自然的问题是，如果忘了使用<code>new</code>命令，直接调用构造函数会发生什么事？</p>
<p>这种情况下，构造函数就变成了普通函数，并不会生成实例对象。而且由于后面会说到的原因，<code>this</code>这时代表全局对象，将造成一些意想不到的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Vehicle</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">price</span> = <span class="number">1000</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v = <span class="title class_">Vehicle</span>(); <span class="comment">// 忘记使用new命令，构造函数变成普通函数，不会生成实例，函数内部this指向window</span></span><br><span class="line">v <span class="comment">// undefined   函数为普通函数且没有返回值，所有v为undefined</span></span><br><span class="line">price <span class="comment">// 1000  函数内部this指向window， price变成全局属性，等价于window.price</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，调用<code>Vehicle</code>构造函数时，忘了加上<code>new</code>命令。结果，变量<code>v</code>变成了<code>undefined</code>，而<code>price</code>属性变成了全局变量。因此，应该非常小心，避免不使用<code>new</code>命令、直接调用构造函数。</p>
<p>为了保证构造函数必须与<code>new</code>命令一起使用，一个解决办法是，<strong>构造函数内部使用严格模式</strong>，即第一行加上<code>use strict</code>。这样的话，一旦忘了使用<code>new</code>命令，直接调用构造函数就会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fubar</span>(<span class="params">foo, bar</span>)&#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_foo</span> = foo; <span class="comment">// 严格模式中this不能指向window对象，不加new调用this等于undefined，给undefined添加属性会报错</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_bar</span> = bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Fubar</span>()</span><br><span class="line"><span class="comment">// TypeError: Cannot set property &#x27;_foo&#x27; of undefined</span></span><br></pre></td></tr></table></figure>

<p> 上面代码的<code>Fubar</code>为构造函数，<code>use strict</code>命令保证了该函数在严格模式下运行。由于<strong>严格模式中，函数内部的<code>this</code>不能指向全局对象</strong>，默认等于<code>undefined</code>，导致不加<code>new</code>调用会报错（JavaScript 不允许对<code>undefined</code>添加属性）。</p>
<p> <strong>另一个解决办法</strong>，构造函数内部判断是否使用<code>new</code>命令，如果发现没有使用，则直接返回一个实例对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fubar</span>(<span class="params">foo, bar</span>) &#123;</span><br><span class="line">  <span class="comment">// instanceof运算符用于检测构造函数的prototype属性是否出现在某个实例对象的原型链（），返回布尔值。</span></span><br><span class="line">  <span class="comment">// 语法： &lt;实例对象&gt; instanceof &lt;构造函数&gt;</span></span><br><span class="line">  <span class="keyword">if</span> (!(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Fubar</span>)) &#123;  <span class="comment">// 或 使用 (!new.target) 判断是否使用new命令</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fubar</span>(foo, bar);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_foo</span> = foo;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_bar</span> = bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Fubar</span>(<span class="number">1</span>, <span class="number">2</span>).<span class="property">_foo</span> <span class="comment">// 1</span></span><br><span class="line">(<span class="keyword">new</span> <span class="title class_">Fubar</span>(<span class="number">1</span>, <span class="number">2</span>)).<span class="property">_foo</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中的构造函数，不管加不加<code>new</code>命令，都会得到同样的结果。</p>
<h4 id="new-命令的原理"><a href="#new-命令的原理" class="headerlink" title="new 命令的原理"></a>new 命令的原理</h4><p>使用<code>new</code>命令时，它后面的函数依次执行下面的步骤。</p>
<ol>
<li><p>创建一个空对象，作为将要返回的实例对象。</p>
</li>
<li><p>将这个空对象的原型，指向构造函数的<code>prototype</code>属性。</p>
</li>
<li><p>将这个空对象赋值给函数内部的<code>this</code>关键字。</p>
</li>
<li><p>开始执行构造函数内部的代码。（代码中this指向空对象（实例对象））</p>
</li>
<li><p>返回实例对象（或自定义对象）</p>
</li>
</ol>
<p>也就是说，构造函数内部，<code>this</code>指的是一个新生成的空对象，<strong>所有针对<code>this</code>的操作，都会发生在这个空对象上</strong>。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即<code>this</code>对象），将其“构造”为需要的样子。</p>
<p>如果构造函数内部有<code>return</code>语句，而且<code>return</code>后面跟着一个对象，<code>new</code>命令会返回<code>return</code>语句指定的对象；否则，就会不管<code>return</code>语句，返回<code>this</code>对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Vehicle</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">price</span> = <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1000</span>; <span class="comment">// 1000 非对象，被忽略，返回的是this对象；如果是return &#123;&#125;，则会返回&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> <span class="title class_">Vehicle</span>()) === <span class="number">1000</span></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，构造函数<code>Vehicle</code>的<code>return</code>语句返回一个数值。这时，<code>new</code>命令就会忽略这个<code>return</code>语句，返回“构造”后的<code>this</code>对象。</p>
<p>但是，如果<code>return</code>语句返回的是一个跟<code>this</code>无关的新对象，<code>new</code>命令会返回这个新对象，而不是<code>this</code>对象。这一点需要特别引起注意。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Vehicle</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">price</span> = <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">price</span>: <span class="number">2000</span> &#125;; <span class="comment">// return的是一个对象，会被返回出去。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> <span class="title class_">Vehicle</span>()).<span class="property">price</span></span><br><span class="line"><span class="comment">// 2000</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，构造函数<code>Vehicle</code>的<code>return</code>语句，返回的是一个新对象。<code>new</code>命令会返回这个对象，而不是<code>this</code>对象。</p>
<p>另一方面，如果对普通函数（内部没有<code>this</code>关键字的函数）使用<code>new</code>命令，则会返回一个空对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getMessage</span>(<span class="params"></span>) &#123; <span class="comment">// 内部沒有this关键字，会返回一个空对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;this is a message&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> msg = <span class="keyword">new</span> <span class="title function_">getMessage</span>();</span><br><span class="line"></span><br><span class="line">msg <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="keyword">typeof</span> msg <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>

<p> 上面代码中，<code>getMessage</code>是一个普通函数，返回一个字符串。对它使用<code>new</code>命令，会得到一个空对象。这是因为**<code>new</code>命令总是返回一个对象，要么是实例对象，要么是<code>return</code>语句指定的对象**。本例中，<code>return</code>语句返回的是字符串，所以<code>new</code>命令就忽略了该语句。</p>
<p><code>new</code>命令简化的内部流程，可以用下面的代码表示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name,age</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new的原理：自定义_new</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_new</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 将 arguments 对象转为数组</span></span><br><span class="line">  <span class="keyword">var</span> args = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="comment">// 取出构造函数</span></span><br><span class="line">  <span class="keyword">var</span> constructor = args.<span class="title function_">shift</span>();</span><br><span class="line">  <span class="comment">// 创建一个空对象，继承构造函数的 prototype 属性</span></span><br><span class="line">  <span class="keyword">var</span> context = <span class="title class_">Object</span>.<span class="title function_">create</span>(constructor.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  <span class="comment">// 执行构造函数</span></span><br><span class="line">  <span class="keyword">var</span> result = constructor.<span class="title function_">apply</span>(context, args);</span><br><span class="line">  <span class="comment">// 如果返回结果是对象，就直接返回，否则返回 context 对象</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span> &amp;&amp; result != <span class="literal">null</span>) ? result : context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义_new2</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_new2</span>(<span class="params"><span class="comment">/* 构造函数 */</span> constructor, <span class="comment">/* 构造函数参数 */</span> params</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建一个空对象，继承构造函数的 prototype 属性</span></span><br><span class="line">  <span class="keyword">var</span> context = <span class="title class_">Object</span>.<span class="title function_">create</span>(constructor.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  <span class="comment">// 执行构造函数</span></span><br><span class="line">  <span class="keyword">var</span> result = constructor.<span class="title function_">apply</span>(context, params);</span><br><span class="line">  <span class="comment">// 如果返回结果是对象，就直接返回，否则返回 context 对象</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span> &amp;&amp; result != <span class="literal">null</span>) ? result : context;</span><br><span class="line">  <span class="comment">// （当用户在构造函数内部自定义返回对象的话则使用该对象，否则返回context）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过自定义_new 返回实例</span></span><br><span class="line"><span class="keyword">var</span> actor = <span class="title function_">_new</span>(<span class="title class_">Person</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="number">28</span>);</span><br><span class="line">actor.<span class="property">name</span> <span class="comment">// 张三</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过自定义_new2 返回实例</span></span><br><span class="line"><span class="keyword">var</span> actor2 = <span class="title function_">_new2</span>(<span class="title class_">Person</span>, [<span class="string">&#x27;李四&#x27;</span>, <span class="number">29</span>]);</span><br><span class="line">actor2.<span class="property">name</span> <span class="comment">// 李四</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过new命令 返回实例</span></span><br><span class="line"><span class="keyword">var</span> actor3 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;王五&#x27;</span>,<span class="number">30</span>)</span><br><span class="line">actor3.<span class="property">name</span> <span class="comment">// 王五</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="new-target-属性"><a href="#new-target-属性" class="headerlink" title="new.target 属性"></a>new.target 属性</h4><p>构造函数内部可以使用<code>new.target</code>属性。如果当前函数是<code>new</code>命令调用，<code>new.target</code><strong>指向当前函数</strong>，否则为<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span> === f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// false</span></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">f</span>() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>使用这个属性，可以<strong>判断函数调用的时候，是否使用<code>new</code>命令</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">new</span>.<span class="property">target</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请使用 new 命令调用！&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// Uncaught Error: 请使用 new 命令调用！</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，构造函数<code>f</code>调用时，没有使用<code>new</code>命令，就抛出一个错误。</p>
<h3 id="4、Object-create-创建实例对象"><a href="#4、Object-create-创建实例对象" class="headerlink" title="4、Object.create()创建实例对象"></a>4、Object.create()创建实例对象</h3><p>构造函数作为模板，可以生成实例对象。但是，有时拿不到构造函数，只能拿到一个现有的对象。我们希望以这个现有的对象作为模板，生成新的实例对象，这时就可以使用<code>Object.create()</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个例子没有构造函数，只有一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = &#123; <span class="comment">// 这个对象用来生成实例对象，它被当成一个模板</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">38</span>,</span><br><span class="line">  <span class="attr">greeting</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi! I\&#x27;m &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(person1);</span><br><span class="line"></span><br><span class="line">person2.<span class="property">name</span> <span class="comment">// 张三</span></span><br><span class="line">person2.<span class="title function_">greeting</span>() <span class="comment">// Hi! I&#x27;m 张三.</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>person1</code>是<code>person2</code>的模板，后者继承了前者的属性和方法。</p>
<p><code>Object.create()</code>的详细介绍，请看后面的相关章节。</p>
<h2 id="二、this关键字"><a href="#二、this关键字" class="headerlink" title="二、this关键字"></a>二、this关键字</h2><h3 id="1、涵义"><a href="#1、涵义" class="headerlink" title="1、涵义"></a>1、涵义</h3><p><code>this</code>关键字是一个非常重要的语法点。毫不夸张地说，不理解它的含义，大部分开发任务都无法完成。</p>
<p>前一章已经提到，<code>this</code>可以用在构造函数之中，表示实例对象。除此之外，<code>this</code>还可以用在别的场合。但不管是什么场合，<code>this</code>都有一个共同点：<strong>它总是返回一个对象</strong>。</p>
<p>简单说，**<code>this</code>就是属性或方法“当前”所在的对象**。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">property</span> <span class="comment">// this代表property属性当前所在的对象</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>this</code>就代表<code>property</code>属性当前所在的对象。</p>
<p>下面是一个实际的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="attr">describe</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;姓名：&#x27;</span>+ <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">describe</span>()</span><br><span class="line"><span class="comment">// &quot;姓名：张三&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>this.name</code>表示<code>name</code>属性所在的那个对象。由于<code>this.name</code>是在<code>describe</code>方法中调用，而<code>describe</code>方法所在的当前对象是<code>person</code>，因此<code>this</code>指向<code>person</code>，<code>this.name</code>就是<code>person.name</code>。</p>
<p>由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，即<code>this</code><strong>的指向是可变的</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="attr">describe</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;姓名：&#x27;</span>+ <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> B = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;李四&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">B.<span class="property">describe</span> = A.<span class="property">describe</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 此时B的值：</span></span><br><span class="line"><span class="comment">B=&#123;</span></span><br><span class="line"><span class="comment">	name: &#x27;李四&#x27;,</span></span><br><span class="line"><span class="comment">    describe: function () &#123;</span></span><br><span class="line"><span class="comment">        return &#x27;姓名：&#x27;+ this.name;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">B.<span class="title function_">describe</span>() <span class="comment">// B内部的this指向B对象</span></span><br><span class="line"><span class="comment">// &quot;姓名：李四&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>A.describe</code>属性被赋给<code>B</code>，于是<code>B.describe</code>就表示<code>describe</code>方法所在的当前对象是<code>B</code>，所以<code>this.name</code>就指向<code>B.name</code>。</p>
<p>稍稍重构这个例子，<code>this</code>的动态指向就能看得更清楚。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;姓名：&#x27;</span>+ <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="attr">describe</span>: f</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> B = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;李四&#x27;</span>,</span><br><span class="line">  <span class="attr">describe</span>: f</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A.<span class="title function_">describe</span>() <span class="comment">// &quot;姓名：张三&quot;</span></span><br><span class="line">B.<span class="title function_">describe</span>() <span class="comment">// &quot;姓名：李四&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>f</code>内部使用了<code>this</code>关键字，随着<code>f</code>所在的对象不同，<code>this</code>的指向也不同。</p>
<p>只要函数被赋给另一个变量，<code>this</code>的指向就会变。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="attr">describe</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;姓名：&#x27;</span>+ <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> f = A.<span class="property">describe</span>;</span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// &quot;姓名：李四&quot; f函数中的this和name变量所在的对象都为window顶层对象</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>A.describe</code>被赋值给变量<code>f</code>，内部的<code>this</code>就会指向<code>f</code>运行时所在的对象（本例是顶层对象）。</p>
<p>再看一个网页编程的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;age&quot;</span> size=<span class="number">3</span> onChange=<span class="string">&quot;validate(this, 18, 99);&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">function</span> <span class="title function_">validate</span>(<span class="params">obj, lowval, hival</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">if</span> ((obj.<span class="property">value</span> &lt; lowval) || (obj.<span class="property">value</span> &gt; hival))</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Invalid Value!&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>上面代码是一个文本输入框，每当用户输入一个值，就会调用<code>onChange</code>回调函数，验证这个值是否在指定范围。浏览器会向回调函数传入当前对象，因此<code>this</code>就代表传入当前对象（即文本框），然后就可以从<code>this.value</code>上面读到用户的输入值。</p>
<p> 总结一下，<strong>JavaScript 语言之中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，<code>this</code>就是函数运行时所在的对象（环境）</strong>。这本来并不会让用户糊涂，但是 JavaScript 支持运行环境动态切换，也就是说，<code>this</code>的指向是动态的，没有办法事先确定到底指向哪个对象，这才是最让初学者感到困惑的地方。</p>
<h3 id="2、实质"><a href="#2、实质" class="headerlink" title="2、实质"></a>2、实质</h3><p>JavaScript 语言之所以有 this 的设计，跟内存里面的数据结构有关系。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>:  <span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面的代码将一个对象赋值给变量<code>obj</code>。JavaScript 引擎会先在内存里面，生成一个对象<code>&#123; foo: 5 &#125;</code>，然后把这个对象的内存地址赋值给变量<code>obj</code>。也就是说，变量<code>obj</code>是一个地址（reference）。后面如果要读取<code>obj.foo</code>，引擎先从<code>obj</code>拿到内存地址，然后再从该地址读出原始的对象，返回它的<code>foo</code>属性。</p>
<p>原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的<code>foo</code>属性，实际上是以下面的形式保存的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">foo</span>: &#123;</span><br><span class="line">    [[value]]: <span class="number">5</span></span><br><span class="line">    [[writable]]: <span class="literal">true</span></span><br><span class="line">    [[enumerable]]: <span class="literal">true</span></span><br><span class="line">    [[configurable]]: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，<code>foo</code>属性的值保存在属性描述对象的<code>value</code>属性里面。</p>
<p> 这样的结构是很清晰的，问题在于属性的值可能是一个函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125; &#125;;</span><br></pre></td></tr></table></figure>

<p>这时，<strong>引擎会将函数单独保存在内存中</strong>，然后再将函数的地址赋值给<code>foo</code>属性的<code>value</code>属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">foo</span>: &#123;</span><br><span class="line">    [[value]]: 函数的地址</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">f</span>: f &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单独执行</span></span><br><span class="line"><span class="title function_">f</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj 环境执行</span></span><br><span class="line">obj.<span class="title function_">f</span>()</span><br></pre></td></tr></table></figure>

<p>JavaScript 允许在函数体内部，引用当前环境的其他变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数体里面使用了变量<code>x</code>。该变量由运行环境提供。</p>
<p>现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，<code>this</code>就出现了，<strong>它的设计目的就是在函数体内部，指代函数当前的运行环境</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数体里面的<code>this.x</code>就是指当前运行环境的<code>x</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">f</span>: f,</span><br><span class="line">  <span class="attr">x</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单独执行</span></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// 1  f方法当前运行环境为window对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// obj 环境执行</span></span><br><span class="line">obj.<span class="title function_">f</span>() <span class="comment">// 2 f方法当前运行环境为obj对象</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>f</code>在全局环境执行，<code>this.x</code>指向全局环境的<code>x</code>；在<code>obj</code>环境执行，<code>this.x</code>指向<code>obj.x</code>。</p>
<h3 id="3、使用场合"><a href="#3、使用场合" class="headerlink" title="3、使用场合"></a>3、使用场合</h3><p> <code>this</code>主要有以下几个使用场合。</p>
<h4 id="（1）全局环境"><a href="#（1）全局环境" class="headerlink" title="（1）全局环境"></a>（1）全局环境</h4><p>全局环境使用<code>this</code>，它指的就是顶层对象<code>window</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span> === <span class="variable language_">window</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="variable language_">window</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码说明，不管是不是在函数内部，只要是在全局环境下运行，<code>this</code>就是指顶层对象<code>window</code>。</p>
<h4 id="（2）构造函数"><a href="#（2）构造函数" class="headerlink" title="（2）构造函数"></a>（2）构造函数</h4><p>构造函数中的<code>this</code>，指的是实例对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Obj</span> = <span class="keyword">function</span> (<span class="params">p</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">p</span> = p; <span class="comment">// this指向实例对象，在实例对象上定义属性p等于p值</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Obj</span>(<span class="string">&#x27;Hello World!&#x27;</span>); <span class="comment">// 通过new构造函数来声明实例对象o</span></span><br><span class="line">o.<span class="property">p</span> <span class="comment">// &quot;Hello World!&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码定义了一个构造函数<code>Obj</code>。由于<code>this</code>指向实例对象，所以在构造函数内部定义<code>this.p</code>，就相当于定义实例对象有一个<code>p</code>属性。</p>
<h4 id="（3）对象的方法"><a href="#（3）对象的方法" class="headerlink" title="（3）对象的方法"></a>（3）对象的方法</h4><p>如果对象的方法里面包含<code>this</code>，<code>this</code>的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变<code>this</code>的指向。</p>
<p>但是，这条规则很不容易把握。请看下面的代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj =&#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">foo</span>() <span class="comment">// obj</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>obj.foo</code>方法执行时，它内部的<code>this</code>指向<code>obj</code>。</p>
<p>但是，下面这几种用法，都会改变<code>this</code>的指向。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line">(obj.<span class="property">foo</span> = obj.<span class="property">foo</span>)() <span class="comment">// window</span></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line">(<span class="literal">false</span> || obj.<span class="property">foo</span>)() <span class="comment">// window</span></span><br><span class="line"><span class="comment">// 情况三</span></span><br><span class="line">(<span class="number">1</span>, obj.<span class="property">foo</span>)() <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//obj.foo 是一个内存地址，它直接取出了 function () &#123;console.log(this);&#125; ，可以把obj.foo看做function () &#123;console.log(this);&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>obj.foo</code>就是一个值。这个值真正调用的时候，运行环境已经不是<code>obj</code>了，而是全局环境，所以<code>this</code>不再指向<code>obj</code>。</p>
<p>可以这样理解，JavaScript 引擎内部，**<code>obj</code>和<code>obj.foo</code>储存在两个内存地址<strong>，称为地址一和地址二。<code>obj.foo()</code>这样调用时，是从地址一调用地址二，因此地址二的运行环境是地址一，<code>this</code>指向<code>obj</code>。但是，</strong>上面三种情况，都是直接取出地址二进行调用，这样的话，运行环境就是全局环境，因此<code>this</code>指向全局环境**。上面三种情况等同于下面的代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//obj.foo 是一个内存地址，它直接取出了 function () &#123;console.log(this);&#125; ，可以把obj.foo看做function () &#123;console.log(this);&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况一</span></span><br><span class="line">(obj.<span class="property">foo</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line">(<span class="literal">false</span> || <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况三</span></span><br><span class="line">(<span class="number">1</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>如果<code>this</code>所在的方法不在对象的第一层，这时<code>this</code>只是指向当前一层的对象，而不会继承更上面的层。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  <span class="attr">p</span>: <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">  <span class="attr">b</span>: &#123;</span><br><span class="line">    <span class="attr">m</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">p</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.<span class="property">b</span>.<span class="title function_">m</span>() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>a.b.m</code>方法在<code>a</code>对象的第二层，该方法内部的<code>this</code>不是指向<code>a</code>，而是指向<code>a.b</code>，因为实际执行的是下面的代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line">  <span class="attr">m</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">p</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  <span class="attr">p</span>: <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">  <span class="attr">b</span>: b</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(a.<span class="property">b</span>).<span class="title function_">m</span>() <span class="comment">// 等同于 b.m()</span></span><br></pre></td></tr></table></figure>

<p>如果要达到预期效果，只有写成下面这样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  <span class="attr">b</span>: &#123;</span><br><span class="line">    <span class="attr">m</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">p</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">p</span>: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果这时将嵌套对象内部的方法赋值给一个变量，<code>this</code>依然会指向全局对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  <span class="attr">b</span>: &#123;</span><br><span class="line">    <span class="attr">m</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">p</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">p</span>: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hello = a.<span class="property">b</span>.<span class="property">m</span>; <span class="comment">// 把方法的内存地址赋值给了hello</span></span><br><span class="line"><span class="title function_">hello</span>() <span class="comment">// undefined  内部this指向window</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>m</code>是多层对象内部的一个方法。为求简便，将其赋值给<code>hello</code>变量，结果调用时，<code>this</code>指向了顶层对象。为了避免这个问题，可以只将<code>m</code>所在的对象赋值给<code>hello</code>，这样调用时，<code>this</code>的指向就不会变。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = a.<span class="property">b</span>;</span><br><span class="line">hello.<span class="title function_">m</span>() <span class="comment">// Hello   this指向不变</span></span><br></pre></td></tr></table></figure>

<h3 id="4、使用注意点"><a href="#4、使用注意点" class="headerlink" title="4、使用注意点"></a>4、使用注意点</h3><h4 id="（1）避免多层-this"><a href="#（1）避免多层-this" class="headerlink" title="（1）避免多层 this"></a>（1）避免多层 this</h4><p> 由于<code>this</code>的指向是不确定的，所以切勿在函数中包含多层的<code>this</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="attr">f1</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// this指向o对象</span></span><br><span class="line">    <span class="keyword">var</span> f2 = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 方法会另起一个内存地址</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// this指向window对象</span></span><br><span class="line">    &#125;();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.<span class="title function_">f1</span>()</span><br><span class="line"><span class="comment">// Object</span></span><br><span class="line"><span class="comment">// Window</span></span><br></pre></td></tr></table></figure>

<p>上面代码包含两层<code>this</code>，结果运行后，第一层指向对象<code>o</code>，第二层指向全局对象，因为实际执行的是下面的代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> temp = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="attr">f1</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="keyword">var</span> f2 = <span class="title function_">temp</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个解决方法是在第二层改用一个指向外层<code>this</code>的变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="attr">f1</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="keyword">var</span> that = <span class="variable language_">this</span>; <span class="comment">// 使用变量保存this</span></span><br><span class="line">    <span class="keyword">var</span> f2 = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(that);</span><br><span class="line">    &#125;();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.<span class="title function_">f1</span>()</span><br><span class="line"><span class="comment">// Object</span></span><br><span class="line"><span class="comment">// Object</span></span><br></pre></td></tr></table></figure>

<p>上面代码定义了变量<code>that</code>，固定指向外层的<code>this</code>，然后在内层使用<code>that</code>，就不会发生<code>this</code>指向的改变。</p>
<p>事实上，使用一个变量固定<code>this</code>的值，然后内层函数调用这个变量，是非常常见的做法，请务必掌握。</p>
<p>JavaScript 提供了严格模式，也可以硬性避免这种问题。严格模式下，如果函数内部的<code>this</code>指向顶层对象，就会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line">counter.<span class="property">inc</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">count</span>++</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> f = counter.<span class="property">inc</span>; <span class="comment">// 这里直接取出方法的内存地址赋值给f，运行环境为window</span></span><br><span class="line"><span class="title function_">f</span>()</span><br><span class="line"><span class="comment">// TypeError: Cannot read property &#x27;count&#x27; of undefined</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>inc</code>方法通过<code>&#39;use strict&#39;</code>声明采用严格模式，这时内部的<code>this</code>一旦指向顶层对象，就会报错。</p>
<h4 id="（2）避免数组处理方法中的-this"><a href="#（2）避免数组处理方法中的-this" class="headerlink" title="（2）避免数组处理方法中的 this"></a>（2）避免数组处理方法中的 this</h4><p> 数组的<code>map</code>和<code>foreach</code>方法，允许提供一个函数作为参数。这个函数内部不应该使用<code>this</code> 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="attr">v</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="attr">p</span>: [ <span class="string">&#x27;a1&#x27;</span>, <span class="string">&#x27;a2&#x27;</span> ],</span><br><span class="line">  <span class="attr">f</span>: <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">p</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123; <span class="comment">// 这个方法的运行环境为window</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">v</span> + <span class="string">&#x27; &#x27;</span> + item);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.<span class="title function_">f</span>()</span><br><span class="line"><span class="comment">// undefined a1</span></span><br><span class="line"><span class="comment">// undefined a2</span></span><br></pre></td></tr></table></figure>

<p> 上面代码中，<code>foreach</code>方法的回调函数中的<code>this</code>，其实是指向<code>window</code>对象，因此取不到<code>o.v</code>的值。原因跟上一段的多层<code>this</code>是一样的，就是内层的<code>this</code>不指向外部，而指向顶层对象。</p>
<p>解决这个问题的一种方法，就是前面提到的，使用中间变量固定<code>this</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="attr">v</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="attr">p</span>: [ <span class="string">&#x27;a1&#x27;</span>, <span class="string">&#x27;a2&#x27;</span> ],</span><br><span class="line">  <span class="attr">f</span>: <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">p</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(that.<span class="property">v</span>+<span class="string">&#x27; &#x27;</span>+item);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.<span class="title function_">f</span>()</span><br><span class="line"><span class="comment">// hello a1</span></span><br><span class="line"><span class="comment">// hello a2</span></span><br></pre></td></tr></table></figure>

<p>另一种方法是将<code>this</code>当作<code>foreach</code>方法的第二个参数，固定它的运行环境。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="attr">v</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="attr">p</span>: [ <span class="string">&#x27;a1&#x27;</span>, <span class="string">&#x27;a2&#x27;</span> ],</span><br><span class="line">  <span class="attr">f</span>: <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">p</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">v</span> + <span class="string">&#x27; &#x27;</span> + item);</span><br><span class="line">    &#125;, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.<span class="title function_">f</span>()</span><br><span class="line"><span class="comment">// hello a1</span></span><br><span class="line"><span class="comment">// hello a2</span></span><br></pre></td></tr></table></figure>

<p>ES6箭头函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="attr">v</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="attr">p</span>: [ <span class="string">&#x27;a1&#x27;</span>, <span class="string">&#x27;a2&#x27;</span> ],</span><br><span class="line">  <span class="attr">f</span>: <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">p</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123; <span class="comment">// 箭头函数使this指向为o对象</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">v</span>+<span class="string">&#x27; &#x27;</span>+item);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.<span class="title function_">f</span>()</span><br><span class="line"><span class="comment">// hello a1</span></span><br><span class="line"><span class="comment">// hello a2</span></span><br></pre></td></tr></table></figure>



<h4 id="（3）避免回调函数中的-this"><a href="#（3）避免回调函数中的-this" class="headerlink" title="（3）避免回调函数中的 this"></a>（3）避免回调函数中的 this</h4><p>回调函数中的<code>this</code>往往会改变指向，最好避免使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">o.<span class="property">f</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jQuery 的写法</span></span><br><span class="line">$(<span class="string">&#x27;#button&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, o.<span class="property">f</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，点击按钮以后，控制台会显示<code>false</code>。原因是此时<code>this</code>不再指向<code>o</code>对象，而是指向按钮的 DOM 对象，因为<code>f</code>方法是在按钮对象的环境中被调用的。这种细微的差别，很容易在编程中忽视，导致难以察觉的错误。</p>
<p>为了解决这个问题，可以采用下面的一些方法对<code>this</code>进行绑定，也就是使得<code>this</code>固定指向某个对象，减少不确定性。</p>
<h3 id="5、绑定-this-的方法"><a href="#5、绑定-this-的方法" class="headerlink" title="5、绑定 this 的方法"></a>5、绑定 this 的方法</h3><p> <code>this</code>的动态切换，固然为 JavaScript 创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把<code>this</code>固定下来，避免出现意想不到的情况。JavaScript 提供了<code>call</code>、<code>apply</code>、<code>bind</code>这三个方法，来切换&#x2F;固定<code>this</code>的指向。</p>
<h4 id="Function-prototype-call"><a href="#Function-prototype-call" class="headerlink" title="Function.prototype.call()"></a>Function.prototype.call()</h4><p>函数实例的<code>call</code>方法，可以<strong>指定函数内部<code>this</code>的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() === <span class="variable language_">window</span> <span class="comment">// true</span></span><br><span class="line">f.<span class="title function_">call</span>(obj) === obj <span class="comment">// true 使函数内this指向obj，相当于把函数放入obj对象内运行。</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，全局环境运行函数<code>f</code>时，<code>this</code>指向全局环境（浏览器为<code>window</code>对象）；<code>call</code>方法可以改变<code>this</code>的指向，指定<code>this</code>指向对象<code>obj</code>，然后在对象<code>obj</code>的作用域中运行函数<code>f</code>。</p>
<p><strong><code>call</code>方法的参数，应该是一个对象</strong>。如果参数为空、<code>null</code>和<code>undefined</code>，则<strong>默认传入全局对象</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">n</span>: <span class="number">456</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">n</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数为空、null、undefined时默认传入全局对象</span></span><br><span class="line">a.<span class="title function_">call</span>() <span class="comment">// 123</span></span><br><span class="line">a.<span class="title function_">call</span>(<span class="literal">null</span>) <span class="comment">// 123</span></span><br><span class="line">a.<span class="title function_">call</span>(<span class="literal">undefined</span>) <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">a.<span class="title function_">call</span>(<span class="variable language_">window</span>) <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">a.<span class="title function_">call</span>(obj) <span class="comment">// 456</span></span><br></pre></td></tr></table></figure>

<p> 上面代码中，<code>a</code>函数中的<code>this</code>关键字，如果指向全局对象，返回结果为<code>123</code>。如果使用<code>call</code>方法将<code>this</code>关键字指向<code>obj</code>对象，返回结果为<code>456</code>。可以看到，如果<code>call</code>方法没有参数，或者参数为<code>null</code>或<code>undefined</code>，则等同于指向全局对象。</p>
<p>如果<code>call</code>方法的参数是一个原始值，那么这个<strong>原始值会自动转成对应的包装对象</strong>，然后传入<code>call</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">f.<span class="title function_">call</span>(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// Number &#123;[[PrimitiveValue]]: 5&#125; // Number的实例对象</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>call</code>的参数为<code>5</code>，不是对象，会被自动转成包装对象（<code>Number</code>的实例），绑定<code>f</code>内部的<code>this</code>。</p>
<p><code>call</code>方法还可以接受多个参数。</p>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">func.<span class="title function_">call</span>(thisValue, arg1, arg2, ...)</span><br><span class="line"><span class="comment">// 第一个参数thisValue为函数内this将要指向的对象</span></span><br><span class="line"><span class="comment">// 其余参数为传入函数的参数</span></span><br></pre></td></tr></table></figure>

<p><code>call</code>的第一个参数就是<code>this</code>所要指向的那个对象，后面的参数则是函数调用时所需的参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add.<span class="title function_">call</span>(<span class="variable language_">this</span>, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>call</code>方法指定函数<code>add</code>内部的<code>this</code>绑定当前环境（对象），并且参数为<code>1</code>和<code>2</code>，因此函数<code>add</code>运行后得到<code>3</code>。</p>
<h5 id="应用：调用对象的原生方法"><a href="#应用：调用对象的原生方法" class="headerlink" title="应用：调用对象的原生方法"></a>应用：调用对象的原生方法</h5><p> <code>call</code>方法的一个应用是调用对象的原生方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;toString&#x27;</span>) <span class="comment">// false 判断obj是否有toString属性，注意这里不是toString()方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖掉继承的 hasOwnProperty 方法</span></span><br><span class="line">obj.<span class="property">hasOwnProperty</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;toString&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(obj, <span class="string">&#x27;toString&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>hasOwnProperty</code>是<code>obj</code>对象继承的方法，如果这个方法一旦被覆盖，就不会得到正确结果。<code>call</code>方法可以解决这个问题，它将<code>hasOwnProperty</code>方法的原始定义放到<code>obj</code>对象上执行，这样无论<code>obj</code>上有没有同名方法，都不会影响结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> objArr = &#123; <span class="comment">// 类数组对象</span></span><br><span class="line">    <span class="number">0</span>:<span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="number">1</span>:<span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="number">2</span>:<span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="attr">length</span>:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(objArr) <span class="comment">// 执行数组的slice方法，并把obj指定为方法的this</span></span><br><span class="line"><span class="comment">// 或 arr = [].slice.call(obj)</span></span><br><span class="line"></span><br><span class="line">arr <span class="comment">// [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>objArr</code>是一个类似数组的对象，使用<code>call</code>调用数组的<code>slice</code>方法，指定<code>objArr</code>为<code>slice</code>方法内部的<code>this</code>，<code>slice</code>方法返回值赋给<code>arr</code>。</p>
<p>另外来看看数组<code>slice</code>方法的内部实现原理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>=<span class="keyword">function</span>(<span class="params">start,end</span>)&#123;  <span class="comment">//数组方法slice的底层内部实现</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>(); <span class="comment">//新数组</span></span><br><span class="line">    <span class="keyword">var</span> start = start || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> end = end || <span class="variable language_">this</span>.<span class="property">length</span>; <span class="comment">//this指向调用的对象，用了call之后，改变this的指向，指向传进来的对象</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=start; i&lt;end; i++)&#123;</span><br><span class="line">        result.<span class="title function_">push</span>(<span class="variable language_">this</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;	<span class="comment">//返回的为一个新的数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Function-prototype-apply"><a href="#Function-prototype-apply" class="headerlink" title="Function.prototype.apply()"></a>Function.prototype.apply()</h4><p><code>apply</code>方法的作用与<code>call</code>方法类似，也是改变<code>this</code>指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。</p>
<h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">func.<span class="title function_">apply</span>(thisValue, [arg1, arg2, ...])</span><br><span class="line"><span class="comment">// 第一个参数thisValue为函数内this将要指向的对象</span></span><br><span class="line"><span class="comment">// 第二个参数为一个数组，数组每一项为传入函数的参数</span></span><br></pre></td></tr></table></figure>

<p> <code>apply</code>方法的第一个参数也是<code>this</code>所要指向的那个对象，如果设为<code>null</code>或<code>undefined</code>，则等同于指定全局对象。第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。原函数的参数，在<code>call</code>方法中必须一个个添加，但是在<code>apply</code>方法中，必须以数组形式添加。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, y</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x + y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.<span class="title function_">call</span>(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 2</span></span><br><span class="line">f.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">1</span>]) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>f</code>函数本来接受两个参数，使用<code>apply</code>方法以后，就变成可以接受一个数组作为参数。</p>
<p>利用这一点，可以做一些有趣的应用。</p>
<h5 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h5><h5 id="（1）获取数组最大-最小元素"><a href="#（1）获取数组最大-最小元素" class="headerlink" title="（1）获取数组最大&#x2F;最小元素"></a>（1）获取数组最大&#x2F;最小元素</h5><p>JavaScript 不提供找出数组最大元素的函数。结合使用<code>apply</code>方法和<code>Math.max/Math.min</code>方法，就可以返回数组的最大&#x2F;最小元素。</p>
<p><strong>利用第二个参数为数组的特点</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取最大值</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">10</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">9</span>];</span><br><span class="line"><span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, a) <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Math.max方法获取最大值</span></span><br><span class="line"><span class="comment">//Math.max(10, 2, 4, 15, 9) // 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最小值</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">10</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">9</span>];</span><br><span class="line"><span class="title class_">Math</span>.<span class="property">min</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, a) <span class="comment">// 15    null等于绑定全局对象</span></span><br></pre></td></tr></table></figure>

<h5 id="（2）将数组的空元素变为undefined"><a href="#（2）将数组的空元素变为undefined" class="headerlink" title="（2）将数组的空元素变为undefined"></a>（2）将数组的空元素变为<code>undefined</code></h5><p>通过<code>apply</code>方法，利用<code>Array</code>构造函数将数组的空元素变成<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="string">&#x27;a&#x27;</span>, ,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, undefined, &#x27;b&#x27; ]</span></span><br></pre></td></tr></table></figure>

<p>空元素与<code>undefined</code>的差别在于，数组的<code>forEach</code>方法会跳过空元素，但是不会跳过<code>undefined</code>。因此，遍历内部元素的时候，会得到不同的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>, , <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">print</span>(<span class="params">i</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.<span class="title function_">forEach</span>(print)</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, a).<span class="title function_">forEach</span>(print)</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// b</span></span><br></pre></td></tr></table></figure>

<h5 id="（3）转换类似数组的对象"><a href="#（3）转换类似数组的对象" class="headerlink" title="（3）转换类似数组的对象"></a>（3）转换类似数组的对象</h5><p>另外，利用数组对象的<code>slice</code>方法，可以将一个类似数组的对象（比如<code>arguments</code>对象）转为真正的数组。</p>
<p>和使用<code>call</code>方法的效果一样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">apply</span>(&#123;<span class="number">0</span>: <span class="number">1</span>, <span class="attr">length</span>: <span class="number">1</span>&#125;) <span class="comment">// [1]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">apply</span>(&#123;<span class="number">0</span>: <span class="number">1</span>&#125;) <span class="comment">// []</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">apply</span>(&#123;<span class="number">0</span>: <span class="number">1</span>, <span class="attr">length</span>: <span class="number">2</span>&#125;) <span class="comment">// [1, undefined]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">apply</span>(&#123;<span class="attr">length</span>: <span class="number">1</span>&#125;) <span class="comment">// [undefined]</span></span><br></pre></td></tr></table></figure>

<p>上面代码的<code>apply</code>方法的参数都是对象，但是返回结果都是数组，这就起到了将对象转成数组的目的。从上面代码可以看到，这个方法起作用的前提是，被处理的对象必须有<code>length</code>属性，以及相对应的数字键。</p>
<h5 id="（4）绑定回调函数的对象"><a href="#（4）绑定回调函数的对象" class="headerlink" title="（4）绑定回调函数的对象"></a>（4）绑定回调函数的对象</h5><p>前面的按钮点击事件的例子，可以改写如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">o.<span class="property">f</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === o);<span class="comment">// true  ，如未改变this指向，this将指向 DOM 对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">  o.<span class="property">f</span>.<span class="title function_">apply</span>(o);</span><br><span class="line">  <span class="comment">// 或者 o.f.call(o);</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jQuery 的写法</span></span><br><span class="line">$(<span class="string">&#x27;#button&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, f);</span><br></pre></td></tr></table></figure>

<p>上面代码中，点击按钮以后，控制台将会显示<code>true</code>。由于<code>apply</code>方法（或者<code>call</code>方法）不仅绑定函数执行时所在的对象，还会立即执行函数，因此不得不把绑定语句写在一个函数体内。更简洁的写法是采用下面介绍的<code>bind</code>方法。</p>
<h4 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind()"></a>Function.prototype.bind()</h4><p> <code>bind</code>方法用于将函数体内的<code>this</code>绑定到某个对象，然后<strong>返回一个新函数，bind方法并非立即执行一个函数。</strong></p>
<h5 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">func.<span class="title function_">bind</span>(thisValue, arg1, arg2, ...)()</span><br><span class="line"><span class="comment">// 第一个参数thisValue为函数内this将要指向的对象</span></span><br><span class="line"><span class="comment">// 其余参数为传入函数的参数</span></span><br><span class="line"><span class="comment">// bind方法返回一个新函数，并非立即执行，如需执行要在后面加个括号</span></span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">d.<span class="title function_">getTime</span>() <span class="comment">// 1481869925657</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> print = d.<span class="property">getTime</span>;</span><br><span class="line"><span class="title function_">print</span>() <span class="comment">// Uncaught TypeError: this is not a Date object.</span></span><br></pre></td></tr></table></figure>

<p> 上面代码中，我们将<code>d.getTime</code>方法赋给变量<code>print</code>，然后调用<code>print</code>就报错了。这是因为<code>getTime</code>方法内部的<code>this</code>，绑定<code>Date</code>对象的实例，赋给变量<code>print</code>以后，内部的<code>this</code>已经不指向<code>Date</code>对象的实例了。</p>
<p><code>bind</code>方法可以解决这个问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> print = d.<span class="property">getTime</span>.<span class="title function_">bind</span>(d);</span><br><span class="line"><span class="title function_">print</span>() <span class="comment">// 1481869925657</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>bind</code>方法将<code>getTime</code>方法内部的<code>this</code>绑定到<code>d</code>对象，这时就可以安全地将这个方法赋值给其他变量了。</p>
<p> <code>bind</code>方法的参数就是所要绑定<code>this</code>的对象，下面是一个更清晰的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">inc</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = counter.<span class="property">inc</span>.<span class="title function_">bind</span>(counter);</span><br><span class="line"><span class="title function_">func</span>();</span><br><span class="line">counter.<span class="property">count</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>counter.inc</code>方法被赋值给变量<code>func</code>。这时必须用<code>bind</code>方法将<code>inc</code>内部的<code>this</code>，绑定到<code>counter</code>，否则就会出错。</p>
<p><code>this</code>绑定到其他对象也是可以的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">inc</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">100</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> func = counter.<span class="property">inc</span>.<span class="title function_">bind</span>(obj);</span><br><span class="line"><span class="title function_">func</span>();</span><br><span class="line">obj.<span class="property">count</span> <span class="comment">// 101</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>bind</code>方法将<code>inc</code>方法内部的<code>this</code>，绑定到<code>obj</code>对象。结果调用<code>func</code>函数以后，递增的就是<code>obj</code>内部的<code>count</code>属性。</p>
<p><code>bind</code>还可以接受更多的参数，将这些参数绑定原函数的参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * <span class="variable language_">this</span>.<span class="property">m</span> + y * <span class="variable language_">this</span>.<span class="property">n</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">m</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">n</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newAdd = add.<span class="title function_">bind</span>(obj, <span class="number">5</span>); <span class="comment">// 第二个参数为add内的x</span></span><br><span class="line"><span class="title function_">newAdd</span>(<span class="number">5</span>) <span class="comment">// 20 传入的参数为add内的y</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>bind</code>方法除了绑定<code>this</code>对象，还将<code>add</code>函数的第一个参数<code>x</code>绑定成<code>5</code>，然后返回一个新函数<code>newAdd</code>，这个函数只要再接受一个参数<code>y</code>就能运行了。</p>
<p>如果<code>bind</code>方法的第一个参数是<code>null</code>或<code>undefined</code>，等于将<code>this</code>绑定到全局对象，函数运行时<code>this</code>指向顶层对象（浏览器为<code>window</code>）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> plus5 = add.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="number">5</span>);</span><br><span class="line"><span class="title function_">plus5</span>(<span class="number">10</span>) <span class="comment">// 15  传入的参数为add内的y</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>add</code>内部并没有<code>this</code>，使用<code>bind</code>方法的主要目的是绑定参数<code>x</code>，以后每次运行新函数<code>plus5</code>，就只需要提供另一个参数<code>y</code>就够了。而且因为<code>add</code>内部没有<code>this</code>，所以<code>bind</code>的第一个参数是<code>null</code>，不过这里如果是其他对象，也没有影响。</p>
<h5 id="bind要注意的点："><a href="#bind要注意的点：" class="headerlink" title="bind要注意的点："></a>bind要注意的点：</h5><h5 id="（1）每一次返回一个新函数"><a href="#（1）每一次返回一个新函数" class="headerlink" title="（1）每一次返回一个新函数"></a>（1）每一次返回一个新函数</h5><p><code>bind</code>方法<strong>每运行一次，就返回一个新函数</strong>，这会产生一些问题。比如，监听事件的时候，不能写成下面这样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, o.<span class="property">m</span>.<span class="title function_">bind</span>(o));</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>click</code>事件绑定<code>bind</code>方法生成的一个匿名函数。这样会导致无法取消绑定，所以，下面的代码是无效的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, o.<span class="property">m</span>.<span class="title function_">bind</span>(o));</span><br></pre></td></tr></table></figure>

<p>正确的方法是写成下面这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> listener = o.<span class="property">m</span>.<span class="title function_">bind</span>(o);</span><br><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, listener);</span><br><span class="line"><span class="comment">//  ...</span></span><br><span class="line">element.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, listener);</span><br></pre></td></tr></table></figure>

<h5 id="（2）结合回调函数使用"><a href="#（2）结合回调函数使用" class="headerlink" title="（2）结合回调函数使用"></a>（2）结合回调函数使用</h5><p>回调函数是 JavaScript 最常用的模式之一，但是一个常见的错误是，将包含<code>this</code>的方法直接当作回调函数。解决方法就是使用<code>bind</code>方法，将<code>counter.inc</code>绑定<code>counter</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">inc</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">callIt</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="title function_">callback</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">callIt</span>(counter.<span class="property">inc</span>.<span class="title function_">bind</span>(counter));</span><br><span class="line">counter.<span class="property">count</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>callIt</code>方法会调用回调函数。这时如果直接把<code>counter.inc</code>传入，调用时<code>counter.inc</code>内部的<code>this</code>就会指向全局对象。使用<code>bind</code>方法将<code>counter.inc</code>绑定<code>counter</code>以后，就不会有这个问题，<code>this</code>总是指向<code>counter</code>。</p>
<p>还有一种情况比较隐蔽，就是某些数组方法可以接受一个函数当作参数。这些函数内部的<code>this</code>指向，很可能也会出错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="attr">times</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  <span class="attr">print</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">times</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">n</span>) &#123; <span class="comment">// 数组的forEach方法内部this指向问题</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// 这里的this指向全局对象</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">print</span>()</span><br><span class="line"><span class="comment">// 没有任何输出</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>obj.print</code>内部<code>this.times</code>的<code>this</code>是指向<code>obj</code>的，这个没有问题。但是，<code>forEach</code>方法的回调函数内部的<code>this.name</code>却是指向全局对象，导致没有办法取到值。稍微改动一下，就可以看得更清楚。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj.<span class="property">print</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">times</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="variable language_">window</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">print</span>()</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>解决这个问题，也是通过<code>bind</code>方法绑定<code>this</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj.<span class="property">print</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">times</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;.<span class="title function_">bind</span>(<span class="variable language_">this</span>));<span class="comment">// 使用bind把this指向的obj对象传入方法内</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">print</span>()</span><br><span class="line"><span class="comment">// 张三</span></span><br><span class="line"><span class="comment">// 张三</span></span><br><span class="line"><span class="comment">// 张三</span></span><br></pre></td></tr></table></figure>

<h5 id="（3）结合call方法使用（改写数组方法调用形式）"><a href="#（3）结合call方法使用（改写数组方法调用形式）" class="headerlink" title="（3）结合call方法使用（改写数组方法调用形式）"></a>（3）结合<code>call</code>方法使用（改写数组方法调用形式）</h5><p>利用<code>bind</code>方法，可以<strong>改写一些 JavaScript 原生方法的使用形式</strong>，以数组的<code>slice</code>方法为例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">1</span>) <span class="comment">// [1]</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span>, <span class="number">1</span>) <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，数组的<code>slice</code>方法从<code>[1, 2, 3]</code>里面，按照指定位置和长度切分出另一个数组。这样做的本质是在<code>[1, 2, 3]</code>上面调用<code>Array.prototype.slice</code>方法，因此可以用<code>call</code>方法表达这个过程，得到同样的结果。</p>
<p><code>call</code>方法实质上是调用<code>Function.prototype.call</code>方法，因此上面的表达式可以<strong>用<code>bind</code>方法改写</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">call</span>.<span class="title function_">bind</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>);</span><br><span class="line"><span class="title function_">slice</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span>, <span class="number">1</span>) <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure>

<p>上面代码的含义就是，将<code>Array.prototype.slice</code>变成<code>Function.prototype.call</code>方法所在的对象，调用时就变成了<code>Array.prototype.slice.call</code>。类似的写法还可以用于其他数组方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> push = <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">call</span>.<span class="title function_">bind</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span>);</span><br><span class="line"><span class="keyword">var</span> pop = <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">call</span>.<span class="title function_">bind</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span> ,<span class="number">2</span> ,<span class="number">3</span>];</span><br><span class="line"><span class="title function_">push</span>(a, <span class="number">4</span>)</span><br><span class="line">a <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">pop</span>(a)</span><br><span class="line">a <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>如果再进一步，将<code>Function.prototype.call</code>方法绑定到<code>Function.prototype.bind</code>对象，就意味着<code>bind</code>的调用形式也可以被改写。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">v</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">v</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> bind = <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">call</span>.<span class="title function_">bind</span>(<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span>);</span><br><span class="line"><span class="title function_">bind</span>(f, o)() <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p>上面代码的含义就是，将<code>Function.prototype.bind</code>方法绑定在<code>Function.prototype.call</code>上面，所以<code>bind</code>方法就可以直接使用，不需要在函数实例上使用。</p>
<h4 id="总结，call-、apply-、bind-的区别"><a href="#总结，call-、apply-、bind-的区别" class="headerlink" title="总结，call()、apply()、bind()的区别"></a>总结，call()、apply()、bind()的区别</h4><p>这三个方法都是改变函数内部this指向的。</p>
<p>它们的区别是：</p>
<p>call()第一个参数为函数内this将要指向的对象，其余参数为传入函数的参数。</p>
<p>apply()第一个参数为函数内this将要指向的对象，第二个参数为数组，数组每一项为传入函数的参数。</p>
<p>bind()传入参数和call()一样，区别是bind()返回一个新的函数，并非立即执行。</p>
<h2 id="三、对象的继承"><a href="#三、对象的继承" class="headerlink" title="三、对象的继承"></a>三、对象的继承</h2><p>面向对象编程很重要的一个方面，就是对象的继承。<strong>A 对象通过继承 B 对象，就能直接拥有 B 对象的所有属性和方法。这对于代码的复用是非常有用的</strong>。</p>
<p>大部分面向对象的编程语言，都是通过“类”（class）实现对象的继承。传统上，JavaScript 语言的继承不通过 class，而是通过“原型对象”（prototype）实现，本章介绍 JavaScript 的原型链继承。</p>
<p>ES6 引入了 class 语法，基于 class 的继承不在这个教程介绍，请参阅《ES6 标准入门》一书的相关章节。</p>
<p><strong>ES5 是通过“原型对象”（prototype）实现继承。</strong></p>
<h3 id="1、原型对象概述"><a href="#1、原型对象概述" class="headerlink" title="1、原型对象概述"></a>1、原型对象概述</h3><h4 id="（1）构造函数的缺点"><a href="#（1）构造函数的缺点" class="headerlink" title="（1）构造函数的缺点"></a>（1）构造函数的缺点</h4><p>JavaScript 通过构造函数生成新对象，因此<strong>构造函数可以视为对象的模板</strong>。实例对象的属性和方法，可以定义在构造函数内部。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Cat</span> (name, color) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;大毛&#x27;</span>, <span class="string">&#x27;白色&#x27;</span>);</span><br><span class="line"></span><br><span class="line">cat1.<span class="property">name</span> <span class="comment">// &#x27;大毛&#x27;</span></span><br><span class="line">cat1.<span class="property">color</span> <span class="comment">// &#x27;白色&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Cat</code>函数是一个构造函数，函数内部定义了<code>name</code>属性和<code>color</code>属性，所有实例对象（上例是<code>cat1</code>）都会生成这两个属性，即这两个属性会定义在实例对象上面。</p>
<p>通过构造函数为实例对象定义属性，虽然很方便，但是有一个缺点。<strong>同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Cat</span>(<span class="params">name, color</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">meow</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;喵喵&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方法，就是在原型对象（prototype）上创建共同的方法</span></span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">meow2</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;喵喵&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;大毛&#x27;</span>, <span class="string">&#x27;白色&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;二毛&#x27;</span>, <span class="string">&#x27;黑色&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// cat1和cat2是同一个构造函数的两个实例对象，他们无法共享meow属性，从而造成对系统资源的浪费。</span></span><br><span class="line">cat1.<span class="property">meow</span> === cat2.<span class="property">meow</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">cat1.<span class="property">meow2</span> === cat2.<span class="property">meow2</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>cat1</code>和<code>cat2</code>是同一个构造函数的两个实例，它们都具有<code>meow</code>方法。由于<code>meow</code>方法是生成在每个实例对象上面，所以两个实例就生成了两次。也就是说，每新建一个实例，就会新建一个<code>meow</code>方法。这既没有必要，又浪费系统资源，因为所有<code>meow</code>方法都是同样的行为，完全应该共享。</p>
<p><strong>这个问题的解决方法，就是 JavaScript 的原型对象（prototype）。</strong></p>
<h4 id="（2）prototype-属性的作用"><a href="#（2）prototype-属性的作用" class="headerlink" title="（2）prototype 属性的作用"></a>（2）prototype 属性的作用</h4><p><strong>JavaScript 继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享</strong>。也就是说，如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系。</p>
<p>下面，先看怎么为对象指定原型。JavaScript 规定，<strong>每个函数都有一个<code>prototype</code>属性，指向一个对象</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">typeof</span> f.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>f</code>默认具有<code>prototype</code>属性，指向一个对象。</p>
<p> <strong>对于普通函数来说，该属性基本无用</strong>。但是，<strong>对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的原型</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Animal.prototype属性是实例cat1和cat2的原型对象，在上面添加属性，实例就共享了该属性</span></span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">color</span> = <span class="string">&#x27;white&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;大毛&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;二毛&#x27;</span>);</span><br><span class="line"></span><br><span class="line">cat1.<span class="property">color</span> <span class="comment">// &#x27;white&#x27;</span></span><br><span class="line">cat2.<span class="property">color</span> <span class="comment">// &#x27;white&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，构造函数<code>Animal</code>的<code>prototype</code>属性，就是实例对象<code>cat1</code>和<code>cat2</code>的原型对象。原型对象上添加一个<code>color</code>属性，结果，实例对象都共享了该属性。</p>
<p>原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在<strong>所有</strong>实例对象上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">color</span> = <span class="string">&#x27;yellow&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// color属性并非实例对象cat1/cat2本身的属性,只是当实例本身没有该属性或方法时，它会到原型对象去寻找该属性或方法</span></span><br><span class="line">cat1.<span class="property">color</span> <span class="comment">// &quot;yellow&quot;</span></span><br><span class="line">cat2.<span class="property">color</span> <span class="comment">// &quot;yellow&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，原型对象的<code>color</code>属性的值变为<code>yellow</code>，两个实例对象的<code>color</code>属性立刻跟着变了。这是因为实例对象其实没有<code>color</code>属性，都是读取原型对象的<code>color</code>属性。也就是说，<strong>当实例对象本身没有某个属性或方法的时候，它会到原型对象去寻找该属性或方法。</strong>这就是原型对象的特殊之处。</p>
<p>如果<strong>实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cat1.<span class="property">color</span> = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line"></span><br><span class="line">cat1.<span class="property">color</span> <span class="comment">// &#x27;black&#x27;</span></span><br><span class="line">cat2.<span class="property">color</span> <span class="comment">// &#x27;yellow&#x27;</span></span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">color</span> <span class="comment">// &#x27;yellow&#x27;;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，实例对象<code>cat1</code>的<code>color</code>属性改为<code>black</code>，就使得它不再去原型对象读取<code>color</code>属性，后者的值依然为<code>yellow</code>。</p>
<p>总结一下，原型对象的<strong>作用</strong>，<strong>就是定义所有实例对象共享的属性和方法</strong>。这也是它被称为原型对象的原因，而实例对象可以视作从原型对象衍生出来的子对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">walk</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27; is walking&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Animal.prototype</code>对象上面定义了一个<code>walk</code>方法，这个方法将可以在所有<code>Animal</code>实例对象上面调用。</p>
<h4 id="（3）原型链"><a href="#（3）原型链" class="headerlink" title="（3）原型链"></a>（3）原型链</h4><p><strong>JavaScript 规定，所有对象都有自己的原型对象（prototype）。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型……</strong></p>
<p>如果一层层地上溯，所有对象的原型<strong>最终都可以上溯到<code>Object.prototype</code>，即<code>Object</code>构造函数的<code>prototype</code>属性</strong>。也就是说，所有对象都继承了<code>Object.prototype</code>的属性。这就是所有对象都有<code>valueOf</code>和<code>toString</code>方法的原因，因为这是从<code>Object.prototype</code>继承的。</p>
<p>那么，<code>Object.prototype</code>对象有没有它的原型呢？回答是<code>Object.prototype</code>的原型是<code>null</code>。<code>null</code>没有任何属性和方法，也没有自己的原型。因此，**原型链的尽头就是<code>null</code>**。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// Object.getPrototypeOf方法返回对象的原型</span></span><br><span class="line"><span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，<code>Object.prototype</code>对象的原型是<code>null</code>，由于<code>null</code>没有任何属性，所以原型链到此为止。<code>Object.getPrototypeOf</code>方法返回参数对象的原型，具体介绍请看后文。</p>
<p>**读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的<code>Object.prototype</code>还是找不到，则返回<code>undefined</code>**。如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。</p>
<p>注意，一级级向上，在整个原型链上寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。</p>
<p>举例来说，如果让构造函数的<code>prototype</code>属性指向一个数组，就意味着实例对象可以调用数组方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyArray</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyArray</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Array</span>(); <span class="comment">// 构造函数MyArray的原型指向 数组实例</span></span><br><span class="line"><span class="title class_">MyArray</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">MyArray</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mine = <span class="keyword">new</span> <span class="title class_">MyArray</span>(); <span class="comment">// mine是构造函数MyArray的实例</span></span><br><span class="line">mine.<span class="title function_">push</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">mine.<span class="property">length</span> <span class="comment">// 3</span></span><br><span class="line">mine <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">// true 判断实例对象mine是否为构造函数Array的实例</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>mine</code>是构造函数<code>MyArray</code>的实例对象，由于<code>MyArray.prototype</code>指向一个数组实例，使得<code>mine</code>可以调用数组方法（这些方法定义在数组实例的<code>prototype</code>对象上面）。最后那行<code>instanceof</code>表达式，用来比较一个对象是否为某个构造函数的实例，结果就是证明<code>mine</code>为<code>Array</code>的实例，<code>instanceof</code>运算符的详细解释详见后文。</p>
<p> 上面代码还出现了原型对象的<code>constructor</code>属性，这个属性的含义下一节就来解释。</p>
<h4 id="（4）constructor-属性"><a href="#（4）constructor-属性" class="headerlink" title="（4）constructor 属性"></a>（4）constructor 属性</h4><p><strong><code>prototype</code>对象有一个<code>constructor</code>属性，默认指向<code>prototype</code>对象所在的构造函数。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">P</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">P.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === P <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>由于<code>constructor</code>属性定义在<code>prototype</code>对象上面，意味着可以被所有实例对象继承。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">P</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title function_">P</span>();</span><br><span class="line"></span><br><span class="line">p.<span class="property">constructor</span> === P <span class="comment">// true  p自身没有constructor属性，它是读取原型上的</span></span><br><span class="line">p.<span class="property">constructor</span> === P.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> <span class="comment">// true</span></span><br><span class="line">p.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;constructor&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>p</code>是构造函数<code>P</code>的实例对象，但是<code>p</code>自身没有<code>constructor</code>属性，该属性其实是读取原型链上面的<code>P.prototype.constructor</code>属性。</p>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p><code>constructor</code>属性的<strong>作用</strong>是，<strong>可以得知某个实例对象，到底是哪一个构造函数产生的</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line"></span><br><span class="line">f.<span class="property">constructor</span> === F <span class="comment">// true</span></span><br><span class="line">f.<span class="property">constructor</span> === <span class="title class_">RegExp</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>constructor</code>属性确定了实例对象<code>f</code>的构造函数是<code>F</code>，而不是<code>RegExp</code>。</p>
<p>另一方面，有了<code>constructor</code>属性，就可以从一个实例对象新建另一个实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Constr</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="title class_">Constr</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> x.<span class="title function_">constructor</span>(<span class="params"></span>);  <span class="comment">// 等同于 new Constr()</span></span><br><span class="line">y <span class="keyword">instanceof</span> <span class="title class_">Constr</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>x</code>是构造函数<code>Constr</code>的实例，可以从<code>x.constructor</code>间接调用构造函数。这使得在实例方法中，调用自身的构造函数成为可能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Constr</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">createCopy</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="variable language_">this</span>.<span class="title function_">constructor</span>(<span class="params"></span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>createCopy</code>方法调用构造函数，新建另一个实例。</p>
<p><code>constructor</code>属性<strong>表示原型对象与构造函数之间的关联关系</strong>，如果修改了原型对象，一般会同时修改<code>constructor</code>属性，防止引用的时候出错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Person</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123; <span class="comment">// 修改了原型对象,但没有修改原型下的constructor</span></span><br><span class="line">  <span class="attr">method</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  由于原型对象已被修改，原型下的constructor也被修改</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Person</span> <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Object</span> <span class="comment">// true // 普通对象的constructor指向object构造函数</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，构造函数<code>Person</code>的原型对象改掉了，但是没有修改<code>constructor</code>属性，导致这个属性不再指向<code>Person</code>。由于<code>Person</code>的新原型是一个普通对象，而普通对象的<code>constructor</code>属性指向<code>Object</code>构造函数，导致<code>Person.prototype.constructor</code>变成了<code>Object</code>。</p>
<p>所以，修改原型对象时，一般要同时修改<code>constructor</code>属性的指向。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 坏的写法</span></span><br><span class="line">C.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">method1</span>: <span class="keyword">function</span> (<span class="params">...</span>) &#123; ... &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line">C.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">constructor</span>: C,</span><br><span class="line">  <span class="attr">method1</span>: <span class="keyword">function</span> (<span class="params">...</span>) &#123; ... &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更好的写法 （只是在原型对象上添加方法）</span></span><br><span class="line">C.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">method1</span> = <span class="keyword">function</span> (<span class="params">...</span>) &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，要么将<code>constructor</code>属性重新指向原来的构造函数，要么只在原型对象上添加方法，这样可以保证<code>instanceof</code>运算符不会失真。</p>
<p>如果不能确定<code>constructor</code>属性是什么函数，还有一个办法：通过<code>name</code>属性，从实例得到构造函数的名称。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line">f.<span class="property">constructor</span>.<span class="property">name</span> <span class="comment">// &quot;Foo&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="2、instanceof-运算符"><a href="#2、instanceof-运算符" class="headerlink" title="2、instanceof 运算符"></a>2、instanceof 运算符</h3><p> <code>instanceof</code>运算符，<strong>判断对象是否为某个构造函数的实例，返回一个布尔值</strong>。</p>
<h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;实例对象&gt; <span class="keyword">instanceof</span> &lt;构造函数&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var v = new Vehicle();</span><br><span class="line">v instanceof Vehicle // true   v是构造函数Vehicel的实例</span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>v</code>是构造函数<code>Vehicle</code>的实例，所以返回<code>true</code>。</p>
<p><code>instanceof</code>运算符的左边是实例对象，右边是构造函数。它会<strong>检查右边构造函数的原型对象（prototype），是否在左边对象的原型链上</strong>。因此，下面两种写法是等价的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">v <span class="keyword">instanceof</span> <span class="title class_">Vehicle</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="title class_">Vehicle</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(v)</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.prototype.isPrototypeOf</code>的详细解释见后文。</p>
<p>由于<code>instanceof</code>检查整个原型链，因此同一个实例对象，可能会对多个构造函数都返回<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">d <span class="keyword">instanceof</span> <span class="title class_">Date</span> <span class="comment">// true</span></span><br><span class="line">d <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>d</code>同时是<code>Date</code>和<code>Object</code>的实例，因此对这两个构造函数都返回<code>true</code>。</p>
<p>由于<strong>任意对象（除了<code>null</code>）都是<code>Object</code>的实例</strong>，所以<code>instanceof</code>运算符可以判断一个值是否为非<code>null</code>的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，除了<code>null</code>，其他对象的<code>instanceOf Object</code>的运算结果都是<code>true</code>。</p>
<p><code>instanceof</code>的原理是检查右边构造函数的<code>prototype</code>属性，是否在左边对象的原型链上。有一种<strong>特殊情况</strong>，就是左边对象的原型链上，只有<code>null</code>对象。这时，<code>instanceof</code>判断会失真。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">typeof</span> obj <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>) <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.create(null)</code>返回一个新对象<code>obj</code>，它的原型是<code>null</code>（<code>Object.create</code>的详细介绍见后文）。右边的构造函数<code>Object</code>的<code>prototype</code>属性，不在左边的原型链上，因此<code>instanceof</code>就认为<code>obj</code>不是<code>Object</code>的实例。但是，<strong>只要一个对象的原型不是<code>null</code>，<code>instanceof</code>运算符的判断就不会失真</strong>。</p>
<h4 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h4><p><code>instanceof</code>运算符的一个用处，是<strong>判断值的类型</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> y = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> z = <span class="keyword">function</span> (<span class="params"></span>)&#123;&#125;;</span><br><span class="line">x <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">// true</span></span><br><span class="line">y <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// true</span></span><br><span class="line">y <span class="keyword">instanceof</span> <span class="title class_">Function</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>instanceof</code>运算符判断，变量<code>x</code>是数组，变量<code>y</code>是对象，变量<code>z</code>是函数。</p>
<p>注意，<code>instanceof</code>运算符<strong>只能用于对象</strong>，<strong>不适用原始类型的值</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> z = <span class="number">0</span>;</span><br><span class="line">s <span class="keyword">instanceof</span> <span class="title class_">String</span> <span class="comment">// false</span></span><br><span class="line">z <span class="keyword">instanceof</span> <span class="title class_">Number</span> <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 原始类型并没有实例化，所有都返回false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，字符串不是<code>String</code>对象的实例（因为字符串不是对象），所以返回<code>false</code>。</p>
<p>此外，对于<code>undefined</code>和<code>null</code>，<code>instanceof</code>运算符总是返回<code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>利用<code>instanceof</code>运算符，还可以巧妙地解决，调用构造函数时，<strong>忘了加<code>new</code>命令的问题</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fubar</span> (foo, bar) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Fubar</span>) &#123; <span class="comment">// 忘加new命令时 this为 全局对象window</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_foo</span> = foo;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_bar</span> = bar;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fubar</span>(foo, bar);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Fubar</span>(<span class="number">1</span>, <span class="number">2</span>).<span class="property">_foo</span> <span class="comment">// 1</span></span><br><span class="line">(<span class="keyword">new</span> <span class="title class_">Fubar</span>(<span class="number">1</span>, <span class="number">2</span>)).<span class="property">_foo</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码使用<code>instanceof</code>运算符，在函数体内部判断<code>this</code>关键字是否为构造函数<code>Fubar</code>的实例。如果不是，就表明忘了加<code>new</code>命令。</p>
<h3 id="3、构造函数的继承"><a href="#3、构造函数的继承" class="headerlink" title="3、构造函数的继承"></a>3、构造函数的继承</h3><p><strong>让一个构造函数继承另一个构造函数</strong>，是非常常见的需求。</p>
<p>这可以分成两步实现。<strong>第一步是在子类的构造函数中，调用父类的构造函数</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Sub</span>(<span class="params">value</span>) &#123; <span class="comment">// Sub是子类构造函数</span></span><br><span class="line">  <span class="title class_">Super</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>); <span class="comment">// Super是父类构造函数，这的this是子类的实例</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">prop</span> = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Sub</code>是子类的构造函数，<code>this</code>是子类的实例。在实例上调用父类的构造函数<code>Super</code>，<strong>就会让子类实例具有父类实例的属性</strong>。</p>
<p><strong>第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子类的原型指向一个新对象，新对象原型指向父类原型，等于子类原型继承了父类原型，且对子类原型操作不会影响到父类原型</span></span><br><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Super</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Sub</span>;</span><br><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">method</span> = <span class="string">&#x27;...&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Sub.prototype</code>是子类的原型，要将它赋值为<code>Object.create(Super.prototype)</code>，而不是直接等于<code>Super.prototype</code>。否则后面两行对<code>Sub.prototype</code>的操作，会连父类的原型<code>Super.prototype</code>一起修改掉。</p>
<p> <strong>另外一种写法</strong>是<code>Sub.prototype</code>等于一个父类实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Super</span>();<span class="comment">// 这个写法会继承父类实例的方法，不推荐</span></span><br></pre></td></tr></table></figure>

<p>上面这种写法也有继承的效果，但是子类会具有父类实例的方法。有时，这可能不是我们需要的，所以<strong>不推荐</strong>使用这种写法。</p>
<p>举例来说，下面是一个<code>Shape</code>构造函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Shape</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">y</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Shape</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">move</span> = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">x</span> += x;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">y</span> += y;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&#x27;Shape moved.&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们需要让<code>Rectangle</code>构造函数继承<code>Shape</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一步，子类继承父类的实例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Rectangle</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Shape</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>); <span class="comment">// 调用父类构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Rectangle</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">base</span> = <span class="title class_">Shape</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">base</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步，子类继承父类的原型</span></span><br><span class="line"><span class="title class_">Rectangle</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Shape</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Rectangle</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Rectangle</span>;</span><br></pre></td></tr></table></figure>

<p>采用这样的写法以后，<code>instanceof</code>运算符会对子类和父类的构造函数，都返回<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rect = <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line"></span><br><span class="line">rect <span class="keyword">instanceof</span> <span class="title class_">Rectangle</span>  <span class="comment">// true</span></span><br><span class="line">rect <span class="keyword">instanceof</span> <span class="title class_">Shape</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，子类是整体继承父类。有时只需要<strong>单个方法的继承</strong>，这时可以采用下面的写法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">ClassB</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">print</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="comment">// 单个方法的继承</span></span><br><span class="line">  <span class="title class_">ClassA</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">print</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);<span class="comment">// 继承了ClassA的print方法</span></span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，子类<code>B</code>的<code>print</code>方法先调用父类<code>A</code>的<code>print</code>方法，再部署自己的代码。这就等于继承了父类<code>A</code>的<code>print</code>方法。</p>
<h3 id="4、多重继承"><a href="#4、多重继承" class="headerlink" title="4、多重继承"></a>4、多重继承</h3><p> JavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">M1</span>(<span class="params"></span>) &#123; <span class="comment">// 构造函数M1</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">hello</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">M2</span>(<span class="params"></span>) &#123; <span class="comment">// 构造函数M2</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">world</span> = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">S</span>(<span class="params"></span>) &#123; <span class="comment">// 子类构造函数S</span></span><br><span class="line">  <span class="variable constant_">M1</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="variable constant_">M2</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 M1</span></span><br><span class="line">S.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="variable constant_">M1</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="comment">// 继承链上加入 M2</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(S.<span class="property"><span class="keyword">prototype</span></span>, <span class="variable constant_">M2</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定构造函数</span></span><br><span class="line">S.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = S;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title function_">S</span>();</span><br><span class="line">s.<span class="property">hello</span> <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line">s.<span class="property">world</span> <span class="comment">// &#x27;world&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，子类<code>S</code>同时继承了父类<code>M1</code>和<code>M2</code>。这种模式又称为 Mixin（混入）。</p>
<h3 id="5、模块"><a href="#5、模块" class="headerlink" title="5、模块"></a>5、模块</h3><p>随着网站逐渐变成“互联网应用程序”，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试等等……开发者必须使用软件工程的方法，管理网页的业务逻辑。</p>
<p><strong>JavaScript 模块化编程</strong>，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。</p>
<p>但是，JavaScript 不是一种模块化编程语言，ES6 才开始支持“类”和“模块”。下面介绍传统的做法，如何利用对象实现模块的效果。</p>
<h4 id="（1）基本的实现方法"><a href="#（1）基本的实现方法" class="headerlink" title="（1）基本的实现方法"></a>（1）基本的实现方法</h4><p><strong>模块是实现特定功能的一组属性和方法的封装。</strong></p>
<p>简单的做法是把模块写成一个对象，所有的模块成员都放到这个对象里面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = <span class="keyword">new</span> <span class="title class_">Object</span>(&#123;</span><br><span class="line">　_count : <span class="number">0</span>,</span><br><span class="line">　m1 : <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">　　<span class="comment">//...</span></span><br><span class="line">　&#125;,</span><br><span class="line">　m2 : <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">  　<span class="comment">//...</span></span><br><span class="line">　&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面的函数<code>m1</code>和<code>m2</code>，都封装在<code>module1</code>对象里。使用的时候，就是调用这个对象的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用</span></span><br><span class="line">module1.<span class="title function_">m1</span>();</span><br></pre></td></tr></table></figure>

<p>但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">module1.<span class="property">_count</span> = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>



<h4 id="（2）封装私有变量："><a href="#（2）封装私有变量：" class="headerlink" title="（2）封装私有变量："></a>（2）封装私有变量：</h4><h5 id="（2-1）构造函数的写法"><a href="#（2-1）构造函数的写法" class="headerlink" title="（2-1）构造函数的写法"></a>（2-1）构造函数的写法</h5><p>我们可以利用构造函数，封装私有变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">StringBuilder</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> buffer = []; <span class="comment">// 模块的私有变量</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">add</span> = <span class="keyword">function</span> (<span class="params">str</span>) &#123;</span><br><span class="line">     buffer.<span class="title function_">push</span>(str);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">toString</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> buffer.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>buffer</code>是模块的私有变量。一旦生成实例对象，外部是无法直接访问<code>buffer</code>的。但是，这种方法将私有变量封装在构造函数中，导致构造函数与实例对象是一体的，总是存在于内存之中，无法在使用完成后清除。这意味着，构造函数有双重作用，既用来塑造实例对象，又用来保存实例对象的数据，违背了构造函数与实例对象在数据上相分离的原则（即实例对象的数据，不应该保存在实例对象以外）。同时，非常耗费内存。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">StringBuilder</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_buffer</span> = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">StringBuilder</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">constructor</span>: <span class="title class_">StringBuilder</span>,</span><br><span class="line">  <span class="attr">add</span>: <span class="keyword">function</span> (<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_buffer</span>.<span class="title function_">push</span>(str);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">toString</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_buffer</span>.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种方法将私有变量放入实例对象中，好处是看上去更自然，但是它的私有变量可以从外部读写，不是很安全。</p>
<h5 id="（2-2）立即执行函数的写法"><a href="#（2-2）立即执行函数的写法" class="headerlink" title="（2-2）立即执行函数的写法"></a>（2-2）立即执行函数的写法</h5><p>另一种做法是使用“立即执行函数”（Immediately-Invoked Function Expression，IIFE），将相关的属性和方法封装在一个函数作用域里面，可以达到不暴露私有成员的目的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">　<span class="keyword">var</span> _count = <span class="number">0</span>;</span><br><span class="line">　<span class="keyword">var</span> m1 = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">　  <span class="comment">//...</span></span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">var</span> m2 = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">　　<span class="comment">//...</span></span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">return</span> &#123;</span><br><span class="line">　　m1 : m1,</span><br><span class="line">　　m2 : m2</span><br><span class="line">　&#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>使用上面的写法，外部代码无法读取内部的<code>_count</code>变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">info</span>(module1.<span class="property">_count</span>); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>上面的<code>module1</code>就是 JavaScript 模块的基本写法。下面，再对这种写法进行加工。</p>
<h4 id="（3）模块的放大模式（向模块添加新方法）"><a href="#（3）模块的放大模式（向模块添加新方法）" class="headerlink" title="（3）模块的放大模式（向模块添加新方法）"></a>（3）模块的放大模式（向模块添加新方法）</h4><p>如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式”（augmentation）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="keyword">function</span> (<span class="params">mod</span>)&#123;</span><br><span class="line">　mod.<span class="property">m3</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">　　<span class="comment">//...</span></span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">return</span> mod;</span><br><span class="line">&#125;)(module1);</span><br></pre></td></tr></table></figure>

<p>上面的代码为<code>module1</code>模块添加了一个新方法<code>m3()</code>，然后返回新的<code>module1</code>模块。</p>
<p>在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上面的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽放大模式”（Loose augmentation）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="keyword">function</span> (<span class="params">mod</span>) &#123;</span><br><span class="line">　<span class="comment">//...</span></span><br><span class="line">　<span class="keyword">return</span> mod;</span><br><span class="line">&#125;)(<span class="variable language_">window</span>.<span class="property">module1</span> || &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>与”放大模式”相比，“宽放大模式”就是“立即执行函数”的参数可以是空对象。</p>
<h4 id="（4）输入全局变量（保证独立性）"><a href="#（4）输入全局变量（保证独立性）" class="headerlink" title="（4）输入全局变量（保证独立性）"></a>（4）输入全局变量（保证独立性）</h4><p>独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。</p>
<p>为了在模块内部调用全局变量，必须显式地将其他变量输入模块。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="keyword">function</span> (<span class="params">$, YAHOO</span>) &#123;</span><br><span class="line">　<span class="comment">//...</span></span><br><span class="line">&#125;)(jQuery, <span class="variable constant_">YAHOO</span>); <span class="comment">// 向模块内部传入全局变量</span></span><br></pre></td></tr></table></figure>

<p>上面的<code>module1</code>模块需要使用 jQuery 库和 YUI 库，就把这两个库（其实是两个模块）当作参数输入<code>module1</code>。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。</p>
<p><strong>立即执行函数还可以起到命名空间的作用</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params">$, <span class="variable language_">window</span>, <span class="variable language_">document</span></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">go</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleEvents</span>(<span class="params"></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">initialize</span>(<span class="params"></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dieCarouselDie</span>(<span class="params"></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//attach to the global scope</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">finalCarousel</span> = &#123; <span class="comment">// 对外暴露接口</span></span><br><span class="line">    init : initialize,</span><br><span class="line">    destroy : dieCarouselDie</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)( jQuery, <span class="variable language_">window</span>, <span class="variable language_">document</span> );</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>finalCarousel</code>对象输出到全局，对外暴露<code>init</code>和<code>destroy</code>接口，<strong>内部方法<code>go</code>、<code>handleEvents</code>、<code>initialize</code>、<code>dieCarouselDie</code>都是外部无法调用的</strong>。</p>
<h2 id="四、Object-对象的相关方法"><a href="#四、Object-对象的相关方法" class="headerlink" title="四、Object 对象的相关方法"></a>四、Object 对象的相关方法</h2><p> JavaScript 在<code>Object</code>对象上面，提供了很多相关方法，处理面向对象编程的相关操作。本章介绍这些方法。</p>
<h3 id="1、Object-getPrototypeOf-获取原型对象"><a href="#1、Object-getPrototypeOf-获取原型对象" class="headerlink" title="1、Object.getPrototypeOf() 获取原型对象"></a>1、Object.getPrototypeOf() 获取原型对象</h3><p><code>Object.getPrototypeOf</code>方法<strong>返回参数对象的原型</strong>。这是获取原型对象的标准方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(f) === F.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，实例对象<code>f</code>的原型是<code>F.prototype</code>。</p>
<p>下面是几种特殊对象的原型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空对象的原型是 Object.prototype</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(&#123;&#125;) === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.prototype 的原型是 null</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>) === <span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的原型是 Function.prototype</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(f) === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h3 id="2、Object-setPrototypeOf-设置原型对象"><a href="#2、Object-setPrototypeOf-设置原型对象" class="headerlink" title="2、Object.setPrototypeOf() 设置原型对象"></a>2、Object.setPrototypeOf() 设置原型对象</h3><p> <code>Object.setPrototypeOf</code>方法为参数对象<strong>设置原型</strong>，<strong>返回该参数对象</strong>。它接受两个参数，第一个是现有对象，第二个是原型对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> b = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(a, b);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(a) === b <span class="comment">// true</span></span><br><span class="line">a.<span class="property">x</span> <span class="comment">// 1  a对象共享b对象的属性</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.setPrototypeOf</code>方法将对象<code>a</code>的原型，设置为对象<code>b</code>，因此<code>a</code>可以共享<code>b</code>的属性。</p>
<h5 id="使用Object-setPrototypeOf方法模拟new命令"><a href="#使用Object-setPrototypeOf方法模拟new命令" class="headerlink" title="使用Object.setPrototypeOf方法模拟new命令"></a><strong>使用<code>Object.setPrototypeOf</code>方法模拟<code>new</code>命令</strong></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(&#123;&#125;, F.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// 模拟new命令</span></span><br><span class="line">F.<span class="title function_">call</span>(f);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>new</code>命令新建实例对象，其实可以分成两步。第一步，将一个空对象的原型设为构造函数的<code>prototype</code>属性（上例是<code>F.prototype</code>）；第二步，将构造函数内部的<code>this</code>绑定这个空对象，然后执行构造函数，使得定义在<code>this</code>上面的方法和属性（上例是<code>this.foo</code>），都转移到这个空对象上。</p>
<h3 id="3、-Object-create-创建实例对象，指向目标对象的原型"><a href="#3、-Object-create-创建实例对象，指向目标对象的原型" class="headerlink" title="3、 Object.create() 创建实例对象，指向目标对象的原型"></a>3、 Object.create() 创建实例对象，指向目标对象的原型</h3><p>生成实例对象的常用方法是，使用<code>new</code>命令让构造函数返回一个实例。但是很多时候，只能拿到一个实例对象，它可能根本不是由构建函数生成的，那么能不能从一个实例对象，生成另一个实例对象呢？</p>
<p>JavaScript 提供了<code>Object.create</code>方法，用来满足这种需求。<strong>该方法接受一个对象作为参数，然后以它为原型，返回一个实例对象。</strong>该实例完全继承原型对象的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原型对象</span></span><br><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">  <span class="attr">print</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例对象</span></span><br><span class="line"><span class="keyword">var</span> B = <span class="title class_">Object</span>.<span class="title function_">create</span>(A); <span class="comment">// 以A为原型，创建了B实例对象，使B继承了A的属性</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(B) === A <span class="comment">// true</span></span><br><span class="line">B.<span class="title function_">print</span>() <span class="comment">// hello</span></span><br><span class="line">B.<span class="property">print</span> === A.<span class="property">print</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.create</code>方法以<code>A</code>对象为原型，生成了<code>B</code>对象。<code>B</code>继承了<code>A</code>的所有属性和方法。</p>
<p>实际上，<code>Object.create</code>方法可以用下面的代码代替。</p>
<h5 id="内部实现原理"><a href="#内部实现原理" class="headerlink" title="内部实现原理"></a>内部实现原理</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Object</span>.<span class="property">create</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="property">create</span> = <span class="keyword">function</span> (<span class="params">obj</span>) &#123; <span class="comment">// 模拟Object.create方法</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125; <span class="comment">// 创建一个空构造函数F</span></span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = obj; <span class="comment">// 让F的原型 指向参数obj（obj为传入的原型对象）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>(); <span class="comment">// 返回一个F的实例</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码表明，<code>Object.create</code>方法的实质是新建一个空的构造函数<code>F</code>，然后让<code>F.prototype</code>属性指向参数对象<code>obj</code>，最后返回一个<code>F</code>的实例，从而实现让该实例继承<code>obj</code>的属性。</p>
<p>下面三种方式生成的新对象是等价的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="title class_">Object</span>.<span class="title function_">create</span>(&#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="keyword">var</span> obj3 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<p>如果想要生成一个不继承任何属性（比如没有<code>toString</code>和<code>valueOf</code>方法）的对象，可以将<code>Object.create</code>的参数设为<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>); <span class="comment">// 不继承Object的toString和valueOf方法的一个对象</span></span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">valueOf</span>()</span><br><span class="line"><span class="comment">// TypeError: Object [object Object] has no method &#x27;valueOf&#x27;</span></span><br></pre></td></tr></table></figure>

<p> 上面代码中，对象<code>obj</code>的原型是<code>null</code>，它就不具备一些定义在<code>Object.prototype</code>对象上面的属性，比如<code>valueOf</code>方法。</p>
<p>使用<code>Object.create</code>方法的时候，必须提供对象原型，即<strong>参数不能为空，或者不是对象，否则会报错</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">create</span>()</span><br><span class="line"><span class="comment">// TypeError: Object prototype may only be an Object or null</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="number">123</span>)</span><br><span class="line"><span class="comment">// TypeError: Object prototype may only be an Object or null</span></span><br></pre></td></tr></table></figure>

<p><code>Object.create</code>方法生成的新对象，动态继承了原型。在原型上添加或修改任何方法，会立刻反映在新对象之上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(obj1);</span><br><span class="line"></span><br><span class="line">obj1.<span class="property">p</span> = <span class="number">2</span>;</span><br><span class="line">obj2.<span class="property">p</span> <span class="comment">// 2  obj2的原型指向obj1，当访问obj2上的p属性时，js引擎会先在obj2本身上找，没找到会去原型上找</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，修改对象原型<code>obj1</code>会影响到实例对象<code>obj2</code>。</p>
<p> 除了对象的原型，<code>Object.create</code>方法还可以接受<strong>第二个参数。该参数是一个属性描述对象，它所描述的对象属性，会添加到实例对象，作为该对象自身的属性</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">p1</span>: &#123; <span class="comment">// p1为添加到obj实例对象自身的属性</span></span><br><span class="line">    <span class="attr">value</span>: <span class="number">123</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">p2</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;abc&#x27;</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(&#123;&#125;);</span><br><span class="line">obj.<span class="property">p1</span> = <span class="number">123</span>;</span><br><span class="line">obj.<span class="property">p2</span> = <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><code>Object.create</code>方法生成的对象，<strong>继承了它的原型对象的构造函数</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"><span class="keyword">var</span> b = <span class="title class_">Object</span>.<span class="title function_">create</span>(a);</span><br><span class="line"></span><br><span class="line">b.<span class="property">constructor</span> === A <span class="comment">// true</span></span><br><span class="line">b <span class="keyword">instanceof</span> A <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>b</code>对象的原型是<code>a</code>对象，因此继承了<code>a</code>对象的构造函数<code>A</code>。</p>
<h3 id="4、Object-prototype-isPrototypeOf-判断某个对象是否为参数对象的原型"><a href="#4、Object-prototype-isPrototypeOf-判断某个对象是否为参数对象的原型" class="headerlink" title="4、Object.prototype.isPrototypeOf()判断某个对象是否为参数对象的原型"></a>4、Object.prototype.isPrototypeOf()判断某个对象是否为参数对象的原型</h3><p>实例对象的<code>isPrototypeOf</code>方法，用来<strong>判断该对象是否为参数对象的原型</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(o1);</span><br><span class="line"><span class="keyword">var</span> o3 = <span class="title class_">Object</span>.<span class="title function_">create</span>(o2);</span><br><span class="line"></span><br><span class="line">o2.<span class="title function_">isPrototypeOf</span>(o3) <span class="comment">// true  判断o2是否为o3的原型</span></span><br><span class="line">o1.<span class="title function_">isPrototypeOf</span>(o3) <span class="comment">// true  判断o1是否为o3的原型</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>o1</code>和<code>o2</code>都是<code>o3</code>的原型。这表明只要实例对象处在参数对象的原型链上，<code>isPrototypeOf</code>方法都返回<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(&#123;&#125;) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>([]) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(<span class="regexp">/xyz/</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(<span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，由于<code>Object.prototype</code>处于原型链的最顶端，所以对各种实例都返回<code>true</code>，只有直接继承自<code>null</code>的对象除外。</p>
<h3 id="5、Object-prototype-proto-返回该对象的原型，可读写"><a href="#5、Object-prototype-proto-返回该对象的原型，可读写" class="headerlink" title="5、Object.prototype.__proto__ 返回该对象的原型，可读写"></a>5、Object.prototype.__proto__ 返回该对象的原型，可读写</h3><p> 实例对象的<code>__proto__</code><strong>属性</strong>（前后各两个下划线），<strong>返回该对象的原型。该属性可读写</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;) <span class="comment">// 创建实例对象obj，其原型指定为&#123;x:1&#125;</span></span><br><span class="line">obj.<span class="property">__proto__</span> <span class="comment">// &#123;x: 1&#125;  实例对象obj的__proto__属性，返回obj的原型</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj) <span class="comment">// &#123;x: 1&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码通过<code>Object.create</code>创建实例对象obj，指定其原型为<code>&#123;x:1&#125;</code>，访问obj对象的<code>__proto__</code>属性，返回其原型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> p = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">__proto__</span> = p; <span class="comment">// 原型属性可读写</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj) === p <span class="comment">// true</span></span><br><span class="line">obj.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>上面代码通过<code>__proto__</code>属性，将<code>p</code>对象设为<code>obj</code>对象的原型。</p>
<p> 根据语言标准，<code>__proto__</code>属性只有浏览器才需要部署，其他环境可以没有这个属性。它前后的两根下划线，表明它本质是一个内部属性，不应该对使用者暴露。<strong>因此，应该尽量少用这个属性，而是用<code>Object.getPrototypeOf()</code>和<code>Object.setPrototypeOf()</code>，进行原型对象的读写操作</strong>。</p>
<p>原型链可以用<code>__proto__</code>很直观地表示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> B = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;李四&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proto = &#123;</span><br><span class="line">  <span class="attr">print</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A.<span class="property">__proto__</span> = proto; <span class="comment">// 将A的原型指向proto对象</span></span><br><span class="line">B.<span class="property">__proto__</span> = proto; <span class="comment">// 将B的原型指向proto对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享print方法，都是在调用proto对象内的print方法</span></span><br><span class="line">A.<span class="title function_">print</span>() <span class="comment">// 张三</span></span><br><span class="line">B.<span class="title function_">print</span>() <span class="comment">// 李四</span></span><br><span class="line"></span><br><span class="line">A.<span class="property">print</span> === B.<span class="property">print</span> <span class="comment">// true</span></span><br><span class="line">A.<span class="property">print</span> === proto.<span class="property">print</span> <span class="comment">// true</span></span><br><span class="line">B.<span class="property">print</span> === proto.<span class="property">print</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>A</code>对象和<code>B</code>对象的原型都是<code>proto</code>对象，它们都共享<code>proto</code>对象的<code>print</code>方法。也就是说，<code>A</code>和<code>B</code>的<code>print</code>方法，都是在调用<code>proto</code>对象的<code>print</code>方法。</p>
<h3 id="6、获取原型对象方法的比较"><a href="#6、获取原型对象方法的比较" class="headerlink" title="6、获取原型对象方法的比较"></a>6、获取原型对象方法的比较</h3><p>如前所述，<code>__proto__</code>属性指向当前对象的原型对象，即构造函数的<code>prototype</code>属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">obj.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">obj.<span class="property">__proto__</span> === obj.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码首先新建了一个对象<code>obj</code>，它的<code>__proto__</code>属性，指向构造函数（<code>Object</code>或<code>obj.constructor</code>）的<code>prototype</code>属性。</p>
<p>因此，获取实例对象<code>obj</code>的原型对象，有三种方法。</p>
<ul>
<li><code>obj.__proto__</code></li>
<li><code>obj.constructor.prototype</code></li>
<li><code>Object.getPrototypeOf(obj)</code></li>
</ul>
<p>上面三种方法之中，前两种都不是很可靠。<code>__proto__</code>属性只有浏览器才需要部署，其他环境可以不部署。而<code>obj.constructor.prototype</code>在手动改变原型对象时，可能会失效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> P = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title function_">P</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> C = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line">C.<span class="property"><span class="keyword">prototype</span></span> = p;</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line"></span><br><span class="line">c.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span> === p <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，构造函数<code>C</code>的原型对象被改成了<code>p</code>，但是实例对象的<code>c.constructor.prototype</code>却没有指向<code>p</code>。所以，在改变原型对象时，一般要同时设置<code>constructor</code>属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">C.<span class="property"><span class="keyword">prototype</span></span> = p;</span><br><span class="line">C.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = C; <span class="comment">// 如在构造函数的继承中就使用到这个操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line">c.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span> === p <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>因此，<strong>推荐使用第三种<code>Object.getPrototypeOf</code>方法，获取原型对象</strong>。</p>
<h3 id="7、Object-getOwnPropertyNames"><a href="#7、Object-getOwnPropertyNames" class="headerlink" title="7、Object.getOwnPropertyNames()"></a>7、Object.getOwnPropertyNames()</h3><p><code>Object.getOwnPropertyNames</code>方法<strong>返回一个数组，成员是参数对象本身的所有属性的键名，不包含继承的属性键名</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="title class_">Date</span>)</span><br><span class="line"><span class="comment">// [&quot;parse&quot;, &quot;arguments&quot;, &quot;UTC&quot;, &quot;caller&quot;, &quot;name&quot;, &quot;prototype&quot;, &quot;now&quot;, &quot;length&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.getOwnPropertyNames</code>方法返回<code>Date</code>所有自身的属性名。</p>
<p>对象本身的属性之中，有的是可以遍历的（enumerable），有的是不可以遍历的。<code>Object.getOwnPropertyNames</code>方法返回所有键名，不管是否可以遍历。只获取那些可以遍历的属性，使用<code>Object.keys</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Date</span>) <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<p>上面代码表明，<code>Date</code>对象所有自身的属性，都是不可以遍历的。</p>
<h3 id="8、Object-prototype-hasOwnProperty"><a href="#8、Object-prototype-hasOwnProperty" class="headerlink" title="8、Object.prototype.hasOwnProperty()"></a>8、Object.prototype.hasOwnProperty()</h3><p>对象实例的<code>hasOwnProperty</code>方法返回一个布尔值，用于<strong>判断某个属性定义在对象自身，还是定义在原型链上</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Date.hasOwnProperty(&#x27;length&#x27;) // true</span><br><span class="line">Date.hasOwnProperty(&#x27;toString&#x27;) // false</span><br></pre></td></tr></table></figure>

<p>上面代码表明，<code>Date.length</code>（构造函数<code>Date</code>可以接受多少个参数）是<code>Date</code>自身的属性，<code>Date.toString</code>是继承的属性。</p>
<p>另外，<code>hasOwnProperty</code>方法是 JavaScript 之中唯一一个处理对象属性时，不会遍历原型链的方法。</p>
<h3 id="9、in-运算符和-for…in-循环"><a href="#9、in-运算符和-for…in-循环" class="headerlink" title="9、in 运算符和 for…in 循环"></a>9、in 运算符和 for…in 循环</h3><p><code>in</code>运算符<strong>返回一个布尔值，表示一个对象是否具有某个属性</strong>。它不区分该属性是对象自身的属性，还是继承的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;length&#x27;</span> <span class="keyword">in</span> <span class="title class_">Date</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> <span class="title class_">Date</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>in</code>运算符常用于检查一个属性是否存在。</p>
<p>获得对象的所有可遍历属性（不管是自身的还是继承的），可以使用<code>for...in</code>循环。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">p1</span>: <span class="number">123</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(o1, &#123; <span class="comment">// o2的原型指向o1，并且在o2上定义一个属性p2</span></span><br><span class="line">  <span class="attr">p2</span>: &#123; <span class="attr">value</span>: <span class="string">&quot;abc&quot;</span>, <span class="attr">enumerable</span>: <span class="literal">true</span> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (p <span class="keyword">in</span> o2) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">info</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// p2</span></span><br><span class="line"><span class="comment">// p1    继承的属性</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>o2</code>的<code>p2</code>属性是自身的，<code>p1</code>属性是继承的。这两个属性都会被<code>for...in</code>循环遍历。</p>
<p>为了在<code>for...in</code>循环中获得对象自身的属性，可以采用<code>hasOwnProperty</code>方法判断一下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> name <span class="keyword">in</span> object ) &#123;</span><br><span class="line">  <span class="keyword">if</span> ( object.<span class="title function_">hasOwnProperty</span>(name) ) &#123; <span class="comment">// 过滤掉非自身的属性</span></span><br><span class="line">    <span class="comment">/* loop code */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获得对象的所有属性（不管是自身的还是继承的，也不管是否可枚举）</strong>，可以使用下面的函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inheritedPropertyNames</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> props = &#123;&#125;;</span><br><span class="line">  <span class="keyword">while</span>(obj) &#123;</span><br><span class="line">     <span class="comment">// 获取obj对象的所有属性，包括不可枚举的，</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(obj).<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">p</span>) &#123;</span><br><span class="line">      props[p] = <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    obj = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj); <span class="comment">// 获取对象的原型</span></span><br><span class="line">  &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(props)</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码依次获取<code>obj</code>对象的每一级原型对象“自身”的属性，从而获取<code>obj</code>对象的“所有”属性，不管是否可遍历。</p>
<p>下面是一个例子，列出<code>Date</code>对象的所有属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">inheritedPropertyNames</span>(<span class="title class_">Date</span>)</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//  &quot;caller&quot;,</span></span><br><span class="line"><span class="comment">//  &quot;constructor&quot;,</span></span><br><span class="line"><span class="comment">//  &quot;toString&quot;,</span></span><br><span class="line"><span class="comment">//  &quot;UTC&quot;,</span></span><br><span class="line"><span class="comment">//  ...</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure>

<h3 id="10、对象的拷贝"><a href="#10、对象的拷贝" class="headerlink" title="10、对象的拷贝"></a>10、对象的拷贝</h3><p>如果要拷贝一个对象，需要做到下面两件事情。</p>
<ul>
<li>确保拷贝后的对象，与原对象具有同样的原型。</li>
<li>确保拷贝后的对象，与原对象具有同样的实例属性。</li>
</ul>
<p>下面就是根据上面两点，实现的对象拷贝函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">copyObject</span>(<span class="params">orig</span>) &#123; <span class="comment">// 拷贝对象函数</span></span><br><span class="line">    <span class="comment">// 创建一个新对象，新对象的原型指向旧对象的原型</span></span><br><span class="line">  <span class="keyword">var</span> copy = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(orig));</span><br><span class="line">  <span class="title function_">copyOwnPropertiesFrom</span>(copy, orig);</span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">copyOwnPropertiesFrom</span>(<span class="params">target, source</span>) &#123; <span class="comment">// 拷贝旧对象的实例属性</span></span><br><span class="line">  <span class="title class_">Object</span></span><br><span class="line">    .<span class="title function_">getOwnPropertyNames</span>(source)</span><br><span class="line">    .<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">propKey</span>) &#123;</span><br><span class="line">      <span class="comment">// 获取每个属性的 属性描述对象</span></span><br><span class="line">      <span class="keyword">var</span> desc = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(source, propKey);</span><br><span class="line">      <span class="comment">// 定义属性，给target对象定义propKey属性，其属性描述对象是desc</span></span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, propKey, desc);</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种更简单的写法，是利用 ES2017 才引入标准的<code>Object.getOwnPropertyDescriptors</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">copyObject</span>(<span class="params">orig</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">create</span>(</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(orig),</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(orig)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、严格模式"><a href="#五、严格模式" class="headerlink" title="五、严格模式"></a>五、严格模式</h2><p>除了正常的运行模式，JavaScript 还有第二种运行模式：严格模式（strict mode）。顾名思义，这种模式采用更加严格的 JavaScript 语法。</p>
<p>同样的代码，在正常模式和严格模式中，可能会有不一样的运行结果。一些在正常模式下可以运行的语句，在严格模式下将不能运行。</p>
<h3 id="1、设计目的"><a href="#1、设计目的" class="headerlink" title="1、设计目的"></a>1、设计目的</h3><p>早期的 JavaScript 语言有很多设计不合理的地方，但是为了兼容以前的代码，又不能改变老的语法，只能不断添加新的语法，引导程序员使用新语法。</p>
<p>严格模式是从 ES5 进入标准的，主要目的有以下几个。</p>
<ul>
<li>明确禁止一些不合理、不严谨的语法，减少 JavaScript 语言的一些怪异行为。</li>
<li>增加更多报错的场合，消除代码运行的一些不安全之处，保证代码运行的安全。</li>
<li>提高编译器效率，增加运行速度。</li>
<li>为未来新版本的 JavaScript 语法做好铺垫。</li>
</ul>
<p>总之，严格模式体现了 JavaScript 更合理、更安全、更严谨的发展方向。</p>
<h3 id="2、启用方法"><a href="#2、启用方法" class="headerlink" title="2、启用方法"></a>2、启用方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>更多关于严格模式内容：<a href="https://wangdoc.com/javascript/oop/strict.html">https://wangdoc.com/javascript/oop/strict.html</a></p>
</blockquote>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>学习文档：<a href="https://wangdoc.com/javascript/">https://wangdoc.com/javascript/</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript内置对象</title>
    <url>/post/d42987132638/</url>
    <content><![CDATA[<h1 id="内置对象篇"><a href="#内置对象篇" class="headerlink" title="内置对象篇"></a>内置对象篇</h1><h2 id="一、Object对象"><a href="#一、Object对象" class="headerlink" title="一、Object对象"></a>一、Object对象</h2><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>JavaScript 原生提供<code>Object</code>对象（注意起首的<code>O</code>是大写），本章介绍该对象原生的各种方法。</p>
<p>JavaScript 的所有其他对象都继承自<code>Object</code>对象，即那些对象都是<code>Object</code>的实例。</p>
<p><code>Object</code>对象的原生方法分成两类：<code>Object</code>本身的方法与<code>Object</code>的实例方法。</p>
<p><strong>（1）Object对象本身的方法</strong></p>
<p>所谓“本身的方法”就是直接定义在<code>Object</code>对象的方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property">print</span> = <span class="keyword">function</span> (<span class="params">o</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(o) &#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>print</code>方法就是直接定义在<code>Object</code>对象上。</p>
<p><strong>（2）Object的实例方法</strong></p>
<p>所谓实例方法就是定义在<code>Object</code>原型对象<code>Object.prototype</code>上的方法。它可以被<code>Object</code>实例直接使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">print</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj.<span class="title function_">print</span>() <span class="comment">// Object</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.prototype</code>定义了一个<code>print</code>方法，然后生成一个<code>Object</code>的实例<code>obj</code>。<code>obj</code>直接继承了<code>Object.prototype</code>的属性和方法，可以直接使用<code>obj.print</code>调用<code>print</code>方法。也就是说，<code>obj</code>对象的<code>print</code>方法实质上就是调用<code>Object.prototype.print</code>方法。</p>
<p>关于原型对象<code>object.prototype</code>的详细解释，参见《面向对象编程》章节。这里只要知道，凡是定义在<code>Object.prototype</code>对象上面的属性和方法，将被所有实例对象共享就可以了。</p>
<p>以下先介绍<code>Object</code>作为函数的用法，然后再介绍<code>Object</code>对象的原生方法，分成对象自身的方法（又称为“静态方法”）和实例方法两部分。</p>
<h2 id="2、Object-当作工具方法（不通过new创建）"><a href="#2、Object-当作工具方法（不通过new创建）" class="headerlink" title="2、Object() 当作工具方法（不通过new创建）"></a>2、Object() 当作工具方法（不通过new创建）</h2><p><code>Object()</code><strong>本身是一个函数</strong>，可以当作工具方法使用，将任意值转为对象。这个方法常用于保证某个值一定是对象。</p>
<p>如果参数为空（或者为<code>undefined</code>和<code>null</code>），<code>Object()</code>返回一个空对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>() <span class="comment">// obj =&gt; &#123;&#125;</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">obj = <span class="title class_">Object</span>(<span class="literal">undefined</span>)</span><br><span class="line">obj = <span class="title class_">Object</span>(<span class="literal">null</span>)</span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码的含义，是将<code>undefined</code>和<code>null</code>转为对象，结果得到了一个空对象<code>obj</code>。</p>
<p><code>instanceof</code>运算符用来验证，一个对象是否为指定的构造函数的实例。<code>obj instanceof Object</code>返回<code>true</code>，就表示<code>obj</code>对象是<code>Object</code>的实例。</p>
<p>如果参数是原始类型的值，<code>Object</code>方法将其转为对应的包装对象的实例（参见《原始类型的包装对象》一章）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包装对象实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>(<span class="number">1</span>) <span class="comment">// obj =&gt; Number&#123;1&#125;</span></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// true     in s tan ce of 判断对象类型</span></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="title class_">Number</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// obj =&gt; String&#123;‘foo’&#125;</span></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// true</span></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="title class_">String</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>(<span class="literal">true</span>) <span class="comment">// obj =&gt; Boolean&#123;‘foo’&#125;</span></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// true</span></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="title class_">Boolean</span> <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Object</code>函数的参数是各种原始类型的值，转换成对象就是原始类型值对应的包装对象。</p>
<p>如果<code>Object</code>方法的参数是一个对象，它总是返回该对象，即不用转换。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>(arr) <span class="comment">// obj =&gt; []</span></span><br><span class="line">obj === arr <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>(value) <span class="comment">// obj =&gt; &#123;&#125;</span></span><br><span class="line">obj === value <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>(fn) <span class="comment">// obj =&gt; function()&#123;&#125;</span></span><br><span class="line">obj === fn <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<p>利用这一点，可以写一个<strong>判断变量是否为对象</strong>的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function isObject(value)&#123;</span><br><span class="line">    return value === Object(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isObject([]) // true</span><br><span class="line">isObject(&#123;&#125;) // true</span><br><span class="line">isObject(&#x27;123&#x27;) // false</span><br></pre></td></tr></table></figure>



<h2 id="3、Object构造函数（通过new创建）"><a href="#3、Object构造函数（通过new创建）" class="headerlink" title="3、Object构造函数（通过new创建）"></a>3、Object构造函数（通过new创建）</h2><p><code>Object</code>构造函数的首要用途，是直接通过它来<strong>生成新对象</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>() <span class="comment">// 等同于 var obj = &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，通过<code>var obj = new Object()</code>的写法生成新对象，与字面量的写法<code>var obj = &#123;&#125;</code>是等价的。或者说，后者只是前者的一种简便写法。</p>
</blockquote>
<p><code>Object</code>构造函数的用法与工具方法很相似，几乎一模一样。使用时，可以接受一个参数，如果该参数是一个对象，则直接返回这个对象；如果是一个原始类型的值，则返回该值对应的包装对象（详见《包装对象》一章）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var o1 = &#123;a: 1&#125;;</span><br><span class="line">var o2 = new Object(o1);</span><br><span class="line">o1 === o2 // true</span><br><span class="line"></span><br><span class="line">var obj = new Object(123);</span><br><span class="line">obj instanceof Number // true</span><br></pre></td></tr></table></figure>

<p>虽然用法相似，但是<code>Object(value)</code>与<code>new Object(value)</code>两者的语义是不同的，<code>Object(value)</code>表示将<code>value</code>转成一个对象，<code>new Object(value)</code>则表示新生成一个对象，它的值是<code>value</code>。</p>
<h2 id="4、Object-的静态方法"><a href="#4、Object-的静态方法" class="headerlink" title="4、Object 的静态方法"></a>4、Object 的静态方法</h2><p>所谓“静态方法”，是指<strong>部署在<code>Object</code>对象自身</strong>的方法。</p>
<h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><p><code>Object.keys()</code>方法和<code>Object.getOwnPropertyNames()</code>方法都用来遍历对象的属性。</p>
<p><code>Object.keys()</code>方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）所有<strong>属性名</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">p1</span>: <span class="number">123</span>,</span><br><span class="line">    <span class="attr">p2</span>: <span class="number">456</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj) <span class="comment">// [&#x27;p1&#x27;,&#x27;p2&#x27;]  注意是属性名</span></span><br></pre></td></tr></table></figure>

<h3 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h3><p><code>Object.getOwnPropertyNames</code>方法与<code>Object.keys</code>类似，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">p1</span>: <span class="number">123</span>,</span><br><span class="line">    <span class="attr">p2</span>: <span class="number">456</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(obj) <span class="comment">// [&#x27;p1&#x27;,&#x27;p2&#x27;]</span></span><br><span class="line"><span class="comment">// getOwnPropertyNames 中文含义：获取自己的属性名</span></span><br></pre></td></tr></table></figure>

<p>对于一般的对象来说，<code>Object.keys()</code>和<code>Object.getOwnPropertyNames()</code>返回的结果是一样的。只有涉及不可枚举属性时，才会有不一样的结果。<code>Object.keys</code>方法只返回可枚举的属性（详见《对象属性的描述对象》一章），<code>Object.getOwnPropertyNames</code>方法还返回<strong>不可枚举的属性名</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;world&#x27;</span>]</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(a) <span class="comment">// [&#x27;0&#x27;,‘1’]  如果对象是数组时返回索引字符串</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(a) <span class="comment">// [‘0’,‘1’,&#x27;length&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，数组的<code>length</code>属性是<strong>不可枚举的属性</strong>，所以只出现在<code>Object.getOwnPropertyNames</code>方法的返回结果中。</p>
<p>由于 JavaScript 没有提供计算对象属性个数的方法，所以可以用这两个方法代替。</p>
<p><strong>获取对象属性个数长度</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  p1: 123,</span><br><span class="line">  p2: 456</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.keys(obj).length // 2</span><br><span class="line">Object.getOwnPropertyNames(obj).length // 2</span><br></pre></td></tr></table></figure>

<p>一般情况下，几乎总是使用<code>Object.keys</code>方法，遍历对象的属性。</p>
<h3 id="Object的其他静态方法"><a href="#Object的其他静态方法" class="headerlink" title="Object的其他静态方法"></a>Object的其他静态方法</h3><p>除了上面提到的两个方法，<code>Object</code>还有不少其他静态方法，将在后文逐一详细介绍。</p>
<h4 id="（1）对象属性模型的相关方法"><a href="#（1）对象属性模型的相关方法" class="headerlink" title="（1）对象属性模型的相关方法"></a>（1）对象属性模型的相关方法</h4><ul>
<li><code>Object.getOwnPropertyDescriptor()</code>：获取某个属性的描述对象。</li>
<li><code>Object.defineProperty()</code>：通过描述对象，定义某个属性。</li>
<li><code>Object.defineProperties()</code>：通过描述对象，定义多个属性。</li>
</ul>
<h4 id="（2）控制对象状态的方法"><a href="#（2）控制对象状态的方法" class="headerlink" title="（2）控制对象状态的方法"></a>（2）控制对象状态的方法</h4><ul>
<li><code>Object.preventExtensions()</code>：防止对象扩展。</li>
<li><code>Object.isExtensible()</code>：判断对象是否可扩展。</li>
<li><code>Object.seal()</code>：禁止对象配置。</li>
<li><code>Object.isSealed()</code>：判断一个对象是否可配置。</li>
<li><code>Object.freeze()</code>：冻结一个对象。</li>
<li><code>Object.isFrozen()</code>：判断一个对象是否被冻结。</li>
</ul>
<h4 id="（3）原型链相关方法"><a href="#（3）原型链相关方法" class="headerlink" title="（3）原型链相关方法"></a>（3）原型链相关方法</h4><ul>
<li><code>Object.create()</code>：该方法可以指定原型对象和属性，返回一个新的对象。</li>
<li><code>Object.getPrototypeOf()</code>：获取对象的<code>Prototype</code>对象。</li>
</ul>
<p>、</p>
<p>有部分方法为列入此文档，更多方法详情：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object</a></p>
<h2 id="5、Object-的实例方法"><a href="#5、Object-的实例方法" class="headerlink" title="5、Object 的实例方法"></a>5、Object 的实例方法</h2><p>除了静态方法，还有不少方法定义在<code>Object.prototype</code>对象。它们称为实例方法，所有<code>Object</code>的实例对象都继承了这些方法。</p>
<p><code>Object</code>实例对象的方法，主要有以下六个。</p>
<ul>
<li><code>Object.prototype.valueOf()</code>：返回当前对象对应的值。</li>
<li><code>Object.prototype.toString()</code>：返回当前对象对应的字符串形式。</li>
<li><code>Object.prototype.toLocaleString()</code>：返回当前对象对应的本地字符串形式。</li>
<li><code>Object.prototype.hasOwnProperty()</code>：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。</li>
<li><code>Object.prototype.isPrototypeOf()</code>：判断当前对象是否为另一个对象的原型。</li>
<li><code>Object.prototype.propertyIsEnumerable()</code>：判断某个属性是否可枚举。</li>
</ul>
<p>本节介绍前四个方法，另外两个方法将在后文相关章节介绍。</p>
<h3 id="Object-prototype-valueOf"><a href="#Object-prototype-valueOf" class="headerlink" title="Object.prototype.valueOf()"></a>Object.prototype.valueOf()</h3><p><code>valueOf</code>方法的作用是返回一个对象的“值”，默认情况下<strong>返回对象本身</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">obj.<span class="title function_">valueof</span>() === obj <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>上面代码比较<code>obj.valueOf()</code>与<code>obj</code>本身，两者是一样的。</p>
<p><code>valueOf</code>方法的主要用途是，JavaScript <strong>自动类型转换</strong>时会默认调用这个方法（详见《数据类型转换》一章）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>()</span><br><span class="line"><span class="number">1</span>+obj <span class="comment">//&quot;1[object Object]&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码将对象<code>obj</code>与数字<code>1</code>相加，这时 JavaScript 就会<strong>自动调用</strong><code>valueOf()</code>方法，求出<code>obj</code>的值再与<code>1</code>相加。所以，如果自定义<code>valueOf</code>方法，就可以得到想要的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">obj.<span class="property">valueof</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span> + obj <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>上面代码自定义了<code>obj</code>对象的<code>valueOf</code>方法，于是<code>1 + obj</code>就得到了<code>3</code>。这种方法就相当于用自定义的<code>obj.valueOf</code>，覆盖<code>Object.prototype.valueOf</code>。</p>
<h3 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString()"></a>Object.prototype.toString()</h3><p><code>toString</code>方法的作用是返回一个对象的字符串形式，默认情况下<strong>返回类型字符串</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">o1.<span class="title function_">toString</span>() <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = &#123;<span class="attr">a</span>:<span class="number">2</span>&#125;</span><br><span class="line">o2.<span class="title function_">toString</span>() <span class="comment">// &quot;[object Object]&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，对于一个对象调用<code>toString</code>方法，会返回字符串<code>[object Object]</code>，该字符串说明对象的类型。</p>
<p>字符串<code>[object Object]</code>本身没有太大的用处，但是通过自定义<code>toString</code>方法，可以让对象在自动类型转换时，得到想要的字符串形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line"></span><br><span class="line">obj.<span class="property">toString</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">obj + <span class="string">&#x27; &#x27;</span>+ <span class="string">&#x27;world&#x27;</span> <span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，当对象用于字符串加法时，会<strong>自动调用</strong><code>toString</code>方法。由于自定义了<code>toString</code>方法，所以返回字符串<code>hello world</code>。</p>
<p>数组、字符串、函数、Date 对象都分别部署了自定义的<code>toString</code>方法，覆盖了<code>Object.prototype.toString</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">toString</span>() <span class="comment">// &quot;1,2,3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;123&#x27;</span>.<span class="title function_">toString</span>() <span class="comment">// &quot;123&quot;</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;).<span class="title function_">toString</span>()</span><br><span class="line"><span class="comment">// &quot;function () &#123;</span></span><br><span class="line"><span class="comment">//   return 123;</span></span><br><span class="line"><span class="comment">// &#125;&quot;</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">toString</span>()</span><br><span class="line"><span class="comment">// &quot;Tue May 10 2016 09:11:31 GMT+0800 (CST)&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，数组、字符串、函数、Date 对象调用<code>toString</code>方法，并不会返回<code>[object Object]</code>，因为它们都自定义了<code>toString</code>方法，覆盖原始方法。</p>
<h4 id="toString-的应用：判断数据类型"><a href="#toString-的应用：判断数据类型" class="headerlink" title="toString() 的应用：判断数据类型"></a>toString() 的应用：判断数据类型</h4><p><code>Object.prototype.toString</code>方法返回对象的类型字符串，因此可以用来判断一个值的类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj.toString() // &quot;[object Object]&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码调用空对象的<code>toString</code>方法，结果返回一个字符串<code>object Object</code>，其中第二个<code>Object</code>表示该值的构造函数。这是一个十分有用的判断数据类型的方法。</p>
<p>由于实例对象可能会自定义<code>toString</code>方法，覆盖掉<code>Object.prototype.toString</code>方法，所以为了得到类型字符串，最好直接使用<code>Object.prototype.toString</code>方法。通过函数的<code>call</code>方法，可以在任意值上调用这个方法，帮助我们判断这个值的类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.prototype.toString.call(value)</span><br></pre></td></tr></table></figure>

<p>上面代码表示对<code>value</code>这个值调用<code>Object.prototype.toString</code>方法。</p>
<p>不同数据类型的<code>Object.prototype.toString</code>方法返回值如下。</p>
<ul>
<li>数值：返回<code>[object Number]</code>。</li>
<li>字符串：返回<code>[object String]</code>。</li>
<li>布尔值：返回<code>[object Boolean]</code>。</li>
<li>undefined：返回<code>[object Undefined]</code>。</li>
<li>null：返回<code>[object Null]</code>。</li>
<li>数组：返回<code>[object Array]</code>。</li>
<li>arguments 对象：返回<code>[object Arguments]</code>。</li>
<li>函数：返回<code>[object Function]</code>。</li>
<li>Error 对象：返回<code>[object Error]</code>。</li>
<li>Date 对象：返回<code>[object Date]</code>。</li>
<li>RegExp 对象：返回<code>[object RegExp]</code>。</li>
<li>其他对象：返回<code>[object Object]</code>。</li>
</ul>
<p>这就是说，<code>Object.prototype.toString</code>可以看出一个值到底是什么类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">2</span>) <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>) <span class="comment">// &quot;[object Boolean]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">undefined</span>) <span class="comment">// &quot;[object Undefined]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>) <span class="comment">// &quot;[object Null]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="title class_">Math</span>) <span class="comment">// &quot;[object Math]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;&#125;) <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([]) <span class="comment">// &quot;[object Array]&quot;</span></span><br></pre></td></tr></table></figure>

<p>利用这个特性，可以写出一个比<code>typeof</code>运算符更准确的类型判断函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> type = <span class="keyword">function</span> (<span class="params">o</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> s = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(o)</span><br><span class="line">    <span class="keyword">return</span> s.<span class="title function_">match</span>(<span class="regexp">/\[object (.*?)\]/</span>)[<span class="number">1</span>].<span class="title function_">toLowerCase</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">type</span>(&#123;&#125;); <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="title function_">type</span>([]); <span class="comment">// &quot;array&quot;</span></span><br><span class="line"><span class="title function_">type</span>(<span class="number">5</span>); <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="title function_">type</span>(<span class="literal">null</span>); <span class="comment">// &quot;null&quot;</span></span><br><span class="line"><span class="title function_">type</span>(); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="title function_">type</span>(<span class="regexp">/abcd/</span>); <span class="comment">// &quot;regex&quot;</span></span><br><span class="line"><span class="title function_">type</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()); <span class="comment">// &quot;date&quot;</span></span><br></pre></td></tr></table></figure>

<p>在上面这个<code>type</code>函数的基础上，还可以加上专门判断某种类型数据的方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> type = <span class="keyword">function</span> (<span class="params">o</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> s = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(o);</span><br><span class="line">  <span class="keyword">return</span> s.<span class="title function_">match</span>(<span class="regexp">/\[object (.*?)\]/</span>)[<span class="number">1</span>].<span class="title function_">toLowerCase</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;Null&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Undefined&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Object&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Array&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;String&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Number&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Boolean&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Function&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;RegExp&#x27;</span></span><br><span class="line">].<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">t</span>) &#123;</span><br><span class="line">  type[<span class="string">&#x27;is&#x27;</span> + t] = <span class="keyword">function</span> (<span class="params">o</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">type</span>(o) === t.<span class="title function_">toLowerCase</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">type.<span class="title function_">isObject</span>(&#123;&#125;) <span class="comment">// true</span></span><br><span class="line">type.<span class="title function_">isNumber</span>(<span class="title class_">NaN</span>) <span class="comment">// true</span></span><br><span class="line">type.<span class="title function_">isRegExp</span>(<span class="regexp">/abc/</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="Object-prototype-toLocaleString"><a href="#Object-prototype-toLocaleString" class="headerlink" title="Object.prototype.toLocaleString()"></a>Object.prototype.toLocaleString()</h3><p><code>Object.prototype.toLocaleString</code>方法与<code>toString</code>的返回结果相同，也是返回一个值的字符串形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="title function_">toString</span>(obj) <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line">obj.<span class="title function_">toLocaleString</span>(obj) <span class="comment">// &quot;[object Object]&quot;</span></span><br></pre></td></tr></table></figure>

<p>这个方法的主要作用是留出一个接口，让各种不同的对象实现自己版本的<code>toLocaleString</code>，用来返回针对某些地域的特定的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">toString</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Henry Norman Bethune&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">toLocaleString</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;白求恩&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">toString</span>() <span class="comment">// Henry Norman Bethune</span></span><br><span class="line">person.<span class="title function_">toLocaleString</span>() <span class="comment">// 白求恩</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>toString()</code>方法返回对象的一般字符串形式，<code>toLocaleString()</code>方法返回本地的字符串形式。</p>
<p>目前，主要有三个对象自定义了<code>toLocaleString</code>方法。</p>
<ul>
<li>Array.prototype.toLocaleString()</li>
<li>Number.prototype.toLocaleString()</li>
<li>Date.prototype.toLocaleString()</li>
</ul>
<p>举例来说，日期的实例对象的<code>toString</code>和<code>toLocaleString</code>返回值就不一样，而且<code>toLocaleString</code>的返回值跟用户设定的所在地域相关。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">date.<span class="title function_">toString</span>() <span class="comment">// &quot;Sun Oct 06 2019 15:50:04 GMT+0800 (中国标准时间)&quot;</span></span><br><span class="line">date.<span class="title function_">toLocaleString</span>() <span class="comment">// &quot;2019/10/6 下午3:50:04&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Object-prototype-hasOwnProperty"><a href="#Object-prototype-hasOwnProperty" class="headerlink" title="Object.prototype.hasOwnProperty()"></a>Object.prototype.hasOwnProperty()</h3><p><code>Object.prototype.hasOwnProperty</code>方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性。</p>
<p><strong>检查对象是否包含有某个属性，返回布尔值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  p: 123</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.hasOwnProperty(&#x27;p&#x27;) // true</span><br><span class="line">obj.hasOwnProperty(&#x27;toString&#x27;) // false</span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>obj</code>自身具有<code>p</code>属性，所以返回<code>true</code>。<code>toString</code>属性是继承的，所以返回<code>false</code>。</p>
<h2 id="二、属性描述对象"><a href="#二、属性描述对象" class="headerlink" title="二、属性描述对象"></a>二、属性描述对象</h2><h2 id="1、概述-1"><a href="#1、概述-1" class="headerlink" title="1、概述"></a>1、概述</h2><p>JavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为“属性描述对象”（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。</p>
<p>下面是属性描述对象的一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">123</span>, <span class="comment">// 该属性的属性值，默认undefined</span></span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>, <span class="comment">// 属性值是否可改变，默认为true</span></span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="comment">// 该属性是否可遍历，默认为true</span></span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span>, <span class="comment">//属性描述对象的可配置性,默认为true</span></span><br><span class="line">  <span class="attr">get</span>: <span class="literal">undefined</span>, <span class="comment">// 该属性的取值函数（getter），默认为undefined</span></span><br><span class="line">  <span class="attr">set</span>: <span class="literal">undefined</span> <span class="comment">// 该属性的存值函数（setter），默认为undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>属性描述对象提供6个元属性。</p>
<p>（1）<code>value</code></p>
<p><code>value</code>是该属性的属性值，默认为<code>undefined</code>。</p>
<p>（2）<code>writable</code></p>
<p><code>writable</code>是一个布尔值，表示属性值（value）是否可改变（即是否可写），默认为<code>true</code>。</p>
<p>（3）<code>enumerable</code></p>
<p><code>enumerable</code>是一个布尔值，表示该属性是否可遍历，默认为<code>true</code>。如果设为<code>false</code>，会使得某些操作（比如<code>for...in</code>循环、<code>Object.keys()</code>）跳过该属性。</p>
<p>（4）<code>configurable</code></p>
<p><code>configurable</code>是一个布尔值，表示可配置性，默认为<code>true</code>。如果设为<code>false</code>，将阻止某些操作改写该属性，比如无法删除该属性，也不得改变该属性的属性描述对象（<code>value</code>属性除外）。也就是说，<code>configurable</code>属性控制了属性描述对象的可写性。</p>
<p>（5）<code>get</code></p>
<p><code>get</code>是一个函数，表示该属性的取值函数（getter），默认为<code>undefined</code>。</p>
<p>（6）<code>set</code></p>
<p><code>set</code>是一个函数，表示该属性的存值函数（setter），默认为<code>undefined</code>。</p>
<h2 id="2、Object-getOwnPropertyDescriptor"><a href="#2、Object-getOwnPropertyDescriptor" class="headerlink" title="2、Object.getOwnPropertyDescriptor()"></a>2、Object.getOwnPropertyDescriptor()</h2><p><code>Object.getOwnPropertyDescriptor()</code>方法可以<strong>获取属性描述对象</strong>。它的第一个参数是目标对象，第二个参数是一个字符串，对应目标对象的某个属性名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">p</span>:<span class="string">&#x27;a&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj,<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line"><span class="comment">// Object &#123; value: &quot;a&quot;,  // 属性值&#x27;a&#x27;</span></span><br><span class="line"><span class="comment">//   writable: true, // 属性值&#x27;a&#x27; 可改写</span></span><br><span class="line"><span class="comment">//   enumerable: true, // &#x27;p&#x27;属性可被遍历</span></span><br><span class="line"><span class="comment">//   configurable: true // 属性描述对象的可配置性</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// getOwnPropertyDescriptor 中文含义：获取自己的属性描述符</span></span><br></pre></td></tr></table></figure>

<p>注意，<code>Object.getOwnPropertyDescriptor()</code>方法只能用于对象自身的属性，不能用于继承的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="string">&#x27;a&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, <span class="string">&#x27;toString&#x27;</span>)</span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>toString</code>是<code>obj</code>对象继承的属性，<code>Object.getOwnPropertyDescriptor()</code>无法获取。</p>
<h2 id="3、Object-getOwnPropertyNames"><a href="#3、Object-getOwnPropertyNames" class="headerlink" title="3、Object.getOwnPropertyNames()"></a>3、Object.getOwnPropertyNames()</h2><p><code>Object.getOwnPropertyNames</code>方法返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历。</p>
<p><strong>返回对象的全部属性名</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">p1</span>: &#123; <span class="attr">value</span>: <span class="number">1</span>, <span class="attr">enumerable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  <span class="attr">p2</span>: &#123; <span class="attr">value</span>: <span class="number">2</span>, <span class="attr">enumerable</span>: <span class="literal">false</span> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(obj)</span><br><span class="line"><span class="comment">// [&quot;p1&quot;, &quot;p2&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>obj.p1</code>是可遍历的，<code>obj.p2</code>是不可遍历的。<code>Object.getOwnPropertyNames</code>会将它们都返回。</p>
<p>这跟<code>Object.keys</code>的行为不同，<code>Object.keys</code>只返回对象自身的可遍历属性的全部属性名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>([]) <span class="comment">// []</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>([]) <span class="comment">// [ &#x27;length&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// []</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"> <span class="comment">/*[</span></span><br><span class="line"><span class="comment">	&quot;constructor&quot;,   // 构造函数</span></span><br><span class="line"><span class="comment">    &quot;__defineGetter__&quot;,</span></span><br><span class="line"><span class="comment">    &quot;__defineSetter__&quot;,</span></span><br><span class="line"><span class="comment">    &quot;hasOwnProperty&quot;,  // 检测属性名</span></span><br><span class="line"><span class="comment">    &quot;__lookupGetter__&quot;,</span></span><br><span class="line"><span class="comment">    &quot;__lookupSetter__&quot;,</span></span><br><span class="line"><span class="comment">    &quot;isPrototypeOf&quot;,</span></span><br><span class="line"><span class="comment">    &quot;propertyIsEnumerable&quot;,</span></span><br><span class="line"><span class="comment">    &quot;toString&quot;,  // 返回类型字符串</span></span><br><span class="line"><span class="comment">    &quot;valueOf&quot;,</span></span><br><span class="line"><span class="comment">    &quot;__proto__&quot;,  // 原型链</span></span><br><span class="line"><span class="comment">    &quot;toLocaleString&quot;</span></span><br><span class="line"><span class="comment">   ]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，数组自身的<code>length</code>属性是不可遍历的，<code>Object.keys</code>不会返回该属性。第二个例子的<code>Object.prototype</code>也是一个对象，所有实例对象都会继承它，它自身的属性都是不可遍历的。</p>
<h2 id="4、Object-defineProperty-，Object-defineProperties"><a href="#4、Object-defineProperty-，Object-defineProperties" class="headerlink" title="4、Object.defineProperty()，Object.defineProperties()"></a>4、Object.defineProperty()，Object.defineProperties()</h2><p><code>Object.defineProperty()</code>方法允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象，它的用法如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(object, propertyName, attributesObject)</span><br></pre></td></tr></table></figure>

<p><code>Object.defineProperty</code>方法接受三个参数，依次如下。</p>
<ul>
<li>object：属性所在的对象</li>
<li>propertyName：字符串，表示属性名</li>
<li>attributesObject：属性描述对象</li>
</ul>
<p>举例来说，定义<code>obj.p</code>可以写成下面这样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(&#123;&#125;, <span class="string">&#x27;p&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>, <span class="comment">// 设置为false，无法被改写</span></span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="comment">// 可遍历</span></span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span> <span class="comment">// 属性描述不可再被配置</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.<span class="property">p</span> <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">p</span> = <span class="number">246</span>; <span class="comment">// 由于writable为false,改写无效</span></span><br><span class="line">obj.<span class="property">p</span> <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.defineProperty()</code>方法定义了<code>obj.p</code>属性。由于属性描述对象的<code>writable</code>属性为<code>false</code>，所以<code>obj.p</code>属性不可写。注意，这里的<code>Object.defineProperty</code>方法的第一个参数是<code>&#123;&#125;</code>（一个新建的空对象），<code>p</code>属性直接定义在这个空对象上面，然后返回这个对象，这是<code>Object.defineProperty()</code>的常见用法。</p>
<p>如果属性已经存在，<code>Object.defineProperty()</code>方法相当于更新该属性的属性描述对象。</p>
<p>如果<strong>一次性定义或修改多个属性</strong>，可以使用<code>Object.defineProperties()</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">p1</span>: &#123; <span class="attr">value</span>: <span class="number">123</span>, <span class="attr">enumerable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  <span class="attr">p2</span>: &#123; <span class="attr">value</span>: <span class="string">&#x27;abc&#x27;</span>, <span class="attr">enumerable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  <span class="attr">p3</span>: &#123; <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">p1</span> + <span class="variable language_">this</span>.<span class="property">p2</span> &#125;,</span><br><span class="line">    <span class="attr">enumerable</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>:<span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.<span class="property">p1</span> <span class="comment">// 123</span></span><br><span class="line">obj.<span class="property">p2</span> <span class="comment">// &quot;abc&quot;</span></span><br><span class="line">obj.<span class="property">p3</span> <span class="comment">// &quot;123abc&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.defineProperties()</code>同时定义了<code>obj</code>对象的三个属性。其中，<code>p3</code>属性定义了取值函数<code>get</code>，即每次读取该属性，都会调用这个取值函数。</p>
<p><strong>注意</strong>，一旦定义了取值函数<code>get</code>（或存值函数<code>set</code>），就不能将<code>writable</code>属性设为<code>true</code>，或者同时定义<code>value</code>属性，否则会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;p&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="number">456</span>; &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// TypeError: Invalid property.</span></span><br><span class="line"><span class="comment">// A property cannot both have accessors and be writable or have a value</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;p&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="number">456</span>; &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// TypeError: Invalid property descriptor.</span></span><br><span class="line"><span class="comment">// Cannot both specify accessors and a value or writable attribute</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，同时定义了<code>get</code>属性和<code>value</code>属性，以及将<code>writable</code>属性设为<code>true</code>，就会报错。</p>
<p><code>Object.defineProperty()</code>和<code>Object.defineProperties()</code>参数里面的属性描述对象，<code>writable</code>、<code>configurable</code>、<code>enumerable</code>这三个属性的默认值都为<code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;foo&#x27;</span>, &#123;&#125;);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123;  // 默认值</span></span><br><span class="line"><span class="comment">//   value: undefined,</span></span><br><span class="line"><span class="comment">//   writable: false,</span></span><br><span class="line"><span class="comment">//   enumerable: false,</span></span><br><span class="line"><span class="comment">//   configurable: false</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，定义<code>obj.foo</code>时用了一个空的属性描述对象，就可以看到各个元属性的默认值。</p>
<h2 id="5、Object-prototype-propertyIsEnumerable"><a href="#5、Object-prototype-propertyIsEnumerable" class="headerlink" title="5、Object.prototype.propertyIsEnumerable()"></a>5、Object.prototype.propertyIsEnumerable()</h2><p>实例对象的<code>propertyIsEnumerable()</code>方法返回一个布尔值，用来<strong>判断某个属性是否可遍历</strong>。注意，这个方法只能用于判断对象自身的属性，对于继承的属性一律返回<code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="property">p</span> = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">propertyIsEnumerable</span>(<span class="string">&#x27;p&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">obj.<span class="title function_">propertyIsEnumerable</span>(<span class="string">&#x27;toString&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>obj.p</code>是可遍历的，而<code>obj.toString</code>是继承的属性。</p>
<h2 id="6、元属性"><a href="#6、元属性" class="headerlink" title="6、元属性"></a>6、元属性</h2><p>属性描述对象的各个属性称为“元属性”，因为它们可以看作是控制属性的属性。</p>
<h3 id="value目标属性的值"><a href="#value目标属性的值" class="headerlink" title="value目标属性的值"></a>value目标属性的值</h3><p><code>value</code>属性是目标属性的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="property">p</span> = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, <span class="string">&#x27;p&#x27;</span>).<span class="property">value</span></span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;p&#x27;</span>, &#123; <span class="attr">value</span>: <span class="number">246</span> &#125;);</span><br><span class="line">obj.<span class="property">p</span> <span class="comment">// 246</span></span><br></pre></td></tr></table></figure>

<p>上面代码是通过<code>value</code>属性，读取或改写<code>obj.p</code>的例子。</p>
<h3 id="writable可写性"><a href="#writable可写性" class="headerlink" title="writable可写性"></a>writable可写性</h3><p><code>writable</code>属性是一个布尔值，决定了目标属性的值（value）是否可以被改变。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">37</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.<span class="property">a</span> <span class="comment">// 37</span></span><br><span class="line">obj.<span class="property">a</span> = <span class="number">25</span>; <span class="comment">// 可写性为false，值无法被修改</span></span><br><span class="line">obj.<span class="property">a</span> <span class="comment">// 37</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>obj.a</code>的<code>writable</code>属性是<code>false</code>。然后，改变<code>obj.a</code>的值，不会有任何效果。</p>
<p><strong>注意</strong>，正常模式下，对<code>writable</code>为<code>false</code>的属性赋值不会报错，只会默默失败。但是，严格模式下会报错，即使对<code>a</code>属性重新赋予一个同样的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;use strict&#x27;;</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj, &#x27;a&#x27;, &#123;</span><br><span class="line">  value: 37,</span><br><span class="line">  writable: false</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.a = 37;</span><br><span class="line">// Uncaught TypeError: Cannot assign to read only property &#x27;a&#x27; of object</span><br></pre></td></tr></table></figure>

<p>上面代码是严格模式，对<code>obj.a</code>任何赋值行为都会报错。</p>
<p>如果原型对象的某个属性的<code>writable</code>为<code>false</code>，那么子对象将无法自定义这个属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proto = <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(&#123;&#125;, <span class="string">&#x27;foo&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(proto); <span class="comment">// obj对象继承proto对象</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">foo</span> = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">obj.<span class="property">foo</span> <span class="comment">// &#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>proto</code>是原型对象，它的<code>foo</code>属性不可写。<code>obj</code>对象继承<code>proto</code>，也不可以再自定义这个属性了。如果是严格模式，这样做还会抛出一个错误。</p>
<p>但是，有一个规避方法，就是通过覆盖属性描述对象，绕过这个限制。原因是这种情况下，原型链会被完全忽视。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proto = <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(&#123;&#125;, <span class="string">&#x27;foo&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(proto);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;foo&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;b&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.<span class="property">foo</span> <span class="comment">// &quot;b&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="enumerable可遍历性"><a href="#enumerable可遍历性" class="headerlink" title="enumerable可遍历性"></a>enumerable可遍历性</h3><p><code>enumerable</code>（可遍历性）返回一个布尔值，表示目标属性是否可遍历。</p>
<p>JavaScript 的早期版本，<code>for...in</code>循环是基于<code>in</code>运算符的。我们知道，<code>in</code>运算符不管某个属性是对象自身的还是继承的，都会返回<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>toString</code>不是<code>obj</code>对象自身的属性，但是<code>in</code>运算符也返回<code>true</code>，这导致了<code>toString</code>属性也会被<code>for...in</code>循环遍历。</p>
<p>这显然不太合理，后来就引入了“可遍历性”这个概念。只有可遍历的属性，才会被<code>for...in</code>循环遍历，同时还规定<code>toString</code>这一类实例对象继承的原生属性，都是不可遍历的，这样就保证了<code>for...in</code>循环的可用性。</p>
<p>具体来说，如果一个属性的<code>enumerable</code>为<code>false</code>，下面三个操作不会取到该属性。</p>
<ul>
<li><code>for..in</code>循环</li>
<li><code>Object.keys</code>方法</li>
<li><code>JSON.stringify</code>方法</li>
</ul>
<p>因此，<code>enumerable</code>可以用来设置“秘密”属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;x&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.<span class="property">x</span> <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)  <span class="comment">// []</span></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj) <span class="comment">// &quot;&#123;&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>obj.x</code>属性的<code>enumerable</code>为<code>false</code>，所以一般的遍历操作都无法获取该属性，使得它有点像“秘密”属性，但不是真正的私有属性，还是可以直接获取它的值。</p>
<p>注意，<code>for...in</code>循环包括继承的属性，<code>Object.keys</code>方法不包括继承的属性。如果需要获取对象自身的所有属性，不管是否可遍历，可以使用<code>Object.getOwnPropertyNames</code>方法。</p>
<p>另外，<code>JSON.stringify</code>方法会排除<code>enumerable</code>为<code>false</code>的属性，有时<strong>可以利用这一点。如果对象的 JSON 格式输出要排除某些属性，就可以把这些属性的<code>enumerable</code>设为<code>false</code>。</strong></p>
<h3 id="configurable可配置性"><a href="#configurable可配置性" class="headerlink" title="configurable可配置性"></a>configurable可配置性</h3><p><code>configurable</code>(可配置性）返回一个布尔值，决定了<strong>是否可以修改属性描述对象</strong>。也就是说，<code>configurable</code>为<code>false</code>时，<code>value</code>、<code>writable</code>、<code>enumerable</code>和<code>configurable</code>都不能被修改了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(&#123;&#125;, <span class="string">&#x27;p&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;p&#x27;</span>, &#123;<span class="attr">value</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="comment">// TypeError: Cannot redefine property: p</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;p&#x27;</span>, &#123;<span class="attr">writable</span>: <span class="literal">true</span>&#125;)</span><br><span class="line"><span class="comment">// TypeError: Cannot redefine property: p</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;p&#x27;</span>, &#123;<span class="attr">enumerable</span>: <span class="literal">true</span>&#125;)</span><br><span class="line"><span class="comment">// TypeError: Cannot redefine property: p</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;p&#x27;</span>, &#123;<span class="attr">configurable</span>: <span class="literal">true</span>&#125;)</span><br><span class="line"><span class="comment">// TypeError: Cannot redefine property: p</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>obj.p</code>的<code>configurable</code>为<code>false</code>。然后，改动<code>value</code>、<code>writable</code>、<code>enumerable</code>、<code>configurable</code>，结果都报错。</p>
<p><strong>注意</strong>，<code>writable</code>只有在<code>false</code>改为<code>true</code>会报错，<code>true</code>改为<code>false</code>是允许的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(&#123;&#125;, <span class="string">&#x27;p&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;p&#x27;</span>, &#123;<span class="attr">writable</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// 修改成功</span></span><br></pre></td></tr></table></figure>

<p>至于<code>value</code>，只要<code>writable</code>和<code>configurable</code>有一个为<code>true</code>，就允许改动。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(&#123;&#125;, <span class="string">&#x27;p&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(o1, <span class="string">&#x27;p&#x27;</span>, &#123;<span class="attr">value</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="comment">// 修改成功</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(&#123;&#125;, <span class="string">&#x27;p&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(o2, <span class="string">&#x27;p&#x27;</span>, &#123;<span class="attr">value</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="comment">// 修改成功</span></span><br></pre></td></tr></table></figure>

<p>另外，<code>writable</code>为<code>false</code>时，直接给目标属性赋值，不报错，但不会成功。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(&#123;&#125;, <span class="string">&#x27;p&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.<span class="property">p</span> = <span class="number">2</span>;</span><br><span class="line">obj.<span class="property">p</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>obj.p</code>的<code>writable</code>为<code>false</code>，对<code>obj.p</code>直接赋值不会生效。如果是严格模式，还会报错。</p>
<p>可配置性决定了目标属性是否可以被删除（delete）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">p1</span>: &#123; <span class="attr">value</span>: <span class="number">1</span>, <span class="attr">configurable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  <span class="attr">p2</span>: &#123; <span class="attr">value</span>: <span class="number">2</span>, <span class="attr">configurable</span>: <span class="literal">false</span> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">p1</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">p2</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">p1</span> <span class="comment">// undefined</span></span><br><span class="line">obj.<span class="property">p2</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>obj.p1</code>的<code>configurable</code>是<code>true</code>，所以可以被删除，<code>obj.p2</code>就无法删除。</p>
<h2 id="7、存取器（get和set）"><a href="#7、存取器（get和set）" class="headerlink" title="7、存取器（get和set）"></a>7、存取器（get和set）</h2><p>除了直接定义以外，属性还可以用存取器（accessor）定义。其中，存值函数称为<code>setter</code>，使用属性描述对象的<code>set</code>属性；取值函数称为<code>getter</code>，使用属性描述对象的<code>get</code>属性。</p>
<p><strong>一旦对目标属性定义了存取器，那么存取的时候，都将执行对应的函数</strong>。利用这个功能，可以实现许多高级特性，比如某个属性禁止赋值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(&#123;&#125;, <span class="string">&#x27;p&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 获取属性时执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;getter&#x27;</span> <span class="comment">// 这里相当于定义了p属性的值，如果设置了get则不能再设置value</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">value</span>) &#123; <span class="comment">// 设置属性时执行</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setter: &#x27;</span> + value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.<span class="property">p</span> <span class="comment">// &quot;getter&quot;</span></span><br><span class="line">obj.<span class="property">p</span> = <span class="number">123</span> <span class="comment">// &quot;setter: 123&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>obj.p</code>定义了<code>get</code>和<code>set</code>属性。<code>obj.p</code>取值时，就会调用<code>get</code>；赋值时，就会调用<code>set</code>。</p>
<p>JavaScript 还提供了存取器的<strong>另一种写法</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">p</span>()&#123; <span class="comment">// 相当于为obj对象创建一个p属性，并且赋值为‘getter’</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;getter&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ser <span class="title function_">p</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setter&#x27;</span>+value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的写法与定义属性描述对象是等价的，而且使用更广泛。</p>
<p>注意，取值函数<code>get</code>不能接受参数，存值函数<code>set</code>只能接受一个参数（即属性的值）。</p>
<p>存取器往往用于，属性的值依赖对象内部数据的场合。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj =&#123;</span><br><span class="line">  $n : <span class="number">5</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">next</span>() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$n</span>++ &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">next</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="variable language_">this</span>.<span class="property">$n</span>) <span class="variable language_">this</span>.<span class="property">$n</span> = n;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;新的值必须大于当前值&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">next</span> <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">next</span> = <span class="number">10</span>;</span><br><span class="line">obj.<span class="property">next</span> <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">next</span> = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// Uncaught Error: 新的值必须大于当前值</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>next</code>属性的存值函数和取值函数，都依赖于内部属性<code>$n</code>。</p>
<blockquote>
<p>vue框架就是通过存取器来实现的数据响应式</p>
</blockquote>
<h2 id="8、对象的拷贝"><a href="#8、对象的拷贝" class="headerlink" title="8、对象的拷贝"></a>8、对象的拷贝</h2><p>有时，我们需要将一个对象的所有属性，拷贝到另一个对象，可以用下面的方法实现。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> extend = <span class="keyword">function</span> (<span class="params">to, <span class="keyword">from</span></span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> property <span class="keyword">in</span> <span class="keyword">from</span>) &#123;</span><br><span class="line">        to[property] = <span class="keyword">from</span>[property]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> to</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">extend</span>(&#123;&#125;, &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;) <span class="comment">// &#123;a:1&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面这个方法的问题在于，如果遇到存取器定义的属性，会只拷贝到属性和值，并不能拷贝到存取器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extend(&#123;&#125;, &#123;</span><br><span class="line">  get a() &#123; return 1 &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// &#123;a: 1&#125;   // 这里并没有拷贝到get方法</span><br></pre></td></tr></table></figure>

<p>为了解决这个问题，我们可以通过<code>Object.defineProperty</code>方法来拷贝属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> extend = <span class="keyword">function</span> (<span class="params">to, <span class="keyword">from</span></span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> property <span class="keyword">in</span> <span class="keyword">from</span>)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(!<span class="keyword">from</span>.<span class="title function_">hasOwnProperty</span>()) <span class="keyword">continue</span> <span class="comment">//过滤继承属性 continue 终止本次循环，继续剩余循环</span></span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(</span><br><span class="line">            to,</span><br><span class="line">            property,</span><br><span class="line">            <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(<span class="keyword">from</span>,property)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> to</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">extend</span>(&#123;&#125;,&#123;<span class="keyword">get</span> <span class="title function_">a</span>()&#123;<span class="keyword">return</span> <span class="number">1</span>&#125;&#125;) <span class="comment">// &#123;get a()&#123;return 1&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>hasOwnProperty</code>那一行用来过滤掉继承的属性，否则可能会报错，因为<code>Object.getOwnPropertyDescriptor</code>读不到继承属性的属性描述对象。</p>
<h2 id="9、控制对象读写状态"><a href="#9、控制对象读写状态" class="headerlink" title="9、控制对象读写状态"></a>9、控制对象读写状态</h2><p>有时需要<strong>冻结对象的读写状态，防止对象被改变</strong>。</p>
<p>JavaScript 提供了三种冻结方法：</p>
<ul>
<li><p>最弱的一种是<code>Object.preventExtensions</code> (不能新增，但能被删除和修改)</p>
</li>
<li><p>其次是<code>Object.seal</code> (不能新增和删除，但能修改)</p>
</li>
<li><p>最强的是<code>Object.freeze</code> (不能新增、删除和修改)</p>
</li>
</ul>
<h3 id="Object-preventExtensions-防止新增"><a href="#Object-preventExtensions-防止新增" class="headerlink" title="Object.preventExtensions() 防止新增"></a>Object.preventExtensions() 防止新增</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(obj) <span class="comment">// prevent Extensions 中文： 防止扩展</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj,<span class="string">&#x27;p&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;) <span class="comment">// TypeError:cannot define property:p, object is not extensible</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">p</span> = <span class="number">1</span></span><br><span class="line">obj.<span class="property">p</span> <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>obj</code>对象经过<code>Object.preventExtensions</code>以后，就无法添加新属性了。</p>
<h3 id="Object-isExtensible-是可新增的？"><a href="#Object-isExtensible-是可新增的？" class="headerlink" title="Object.isExtensible() 是可新增的？"></a>Object.isExtensible() 是可新增的？</h3><p><code>Object.isExtensible</code>方法用于<strong>检查一个对象是否使用了<code>Object.preventExtensions</code>方法</strong>。也就是说，检查是否可以为一个对象添加属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(obj) <span class="comment">// true    is Extensible 中文： 是可扩展的？</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(obj)</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(obj) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，对<code>obj</code>对象使用<code>Object.preventExtensions</code>方法以后，再使用<code>Object.isExtensible</code>方法，返回<code>false</code>，表示已经不能添加新属性了。</p>
<h3 id="Object-seal-密封"><a href="#Object-seal-密封" class="headerlink" title="Object.seal() 密封"></a>Object.seal() 密封</h3><p><code>Object.seal</code>方法使得一个对象<strong>既无法添加新属性，也无法删除旧属性。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">p</span>: <span class="string">&#x27;hello&#x27;</span>&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">seal</span>(obj) <span class="comment">// seal 中文： 密封</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">p</span> <span class="comment">// 删除属性无效</span></span><br><span class="line">obj.<span class="property">p</span> <span class="comment">// hello</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">p</span> = <span class="string">&#x27;hi&#x27;</span> <span class="comment">// 可修改值</span></span><br><span class="line">obj.<span class="property">p</span> <span class="comment">// hi</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">x</span> = <span class="string">&#x27;world&#x27;</span> <span class="comment">// 新增属性无效</span></span><br><span class="line">obj.<span class="property">x</span> <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>obj</code>对象执行<code>Object.seal</code>方法以后，就无法添加新属性和删除旧属性了。</p>
<p><code>Object.seal</code>实质是把属性描述对象的<code>configurable</code>属性设为<code>false</code>，因此属性描述对象不再能改变了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">p</span>: <span class="string">&#x27;a&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line"><span class="comment">// Object &#123;</span></span><br><span class="line"><span class="comment">//   value: &quot;a&quot;,</span></span><br><span class="line"><span class="comment">//   writable: true,</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   configurable: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">seal</span>(obj)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line"><span class="comment">// Object &#123;</span></span><br><span class="line"><span class="comment">//   value: &quot;a&quot;,</span></span><br><span class="line"><span class="comment">//   writable: true,</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   configurable: false</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj,<span class="string">&#x27;p&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">enumerable</span>:</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// TypeError: Cannot redefine property: p</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，使用<code>Object.seal</code>方法之后，属性描述对象的<code>configurable</code>属性就变成了<code>false</code>，然后改变<code>enumerable</code>属性就会报错。</p>
<p><code>Object.seal</code>只是禁止新增或删除属性，并不影响修改某个属性的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = &#123; p: &#x27;a&#x27; &#125;;</span><br><span class="line">Object.seal(obj);</span><br><span class="line">obj.p = &#x27;b&#x27;;</span><br><span class="line">obj.p // &#x27;b&#x27;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.seal</code>方法对<code>p</code>属性的<code>value</code>无效，是因为此时<code>p</code>属性的可写性由<code>writable</code>决定。</p>
<h3 id="Object-isSealed-是密封的？"><a href="#Object-isSealed-是密封的？" class="headerlink" title="Object.isSealed() 是密封的？"></a>Object.isSealed() 是密封的？</h3><p><code>Object.isSealed</code>方法用于<strong>检查一个对象是否使用了<code>Object.seal</code>方法</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">p</span>:<span class="string">&#x27;a&#x27;</span>&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">seal</span>(obj)</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">isSealed</span>(obj) <span class="comment">// true   is Sealed 中文： 是密封的？</span></span><br></pre></td></tr></table></figure>

<p>这时，<code>Object.isExtensible</code>方法也返回<code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="string">&#x27;a&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">seal</span>(obj);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(obj) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>isSealed为true，是密封的。isExtensible为false，不是可扩展的</p>
</blockquote>
<h3 id="Object-freeze-冻结"><a href="#Object-freeze-冻结" class="headerlink" title="Object.freeze() 冻结"></a>Object.freeze() 冻结</h3><p><code>Object.freeze</code>方法可以使得一个对象<strong>无法添加新属性、无法删除旧属性、也无法改变属性的值</strong>，使得这个对象实际上变成了常量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">p</span>:<span class="string">&#x27;hello&#x27;</span>&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(obj)</span><br><span class="line"></span><br><span class="line">obj.<span class="property">p</span> = <span class="string">&#x27;world&#x27;</span></span><br><span class="line">obj.<span class="property">p</span> <span class="comment">// hello</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">t</span> = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">obj.<span class="property">t</span> <span class="comment">// nudefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">p</span> <span class="comment">// false</span></span><br><span class="line">obj.<span class="property">p</span> <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，对<code>obj</code>对象进行<code>Object.freeze()</code>以后，修改属性、新增属性、删除属性都无效了。这些操作并不报错，只是默默地失败。如果在严格模式下，则会报错。</p>
<h3 id="Object-isFrozen-是冻结的？"><a href="#Object-isFrozen-是冻结的？" class="headerlink" title="Object.isFrozen() 是冻结的？"></a>Object.isFrozen() 是冻结的？</h3><p><code>Object.isFrozen</code>方法用于<strong>检查一个对象是否使用了<code>Object.freeze</code>方法。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">p</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(obj);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">isFrozen</span>(obj) <span class="comment">// true // 是冻结的</span></span><br></pre></td></tr></table></figure>



<p>使用<code>Object.freeze</code>方法以后，<code>Object.isSealed</code>将会返回<code>true</code>，<code>Object.isExtensible</code>返回<code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">p</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">isSealed</span>(obj) <span class="comment">// true // 是密封的</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(obj) <span class="comment">// false // 不是可扩展的</span></span><br></pre></td></tr></table></figure>

<p><code>Object.isFrozen</code>的一个<strong>用途</strong>是，确认某个对象没有被冻结后，再对它的属性赋值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">p</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="title class_">Object</span>.<span class="title function_">isFrozen</span>(obj)) &#123;</span><br><span class="line">  obj.<span class="property">p</span> = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，确认<code>obj</code>没有被冻结后，再对它的属性赋值，就不会报错了。</p>
<h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>上面的三个方法锁定对象的可写性有一个<strong>漏洞</strong>：<strong>可以通过改变原型对象，来为对象增加属性</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj); <span class="comment">// 获取原型对象</span></span><br><span class="line">proto.<span class="property">t</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">obj.<span class="property">t</span></span><br><span class="line"><span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>obj</code>本身不能新增属性，但是可以在它的原型对象上新增属性，就依然能够在<code>obj</code>上读到。</p>
<p>一种解决方案是，把<code>obj</code>的原型也冻结住。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(proto);</span><br><span class="line"></span><br><span class="line">proto.<span class="property">t</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">obj.<span class="property">t</span> <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p><strong>另外一个局限</strong>是，如果属性值是对象，上面这些方法只能冻结属性指向的对象，而不能冻结对象本身的内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">bar</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(obj);</span><br><span class="line"></span><br><span class="line">obj.<span class="property">bar</span>.<span class="title function_">push</span>(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">obj.<span class="property">bar</span> <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>obj.bar</code>属性指向一个数组，<code>obj</code>对象被冻结以后，这个指向无法改变，即无法指向其他值，但是所指向的数组是可以改变的。</p>
<h2 id="三、Array对象"><a href="#三、Array对象" class="headerlink" title="三、Array对象"></a>三、Array对象</h2><h2 id="1、Array构造函数"><a href="#1、Array构造函数" class="headerlink" title="1、Array构造函数"></a>1、Array构造函数</h2><p><code>Array</code>是 JavaScript 的原生对象，同时也是一个构造函数，可以用它生成新的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">2</span>); <span class="comment">// Array是原生对象，也是构造函数； 2表示生成2个成员</span></span><br><span class="line">arr.<span class="property">length</span> <span class="comment">// 2</span></span><br><span class="line">arr <span class="comment">// [ empty x 2 ]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Array</code>构造函数的参数<code>2</code>，表示生成一个两个成员的数组，每个位置都是空值。</p>
<p>如果没有使用<code>new</code>，运行结果也是一样的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="title class_">Array</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p><code>Array</code>构造函数有一个很大的<strong>缺陷</strong>，就是不同的参数，会导致它的行为不一致。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无参数时，返回一个空数组</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Array</span>() <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个正整数参数，表示返回的新数组的长度</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>) <span class="comment">// [ empty ]</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">2</span>) <span class="comment">// [ empty x 2 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非正整数的数值作为参数，会报错</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">3.2</span>) <span class="comment">// RangeError: Invalid array length</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Array</span>(-<span class="number">3</span>) <span class="comment">// RangeError: Invalid array length</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个非数值（比如字符串、布尔值、对象等）作为参数，</span></span><br><span class="line"><span class="comment">// 则该参数是返回的新数组的成员</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">// [&#x27;abc&#x27;]</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Array</span>([<span class="number">1</span>]) <span class="comment">// [Array[1]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多参数时，所有参数都是返回的新数组的成员</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// [1, 2]</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>可以看到，<code>Array</code>作为构造函数，行为很不一致。因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>注意，如果参数是一个正整数，返回数组的成员都是空位。虽然读取的时候返回<code>undefined</code>，但实际上该位置没有任何值。虽然可以取到<code>length</code>属性，但是取不到键名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> b = [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>];</span><br><span class="line"></span><br><span class="line">a.<span class="property">length</span> <span class="comment">// 3</span></span><br><span class="line">b.<span class="property">length</span> <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>] <span class="comment">// undefined</span></span><br><span class="line">b[<span class="number">0</span>] <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> a <span class="comment">// false  // in运算符用于数组时，前面的参数为数组索引</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> b <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>a</code>是一个长度为3的空数组，<code>b</code>是一个三个成员都是<code>undefined</code>的数组。读取键值的时候，<code>a</code>和<code>b</code>都返回<code>undefined</code>，但是<code>a</code>的键位都是空的，<code>b</code>的键位是有值的。</p>
<h2 id="2、静态方法"><a href="#2、静态方法" class="headerlink" title="2、静态方法"></a>2、静态方法</h2><h3 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h3><p><code>Array.isArray</code>方法返回一个布尔值，表示参数是否为数组。它可以弥补<code>typeof</code>运算符的不足。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">typeof</span> arr <span class="comment">// object // 使用typeof返回的是object</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr)<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>typeof</code>运算符只能显示数组的类型是<code>Object</code>，而<code>Array.isArray</code>方法可以识别数组。</p>
<h2 id="3、实例方法"><a href="#3、实例方法" class="headerlink" title="3、实例方法"></a>3、实例方法</h2><h3 id="valueOf-原数组，toString-转字符串"><a href="#valueOf-原数组，toString-转字符串" class="headerlink" title="valueOf() 原数组，toString() 转字符串"></a>valueOf() 原数组，toString() 转字符串</h3><p><code>valueOf</code>方法是一个所有对象都拥有的方法，表示对该对象求值。不同对象的<code>valueOf</code>方法不尽一致，数组的<code>valueOf</code>方法<strong>返回数组本身</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">arr.<span class="title function_">valueOf</span>() <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure>

<p><code>toString</code>方法也是对象的通用方法，数组的<code>toString</code>方法返回数组的字符串形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.<span class="title function_">toString</span>() <span class="comment">// &quot;1,2,3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]];</span><br><span class="line">arr.<span class="title function_">toString</span>() <span class="comment">// &quot;1,2,3,4,5,6&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="push-末尾添加，pop-删除末尾"><a href="#push-末尾添加，pop-删除末尾" class="headerlink" title="push() 末尾添加，pop() 删除末尾"></a>push() 末尾添加，pop() 删除末尾</h3><p><code>push</code>方法用于在数组的<strong>末端添加一个或多个元素</strong>，并返回添加新元素后的数组长度。注意，该方法会改变原数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[]</span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line">arr.<span class="title function_">push</span>(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// 2</span></span><br><span class="line">arr.<span class="title function_">push</span>(<span class="literal">true</span>,&#123;&#125;) <span class="comment">// 4</span></span><br><span class="line">arr <span class="comment">// [1,&#x27;a&#x27;,true,&#123;&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：push()方法 返回添加后的数组长度，会改变原数组</span></span><br></pre></td></tr></table></figure>

<p>上面代码使用<code>push</code>方法，往数组中添加了四个成员。</p>
<p><code>pop</code>方法用于<strong>删除数组的最后一个元素</strong>，并返回该元素。注意，该方法会改变原数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">arr.<span class="title function_">pop</span>() <span class="comment">// &#x27;c&#x27;  删除最后一个元素，并返回该元素</span></span><br><span class="line">arr <span class="comment">// [&#x27;a&#x27;,&#x27;b&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>对空数组使用<code>pop</code>方法，不会报错，而是返回<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[].<span class="title function_">pop</span>() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>



<p><code>push</code>和<code>pop</code>结合使用，就构成了“后进先出”的<strong>栈结构</strong>（stack）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">3</span>);</span><br><span class="line">arr.<span class="title function_">pop</span>();</span><br><span class="line">arr <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>3</code>是最后进入数组的，但是最早离开数组。</p>
<h3 id="unshift-首位添加-shift-删除首位"><a href="#unshift-首位添加-shift-删除首位" class="headerlink" title="unshift() 首位添加, shift() 删除首位"></a>unshift() 首位添加, shift() 删除首位</h3><p><code>unshift()</code>方法用于在数组的<strong>第一个位置添加元素</strong>，并返回添加新元素后的数组长度。注意，该方法会改变原数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line">a.<span class="title function_">unshift</span>(<span class="string">&#x27;x&#x27;</span>); <span class="comment">// 4</span></span><br><span class="line">a <span class="comment">// [&#x27;x&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><code>unshift()</code>方法可以接受多个参数，这些参数都会添加到目标数组头部。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span> ];</span><br><span class="line">arr.<span class="title function_">unshift</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>) <span class="comment">// 4</span></span><br><span class="line">arr <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27; ]</span></span><br></pre></td></tr></table></figure>



<p><code>shift()</code>方法用于<strong>删除数组的第一个元素</strong>，并返回该元素。注意，该方法会改变原数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">a.<span class="title function_">shift</span>() <span class="comment">// &#x27;a&#x27; 删除第一个元素，并返回该元素</span></span><br><span class="line">a <span class="comment">// [&#x27;b&#x27;,&#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，使用<code>shift()</code>方法以后，原数组就变了。</p>
<p><code>shift()</code>方法可以遍历并清空一个数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (item = list.<span class="title function_">shift</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<p>上面代码通过<code>list.shift()</code>方法每次取出一个元素，从而遍历数组。它的前提是数组元素不能是<code>0</code>或任何布尔值等于<code>false</code>的元素，因此<strong>这样的遍历不是很可靠</strong>。</p>
<p><code>push()</code>和<code>shift()</code>结合使用，就构成了“先进先出”的<strong>队列(堆)结构</strong>（queue）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> queue = []</span><br><span class="line">queue.<span class="title function_">push</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">queue.<span class="title function_">push</span>(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">queue.<span class="title function_">push</span>(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">queue.<span class="title function_">shift</span>()</span><br><span class="line">queue <span class="comment">// [&#x27;2&#x27;,&#x27;3&#x27;]</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>push() 最后位置添加元素，unshift() 第一位置添加元素</p>
<p>pop() 删除最后一个元素，shift() 删除第一个元素</p>
</blockquote>
<h3 id="join-连接每个成员-转字符串"><a href="#join-连接每个成员-转字符串" class="headerlink" title="join() 连接每个成员-转字符串"></a>join() 连接每个成员-转字符串</h3><p><code>join()</code>方法以指定参数作为分隔符，<strong>将所有数组成员连接为一个字符串返回</strong>。如果不提供参数，默认用逗号分隔。</p>
<p><strong>数组转字符串</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">a.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// &#x27;1234&#x27;</span></span><br><span class="line">a.<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>) <span class="comment">// &#x27;1 2 3 4&#x27;</span></span><br><span class="line">a.<span class="title function_">join</span>(<span class="string">&#x27;|&#x27;</span>) <span class="comment">// &#x27;1|2|3|4‘</span></span><br><span class="line">a.<span class="title function_">join</span>() <span class="comment">// &#x27;1,2,3,4&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果数组成员是<code>undefined</code>或<code>null</code>或空位，会被转成空字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="literal">undefined</span>, <span class="literal">null</span>].<span class="title function_">join</span>(<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line"><span class="comment">// &#x27;#&#x27;</span></span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>,, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">join</span>(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"><span class="comment">// &#x27;a--b&#x27;</span></span><br></pre></td></tr></table></figure>

<p>通过<code>call</code>方法，这个方法也可以用于字符串或类似数组的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">join</span>.<span class="title function_">call</span>(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;h-e-l-l-o&quot;</span></span><br><span class="line"><span class="comment">// 等价 &#x27;hello&#x27;.split(&#x27;&#x27;).join(&#x27;-&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>, <span class="attr">length</span>: <span class="number">2</span> &#125;; <span class="comment">// 数组的变形对象</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">join</span>.<span class="title function_">call</span>(obj, <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"><span class="comment">// &#x27;a-b&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="concat-合并数组"><a href="#concat-合并数组" class="headerlink" title="concat() 合并数组"></a>concat() 合并数组</h3><p><code>concat</code>方法用于<strong>多个数组的合并</strong>。它将新数组的成员，添加到原数组成员的后部，然后<strong>返回一个新数组，原数组不变</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;hello&#x27;</span>].<span class="title function_">concat</span>([<span class="string">&#x27;world&#x27;</span>])</span><br><span class="line"><span class="comment">// [&#x27;hello&#x27;,&#x27;world&#x27;]</span></span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;hello&#x27;</span>].<span class="title function_">concat</span>([<span class="string">&#x27;world&#x27;</span>],[<span class="string">&#x27;!&#x27;</span>])</span><br><span class="line"><span class="comment">// [&quot;hello&quot;, &quot;world&quot;, &quot;!&quot;]</span></span><br><span class="line"></span><br><span class="line">[].<span class="title function_">concat</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="comment">// [&#123; a: 1 &#125;, &#123; b: 2 &#125;]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>].<span class="title function_">concat</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="comment">// [2, &#123;a: 1&#125;]</span></span><br><span class="line"></span><br><span class="line">[].<span class="title function_">concat</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">// [1,2]</span></span><br></pre></td></tr></table></figure>

<p>除了数组作为参数，<code>concat</code>也接受其他类型的值作为参数，添加到目标数组尾部。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">concat</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<p>如果数组成员包括对象，<code>concat</code>方法返回当前数组的一个浅拷贝。所谓“<strong>浅拷贝</strong>”，指的是新数组拷贝的是对象的引用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> oldArray = [obj]; <span class="comment">// 浅拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newArray = oldArray.<span class="title function_">concat</span>();</span><br><span class="line"></span><br><span class="line">obj.<span class="property">a</span> = <span class="number">2</span>; <span class="comment">// 改变原对象以后，新数组跟着改变</span></span><br><span class="line">newArray[<span class="number">0</span>].<span class="property">a</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，原数组包含一个对象，<code>concat</code>方法生成的新数组包含这个对象的引用。所以，<strong>改变原对象以后，新数组跟着改变</strong>。</p>
<h3 id="reverse-反转"><a href="#reverse-反转" class="headerlink" title="reverse() 反转"></a>reverse() 反转</h3><p><code>reverse</code>方法用于<strong>颠倒排列数组元素</strong>，返回改变后的数组。注意，该方法将<strong>改变原数组</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">a.<span class="title function_">reverse</span>() <span class="comment">// [4,3,2,1]</span></span><br><span class="line">a <span class="comment">// [4,3,2,1]</span></span><br></pre></td></tr></table></figure>



<h3 id="slice-部分-提取部分成员"><a href="#slice-部分-提取部分成员" class="headerlink" title="slice() 部分-提取部分成员"></a>slice() 部分-提取部分成员</h3><p><code>slice</code>方法用于<strong>提取目标数组的一部分</strong>，返回一个新数组，<strong>原数组不变</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">slice</span>(start, end);</span><br></pre></td></tr></table></figure>

<p>它的第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">a.<span class="title function_">slice</span>(<span class="number">0</span>) <span class="comment">// [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;] 从0到最后一个成员</span></span><br><span class="line">a.<span class="title function_">slice</span>(<span class="number">1</span>) <span class="comment">// [&#x27;b&#x27;,&#x27;c&#x27;] 从1到最后一个成员</span></span><br><span class="line">a.<span class="title function_">slice</span>(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// [&#x27;b&#x27;] 从1到2成员，不包含2成员</span></span><br><span class="line">a.<span class="title function_">slice</span>(<span class="number">2</span>,<span class="number">6</span>) <span class="comment">// [&#x27;c&#x27;] 从2到6成员，超出的不计算在内</span></span><br><span class="line">a.<span class="title function_">slice</span>() <span class="comment">//[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;] 无参数，默认全部，多用于拷贝数组到新的数组</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，最后一个例子<code>slice</code>没有参数，实际上等于返回一个原数组的拷贝。</p>
<p>如果<code>slice</code>方法的参数是<strong>负数</strong>，则表示<strong>倒数计算的位置</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">a.<span class="title function_">slice</span>(-<span class="number">2</span>) <span class="comment">// [&quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line">a.<span class="title function_">slice</span>(-<span class="number">2</span>, -<span class="number">1</span>) <span class="comment">// [&quot;b&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>-2</code>表示倒数计算的第二个位置，<code>-1</code>表示倒数计算的第一个位置。</p>
<p>如果<strong>第一个参数大于等于数组长度</strong>，或者<strong>第二个参数小于第一个参数</strong>，则<strong>返回空数组</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">a.<span class="title function_">slice</span>(<span class="number">4</span>) <span class="comment">// []</span></span><br><span class="line">a.<span class="title function_">slice</span>(<span class="number">2</span>, <span class="number">1</span>) <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<h4 id="应用-类数组转数组"><a href="#应用-类数组转数组" class="headerlink" title="应用-类数组转数组"></a>应用-类数组转数组</h4><p>slice&#96;方法的<strong>一个重要应用</strong>，是<strong>将类似数组的对象转为真正的数组</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(&#123; <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>, <span class="attr">length</span>: <span class="number">2</span> &#125;)</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;div&quot;</span>));</span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码的参数都不是数组，但是通过<code>call</code>方法，在它们上面调用<code>slice</code>方法，就可以把它们转为真正的数组。</p>
<h3 id="splice-从第几个开始，删除几个，并添加成员，返回被删除成员。"><a href="#splice-从第几个开始，删除几个，并添加成员，返回被删除成员。" class="headerlink" title="splice()  从第几个开始，删除几个，并添加成员，返回被删除成员。"></a>splice()  从第几个开始，删除几个，并添加成员，返回被删除成员。</h3><p><code>splice</code>方法用于<strong>删除原数组的一部分成员</strong>，<strong>并可以在删除的位置添加新的数组成员</strong>，<strong>返回值是被删除的元素</strong>。注意，该方法会<strong>改变原数组</strong>。</p>
<blockquote>
<p>也可以不删除成员同时在指定位置添加新成员</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">splice</span>(start, count, addElement1, addElement2, ...);</span><br><span class="line"><span class="comment">// 第几个开始，删除几个，加入的新成员...(非必需）</span></span><br></pre></td></tr></table></figure>

<p><code>splice</code>的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">a.<span class="title function_">splice</span>(<span class="number">2</span>,<span class="number">2</span>) <span class="comment">// [3,4] 返回被删除成员</span></span><br><span class="line">a.[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure>

<p>上面代码从原数组2号位置，删除了2个数组成员。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>];</span><br><span class="line">a.<span class="title function_">splice</span>(<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">// [&quot;e&quot;, &quot;f&quot;]</span></span><br><span class="line">a <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, 1, 2]</span></span><br></pre></td></tr></table></figure>

<p>上面代码从原数组4号位置删除2个成员，并插入了[1 , 2]新成员。</p>
<p>起始位置如果是负数，就表示从倒数位置开始删除。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>];</span><br><span class="line">a.<span class="title function_">splice</span>(-<span class="number">4</span>, <span class="number">2</span>) <span class="comment">// [&quot;c&quot;, &quot;d&quot;] 负数表示倒数</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，从倒数第四个位置<code>c</code>开始删除两个成员。</p>
<p>如果只是单纯地插入元素，<code>splice</code>方法的第二个参数可以设为<code>0</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">a.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>) <span class="comment">// [] // 不删除成员，并加入新成员到指定位置</span></span><br><span class="line">a <span class="comment">// [1, &#x27;a&#x27;, 1, 1]</span></span><br></pre></td></tr></table></figure>

<h4 id="应用-拆分数组"><a href="#应用-拆分数组" class="headerlink" title="应用-拆分数组"></a>应用-拆分数组</h4><p>如果只提供第一个参数，等同于将原数组在指定位置<strong>拆分成两个数组</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> a2 = a.<span class="title function_">splice</span>(<span class="number">2</span>) <span class="comment">// [3, 4]</span></span><br><span class="line">a <span class="comment">// [1, 2]</span></span><br><span class="line">a2 <span class="comment">// [3, 4]</span></span><br></pre></td></tr></table></figure>



<h3 id="sort-排序"><a href="#sort-排序" class="headerlink" title="sort() 排序"></a>sort() 排序</h3><p><code>sort</code>方法对数组成员进行排序，默认是按照<strong>字典顺序排序</strong>。排序后，将<strong>改变原数组</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>].<span class="title function_">sort</span>()</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>].<span class="title function_">sort</span>()</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;ba&#x27;</span>,<span class="string">&#x27;ea&#x27;</span>,<span class="string">&#x27;ae&#x27;</span>].<span class="title function_">sort</span>()</span><br><span class="line"><span class="comment">// [&quot;abc&quot;, &quot;ae&quot;, &quot;ba&quot;, &quot;ea&quot;]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">11</span>, <span class="number">101</span>].<span class="title function_">sort</span>()</span><br><span class="line"><span class="comment">// [101, 11]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">10111</span>, <span class="number">1101</span>, <span class="number">111</span>].<span class="title function_">sort</span>()</span><br><span class="line"><span class="comment">// [10111, 1101, 111]</span></span><br></pre></td></tr></table></figure>

<p>上面代码的最后三个例子，需要特殊注意。<code>sort()</code>方法不是按照大小排序，而是<strong>按照字典顺序</strong>。也就是说，数值会被先转成字符串，再按照字典顺序进行比较，所以<code>101</code>排在<code>11</code>的前面。</p>
<blockquote>
<p>先转成字符串，再从0位置开始对比对应位置上的值的顺序</p>
</blockquote>
<p>如果想让<code>sort</code>方法按照自定义方式排序，可以传入一个函数作为参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">10111</span>, <span class="number">1101</span>, <span class="number">111</span>].<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">a, b</span>) &#123; <span class="comment">// 返回值大于0,则a排于b之后，否则反之。</span></span><br><span class="line">  <span class="keyword">return</span> a - b; <span class="comment">// 升序</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// [111, 1101, 10111]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">10111</span>, <span class="number">1101</span>, <span class="number">111</span>].<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> b - a; <span class="comment">// 降序</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// [10111，1101, 111]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>sort</code>的参数函数本身接受两个参数，表示进行比较的两个数组成员。如果该函数的返回值大于<code>0</code>，表示第一个成员排在第二个成员后面；其他情况下，都是第一个元素排在第二个元素前面。</p>
<h4 id="应用-自定义排序"><a href="#应用-自定义排序" class="headerlink" title="应用-自定义排序"></a>应用-自定义排序</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;李四&quot;</span>, <span class="attr">age</span>: <span class="number">24</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;王五&quot;</span>, <span class="attr">age</span>: <span class="number">28</span>  &#125;</span><br><span class="line">].<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">o1, o2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> o1.<span class="property">age</span> - o2.<span class="property">age</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//   &#123; name: &quot;李四&quot;, age: 24 &#125;,</span></span><br><span class="line"><span class="comment">//   &#123; name: &quot;王五&quot;, age: 28  &#125;,</span></span><br><span class="line"><span class="comment">//   &#123; name: &quot;张三&quot;, age: 30 &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义排序</span></span><br><span class="line">[</span><br><span class="line">    &#123;<span class="attr">day</span>: <span class="string">&#x27;星期日&#x27;</span>&#125;, &#123;<span class="attr">day</span>:<span class="string">&#x27;星期一&#x27;</span>&#125;, &#123;<span class="attr">day</span>:<span class="string">&#x27;星期五&#x27;</span>&#125;</span><br><span class="line">].<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">o1,o2</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">computedDay</span>(o1.<span class="property">day</span>.<span class="title function_">charAt</span>(<span class="number">2</span>)) - <span class="title function_">computedDay</span>(o2.<span class="property">day</span>.<span class="title function_">charAt</span>(<span class="number">2</span>))</span><br><span class="line">&#125;) <span class="comment">//[&#123; day: &#x27;星期一&#x27; &#125;, &#123; day: &#x27;星期五&#x27; &#125;, &#123; day: &#x27;星期日&#x27; &#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">computedDay</span>(<span class="params">v</span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> v === <span class="string">&#x27;一&#x27;</span> ? <span class="number">1</span> : v === <span class="string">&#x27;二&#x27;</span> ? <span class="number">2</span> : v === <span class="string">&#x27;三&#x27;</span> ? <span class="number">3</span> : v === <span class="string">&#x27;四&#x27;</span> ? <span class="number">4</span> : v === <span class="string">&#x27;五&#x27;</span> ? <span class="number">5</span> : v === <span class="string">&#x27;六&#x27;</span> ? <span class="number">6</span> : <span class="number">7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，<strong>自定义的排序函数应该返回数值</strong>，否则不同的浏览器可能有不同的实现，不能保证结果都一致。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">6</span>].<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a &gt; b) <span class="comment">// 返回布尔值，不推荐</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">6</span>].<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b) <span class="comment">// 返回数值，推荐</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，前一种排序算法返回的是布尔值，这是不推荐使用的。后一种是数值，才是更好的写法。</p>
<h3 id="map-映射-每个成员-并返回"><a href="#map-映射-每个成员-并返回" class="headerlink" title="map() 映射 每个成员 并返回"></a>map() 映射 每个成员 并返回</h3><p><code>map</code>方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。<strong>不改变原数组</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">numbers.<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">numbers</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>numbers</code>数组的所有成员依次执行参数函数，运行结果组成一个新数组返回，原数组没有变化。</p>
<p><code>map</code>方法接受一个函数作为参数。该函数调用时，<code>map</code>方法向它传入三个参数：<strong>当前成员</strong>、<strong>当前索引</strong>、<strong>数组本身</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">elem, index, arr</span>) &#123; <span class="comment">// 当前成员、当前索引、数组本身</span></span><br><span class="line">  <span class="keyword">return</span> elem * index;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [0, 2, 6]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>map</code>方法的回调函数有三个参数，<code>elem</code>为当前成员的值，<code>index</code>为当前成员的索引，<code>arr</code>为原数组（<code>[1, 2, 3]</code>）。</p>
<p><code>map</code>方法还可以接受第二个参数，用来绑定回调函数内部的<code>this</code>变量（详见《this 变量》一章）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>[e]; <span class="comment">// this指向arr</span></span><br><span class="line">&#125;, arr) <span class="comment">// 使内部this指向arr</span></span><br><span class="line"><span class="comment">// [&#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码通过<code>map</code>方法的第二个参数，将回调函数内部的<code>this</code>对象，指向<code>arr</code>数组。</p>
<p>如果数组有空位，<code>map</code>方法的回调函数在这个位置不会执行，会跳过数组的空位。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params">n</span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">2</span>].<span class="title function_">map</span>(f) <span class="comment">// [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;]</span></span><br><span class="line">[<span class="number">1</span>, <span class="literal">null</span>, <span class="number">2</span>].<span class="title function_">map</span>(f) <span class="comment">// [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;]</span></span><br><span class="line">[<span class="number">1</span>, , <span class="number">2</span>].<span class="title function_">map</span>(f) <span class="comment">// [&quot;a&quot;, , &quot;a&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>map</code>方法不会跳过<code>undefined</code>和<code>null</code>，但是会跳过空位。</p>
<h3 id="forEach-循环每个成员"><a href="#forEach-循环每个成员" class="headerlink" title="forEach() 循环每个成员"></a>forEach() 循环每个成员</h3><p><code>forEach</code>方法与<code>map</code>方法很相似，也是对数组的所有成员依次执行参数函数。但是，<code>forEach</code>方法<strong>不返回值</strong>，<strong>只用来操作数据</strong>。这就是说，如果数组遍历的目的是为了得到返回值，那么使用<code>map</code>方法，否则使用<code>forEach</code>方法。</p>
<p><code>forEach</code>的用法与<code>map</code>方法一致，参数是一个函数，该函数同样接受三个参数：<strong>当前成员、当前索引、整个数组</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">element, index, array</span>) &#123;  <span class="comment">// 当前成员、当前索引、数组本身</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;[&#x27;</span> + index + <span class="string">&#x27;] = &#x27;</span> + element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>].<span class="title function_">forEach</span>(log);</span><br><span class="line"><span class="comment">// [0] = 2</span></span><br><span class="line"><span class="comment">// [1] = 5</span></span><br><span class="line"><span class="comment">// [2] = 9</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>forEach</code>遍历数组不是为了得到返回值，而是为了在屏幕输出内容，所以不必使用<code>map</code>方法。</p>
<p><code>forEach</code>方法也可以接受第二个参数，绑定参数函数的<code>this</code>变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> out = [];</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">elem</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">push</span>(elem * elem); <span class="comment">// this指向为out</span></span><br><span class="line">&#125;, out); <span class="comment">// 使内部this指向out</span></span><br><span class="line"></span><br><span class="line">out <span class="comment">// [1, 4, 9]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，空数组<code>out</code>是<code>forEach</code>方法的第二个参数，结果，回调函数内部的<code>this</code>关键字就指向<code>out</code>。</p>
<p>注意，<code>forEach</code>方法<strong>无法中断执行</strong>，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用<code>for</code>循环。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr[i] === <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，执行到数组的第二个成员时，就会中断执行。<code>forEach</code>方法做不到这一点。</p>
<p><code>forEach</code>方法也会跳过数组的空位。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> log = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n + <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">2</span>].<span class="title function_">forEach</span>(log)</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// NaN</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="literal">null</span>, <span class="number">2</span>].<span class="title function_">forEach</span>(log)</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1  // null+1 =&gt; 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, , <span class="number">2</span>].<span class="title function_">forEach</span>(log)</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>forEach</code>方法不会跳过<code>undefined</code>和<code>null</code>，但会跳过空位。</p>
<h3 id="filter-过滤"><a href="#filter-过滤" class="headerlink" title="filter() 过滤"></a>filter() 过滤</h3><p><code>filter</code>方法用于过滤数组成员，满足条件的成员组成一个新数组返回。</p>
<p>它的参数是一个函数，所有数组成员依次执行该函数，返回结果为<code>true</code>的成员组成一个新数组返回。</p>
<p>该方法<strong>不会改变原数组</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">elem</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> elem &gt; <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// [4,5]</span></span><br></pre></td></tr></table></figure>

<p>上面代码将大于<code>3</code>的数组成员，作为一个<strong>新数组返回</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="literal">false</span>];</span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">filter</span>(<span class="title class_">Boolean</span>)</span><br><span class="line"><span class="comment">// [1, &quot;a&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>filter</code>方法返回数组<code>arr</code>里面所有布尔值为<code>true</code>的成员。</p>
<p><code>filter</code>方法的参数函数可以接受三个参数<strong>：当前成员，当前位置、整个数组。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">elem, index, arr</span>) &#123; <span class="comment">// 当前成员，当前位置、整个数组</span></span><br><span class="line">  <span class="keyword">return</span> index % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [1, 3, 5]</span></span><br></pre></td></tr></table></figure>

<p>上面代码返回偶数位置的成员组成的新数组。</p>
<p><code>filter</code>方法还可以接受第二个参数，用来绑定参数函数内部的<code>this</code>变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">MAX</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> myFilter = <span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (item &gt; <span class="variable language_">this</span>.<span class="property">MAX</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// this指向obj</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>];</span><br><span class="line">arr.<span class="title function_">filter</span>(myFilter, obj) <span class="comment">// [8, 4, 9]  // 使myFilter内部this指向obj</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，过滤器<code>myFilter</code>内部有<code>this</code>变量，它可以被<code>filter</code>方法的第二个参数<code>obj</code>绑定，返回大于<code>3</code>的成员。</p>
<h3 id="some-某个，every-每个"><a href="#some-某个，every-每个" class="headerlink" title="some()某个，every()每个"></a>some()某个，every()每个</h3><p>这两个方法类似“<strong>断言</strong>”（assert），返回一个布尔值，表示判断数组成员是否符合某种条件。</p>
<p>它们接受一个函数作为参数，所有数组成员依次执行该函数。该函数接受三个参数：<strong>当前成员、当前位置、整个数组</strong>，然后<strong>返回一个布尔值</strong>。</p>
<p><code>some</code>方法是只要一个成员的返回值是<code>true</code>，则整个<code>some</code>方法的返回值就是<code>true</code>，否则返回<code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">arr.<span class="title function_">some</span>(<span class="keyword">function</span>(<span class="params">elem,index,arr</span>)&#123; <span class="comment">// 返回值中有一个为true则此方法返回true</span></span><br><span class="line">    <span class="keyword">return</span> elem &gt;= <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，如果数组<code>arr</code>有一个成员大于等于3，<code>some</code>方法就返回<code>true</code>。</p>
<p><code>every</code>方法是所有成员的返回值都是<code>true</code>，整个<code>every</code>方法才返回<code>true</code>，否则返回<code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.<span class="title function_">every</span>(<span class="keyword">function</span> (<span class="params">elem, index, arr</span>) &#123; <span class="comment">// 每个返回值都为true，此方法才返回true，否则返回false</span></span><br><span class="line">  <span class="keyword">return</span> elem &gt;= <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，数组<code>arr</code>并非所有成员大于等于<code>3</code>，所以返回<code>false</code>。</p>
<p>注意，对于空数组，<code>some</code>方法返回<code>false</code>，<code>every</code>方法返回<code>true</code>，回调函数都不会执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isEven</span>(<span class="params">x</span>) &#123; <span class="keyword">return</span> x % <span class="number">2</span> === <span class="number">0</span> &#125; <span class="comment">// 不会执行此函数</span></span><br><span class="line"></span><br><span class="line">[].<span class="title function_">some</span>(isEven) <span class="comment">// false</span></span><br><span class="line">[].<span class="title function_">every</span>(isEven) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>some</code>和<code>every</code>方法还可以接受第二个参数，用来绑定参数函数内部的<code>this</code>变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">MAX</span>:<span class="number">0</span>&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">elem</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> elem &gt; <span class="variable language_">this</span>.<span class="property">MAX</span> <span class="comment">// this指向obj</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">some</span>(fn,obj) <span class="comment">// true</span></span><br><span class="line">arr.<span class="title function_">every</span>(fn,obj) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h3 id="reduce-累计器，reduceRight-反向累计器"><a href="#reduce-累计器，reduceRight-反向累计器" class="headerlink" title="reduce() 累计器，reduceRight() 反向累计器"></a>reduce() 累计器，reduceRight() 反向累计器</h3><p><code>reduce</code>方法和<code>reduceRight</code>方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，<code>reduce</code>是从左到右处理（从第一个成员到最后一个成员），<code>reduceRight</code>则是从右到左（从最后一个成员到第一个成员），其他完全一样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">a,b,c,d</span>)&#123;</span><br><span class="line">    <span class="comment">// 记住a是默认是第一个成员，然后是上一次运算的返回值。</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a,b)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(c)</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1 2</span></span><br><span class="line"><span class="comment">// 3 3</span></span><br><span class="line"><span class="comment">// 6 4</span></span><br><span class="line"><span class="comment">// 10 5</span></span><br><span class="line"><span class="comment">// 最终结果 15</span></span><br></pre></td></tr></table></figure>

<p> 上面代码中，<code>reduce</code>方法求出数组所有成员的和。第一次执行，<code>a</code>是数组的第一个成员<code>1</code>，<code>b</code>是数组的第二个成员<code>2</code>。第二次执行，<code>a</code>为上一轮的返回值<code>3</code>，<code>b</code>为第三个成员<code>3</code>。第三次执行，<code>a</code>为上一轮的返回值<code>6</code>，<code>b</code>为第四个成员<code>4</code>。第四次执行，<code>a</code>为上一轮返回值<code>10</code>，<code>b</code>为第五个成员<code>5</code>。至此所有成员遍历完成，整个方法的返回值就是最后一轮的返回值<code>15</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">reduce</span>(<span class="title function_">callback</span>(accumulator, currentValue[, index[, array]])[, initialValue])</span><br><span class="line"><span class="comment">// 说明：中括号代表可选参数</span></span><br></pre></td></tr></table></figure>

<p><code>reduce</code>方法和<code>reduceRight</code>方法的第一个参数都是一个<code>callback</code>函数。该函数接受以下四个参数。</p>
<ol>
<li>累积变量，默认为数组的第一个成员</li>
<li>当前变量，默认为数组的第二个成员</li>
<li>当前位置（默认从1开始）, 如果提供了<code>initialValue</code>，则起始索引号为0，否则为1。 （可选）</li>
<li>原数组（可选）</li>
</ol>
<p><code>initialValue</code>可选</p>
<p>作为第一次调用 <code>callback函数时</code>的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。</p>
<p> 如果要对累积变量指定初值，可以把它放在<code>reduce</code>方法和<code>reduceRight</code>方法的第二个参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 25</span></span><br></pre></td></tr></table></figure>

<p>上面代码指定参数<code>a</code>的初值为10，所以数组从10开始累加，最终结果为25。注意，这时<code>b</code>是从数组的第一个成员开始遍历。</p>
<p>上面的第二个参数相当于设定了默认值，处理空数组时尤其有用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">prev, cur</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[].<span class="title function_">reduce</span>(add) <span class="comment">// 报错</span></span><br><span class="line"><span class="comment">// TypeError: Reduce of empty array with no initial value</span></span><br><span class="line">[].<span class="title function_">reduce</span>(add, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，由于空数组取不到初始值，<code>reduce</code>方法会报错。这时，加上第二个参数，就能保证总是会返回一个值。</p>
<p>下面是一个<code>reduceRight</code>方法的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">subtract</span>(<span class="params">prev, cur</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> prev - cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>].<span class="title function_">reduce</span>(subtract) <span class="comment">// 0</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>].<span class="title function_">reduceRight</span>(subtract) <span class="comment">// -4</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>reduce</code>方法相当于<code>3</code>减去<code>2</code>再减去<code>1</code>，<code>reduceRight</code>方法相当于<code>1</code>减去<code>2</code>再减去<code>3</code>。</p>
<h4 id="应用-找出字符最长的数组成员"><a href="#应用-找出字符最长的数组成员" class="headerlink" title="应用-找出字符最长的数组成员"></a>应用-找出字符最长的数组成员</h4><p>由于这两个方法会遍历数组，所以实际上还可以用来做一些遍历相关的操作。比如，找出字符长度最长的数组成员。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function findLongest(entries) &#123;</span><br><span class="line">  return entries.reduce(function (longest, entry) &#123;</span><br><span class="line">    return entry.length &gt; longest.length ? entry : longest;</span><br><span class="line">  &#125;, &#x27;&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">findLongest([&#x27;aaa&#x27;, &#x27;bb&#x27;, &#x27;c&#x27;]) // &quot;aaa&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>reduce</code>的参数函数会将字符长度较长的那个数组成员，作为累积值。这导致遍历所有成员之后，累积值就是字符长度最长的那个成员。</p>
<h4 id="应用-按属性对object分类"><a href="#应用-按属性对object分类" class="headerlink" title="应用-按属性对object分类"></a>应用-按属性对object分类</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> people = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;Max&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;Jane&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">groupBy</span>(<span class="params">objectArray, property</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> objectArray.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">acc, obj</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> key = obj[property];</span><br><span class="line">    <span class="keyword">if</span> (!acc[key]) &#123;<span class="comment">// 当&#123;&#125;中没有对应分类属性时，先创建改属性</span></span><br><span class="line">      acc[key] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    acc[key].<span class="title function_">push</span>(obj);</span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">  &#125;, &#123;&#125;); <span class="comment">// 初始值为&#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> groupedPeople = <span class="title function_">groupBy</span>(people, <span class="string">&#x27;age&#x27;</span>);</span><br><span class="line"><span class="comment">// groupedPeople is:</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   20: [</span></span><br><span class="line"><span class="comment">//     &#123; name: &#x27;Max&#x27;, age: 20 &#125;,</span></span><br><span class="line"><span class="comment">//     &#123; name: &#x27;Jane&#x27;, age: 20 &#125;</span></span><br><span class="line"><span class="comment">//   ],</span></span><br><span class="line"><span class="comment">//   21: [&#123; name: &#x27;Alice&#x27;, age: 21 &#125;]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>更多例子：&lt; <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce</a> &gt;</p>
<h3 id="indexOf-搜索成员第一个出现的位置，lastIndexOf-搜索成员最后出现的位置"><a href="#indexOf-搜索成员第一个出现的位置，lastIndexOf-搜索成员最后出现的位置" class="headerlink" title="indexOf() 搜索成员第一个出现的位置，lastIndexOf() 搜索成员最后出现的位置"></a>indexOf() 搜索成员第一个出现的位置，lastIndexOf() 搜索成员最后出现的位置</h3><p> <code>indexOf</code>方法返回<strong>给定元素在数组中第一次出现的位置</strong>，如果**没有则返回<code>-1</code>**。</p>
<p><strong>indexOf语法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">indexOf</span>(searchElement[, fromIndex = <span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">a.<span class="title function_">indexOf</span>(<span class="number">3</span>) <span class="comment">// 2   3在数组a中第一次出现的位置为2</span></span><br><span class="line">a.<span class="title function_">indexOf</span>(<span class="number">6</span>) <span class="comment">// -1  6在数组a中没有出现，返回-1</span></span><br></pre></td></tr></table></figure>



<p> <code>indexOf</code>方法还可以接受第二个参数，表示搜索的开始位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].<span class="title function_">indexOf</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>) <span class="comment">// -1 从1位置开始搜索a，没有搜索到</span></span><br></pre></td></tr></table></figure>

<p>上面代码从1号位置开始搜索字符<code>a</code>，结果为<code>-1</code>，表示没有搜索到。</p>
<p><strong>lastIndexOf()语法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr.lastIndexOf(searchElement[, fromIndex = arr.length - 1])</span><br></pre></td></tr></table></figure>

<p> <code>lastIndexOf</code>方法返回<strong>给定元素在数组中最后一次出现的位置</strong>，如果没有则返回<code>-1</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">a.<span class="title function_">lastIndexOf</span>(<span class="number">2</span>) <span class="comment">//3   2在数组a中最后一次出现的位置为3</span></span><br><span class="line">a.<span class="title function_">lastIndexOf</span>(<span class="number">5</span>) <span class="comment">//-1</span></span><br></pre></td></tr></table></figure>



<p>注意，这两个方法不能用来搜索<code>NaN</code>的位置，即它们无法确定数组成员是否包含<code>NaN</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="title class_">NaN</span>].<span class="title function_">indexOf</span>(<span class="title class_">NaN</span>) <span class="comment">// -1</span></span><br><span class="line">[<span class="title class_">NaN</span>].<span class="title function_">lastIndexOf</span>(<span class="title class_">NaN</span>) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<p>这是因为这两个方法内部，使用严格相等运算符（<code>===</code>）进行比较，而<code>NaN</code>是唯一一个不等于自身的值。</p>
<h3 id="链式使用"><a href="#链式使用" class="headerlink" title="链式使用"></a>链式使用</h3><p>上面这些数组方法之中，有不少返回的还是数组，所以可以链式使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> users = [</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span>, <span class="attr">email</span>: <span class="string">&#x27;tom@example.com&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">&#x27;peter&#x27;</span>, <span class="attr">email</span>: <span class="string">&#x27;peter@example.com&#x27;</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">users</span><br><span class="line">.<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">user</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> user.<span class="property">email</span>;</span><br><span class="line">&#125;) <span class="comment">// 对每个成员进行遍历，使用返回值组成一个新的数组并返回</span></span><br><span class="line">.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">email</span>) &#123; <span class="comment">// 过滤返回值为false的成员，并返回一个过滤掉的新数组</span></span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/^t/</span>.<span class="title function_">test</span>(email);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">email</span>) &#123; <span class="comment">// 遍历数组</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(email);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// &quot;tom@example.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，先产生一个所有 Email 地址组成的数组，然后再过滤出以<code>t</code>开头的 Email 地址，最后将它打印出来。</p>
<blockquote>
<p>方法的返回值能满足下一个方法的调用，即可使用链式调用。</p>
</blockquote>
<h2 id="四、包装对象"><a href="#四、包装对象" class="headerlink" title="四、包装对象"></a>四、包装对象</h2><h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h2><p>对象是JavaScript语言中最主要的数据类型，三种原始类型的值——数字、字符串、布尔值 在一定条件下，也会自动转为对象，也就是原始类型的<strong>包装对象</strong>（wrapper）</p>
<p> 所谓“包装对象”，<strong>指的是与数字、字符串、布尔值分别相对应的<code>Number</code>、<code>String</code>、<code>Boolean</code>三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">var</span> v2 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> v3 = <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> v1 <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> v2 <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> v3 <span class="comment">// &quot;object&quot;</span></span><br><span class="line"></span><br><span class="line">v1 === <span class="number">123</span> <span class="comment">// false</span></span><br><span class="line">v2 === <span class="string">&#x27;abc&#x27;</span> <span class="comment">// false</span></span><br><span class="line">v3 === <span class="literal">true</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，基于原始类型的值，生成了三个对应的包装对象。可以看到，<code>v1</code>、<code>v2</code>、<code>v3</code>都是对象，且与对应的简单类型值不相等。</p>
<p><strong>包装对象的设计目的，首先是使得“对象”这种类型可以覆盖 JavaScript 所有的值，整门语言有一个通用的数据模型，其次是使得原始类型的值也有办法调用自己的方法。</strong></p>
<p> <code>Number</code>、<code>String</code>和<code>Boolean</code>这三个原生对象，如果不作为构造函数调用（即调用时不加<code>new</code>），而是作为普通函数调用，常常用于将任意类型的值转为数值、字符串和布尔值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串转为数值</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;123&#x27;</span>) <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数值转为字符串</span></span><br><span class="line"><span class="title class_">String</span>(<span class="number">123</span>) <span class="comment">// &quot;123&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数值转为布尔值</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="number">123</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面这种<strong>数据类型的转换</strong>，详见《数据类型转换》一节。</p>
<p> 总结一下，这三个对象作为构造函数使用（带有<code>new</code>）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有<code>new</code>），可以将任意类型的值，转为原始类型的值。</p>
<h2 id="2、实例方法"><a href="#2、实例方法" class="headerlink" title="2、实例方法"></a>2、实例方法</h2><p> 三种包装对象各自提供了许多实例方法，详见后文。这里介绍两种它们共同具有、从<code>Object</code>对象<strong>继承的方法</strong>：<code>valueOf()</code>和<code>toString()</code>。</p>
<h3 id="2-1-valueOf"><a href="#2-1-valueOf" class="headerlink" title="2.1 valueOf()"></a>2.1 valueOf()</h3><p> <code>valueOf()</code>方法返回包装对象实例对应的原始类型的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">123</span>).<span class="title function_">valueOf</span>()  <span class="comment">// 123</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;abc&#x27;</span>).<span class="title function_">valueOf</span>() <span class="comment">// &quot;abc&quot;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>).<span class="title function_">valueOf</span>() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-toString"><a href="#2-2-toString" class="headerlink" title="2.2 toString()"></a>2.2 toString()</h3><p><code>toString()</code>方法返回对应的字符串形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">123</span>).<span class="title function_">toString</span>() <span class="comment">// &quot;123&quot;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;abc&#x27;</span>).<span class="title function_">toString</span>() <span class="comment">// &quot;abc&quot;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>).<span class="title function_">toString</span>() <span class="comment">// &quot;true&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="3、原始类型与实例对象的自动转换"><a href="#3、原始类型与实例对象的自动转换" class="headerlink" title="3、原始类型与实例对象的自动转换"></a>3、原始类型与实例对象的自动转换</h2><p>某些场合，原始类型的值会自动当作包装对象调用，即调用包装对象的属性和方法。这时，JavaScript 引擎会自动将原始类型的值转为包装对象实例，并在使用后立刻销毁实例。</p>
<p>比如，字符串可以调用<code>length</code>属性，返回字符串的长度。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="property">length</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>abc</code>是一个字符串，本身不是对象，不能调用<code>length</code>属性。JavaScript 引擎自动将其转为包装对象，在这个对象上调用<code>length</code>属性。调用结束后，这个临时对象就会被销毁。这就叫原始类型与实例对象的自动转换。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">str.<span class="property">length</span> <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">var</span> strObj = <span class="keyword">new</span> <span class="title class_">String</span>(str)</span><br><span class="line"><span class="comment">// String&#123;</span></span><br><span class="line"><span class="comment">//		0:&#x27;a&#x27;,1:&#x27;b&#x27;,2:&#x27;c&#x27;,length:3,[[PrimitiveValue]]: &quot;abc&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">strObj.<span class="property">length</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p> 上面代码中，字符串<code>abc</code>的包装对象提供了多个属性，<code>length</code>只是其中之一。</p>
<p> 自动转换生成的包装对象是只读的，无法修改。所以，字符串无法添加新属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line">s.<span class="property">x</span> = <span class="number">123</span>;</span><br><span class="line">s.<span class="property">x</span> <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p> 上面代码为字符串<code>s</code>添加了一个<code>x</code>属性，结果无效，总是返回<code>undefined</code>。</p>
<p> 另一方面，调用结束后，包装对象实例会自动销毁。这意味着，下一次调用字符串的属性时，实际是调用一个新生成的对象，而不是上一次调用时生成的那个对象，所以取不到赋值在上一个对象的属性。如果要为字符串添加属性，只有在它的原型对象<code>String.prototype</code>上定义（参见《面向对象编程》章节）。</p>
<h2 id="4、自定义方法"><a href="#4、自定义方法" class="headerlink" title="4、自定义方法"></a>4、自定义方法</h2><p>除了原生的实例方法，包装对象还可以自定义方法和属性，供原始类型的值直接调用。</p>
<p>比如，我们可以新增一个<code>double</code>方法，使得字符串和数字翻倍。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">double</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// String是一个方法，String.prototype本质是一个实例对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">valueOf</span>() + <span class="variable language_">this</span>.<span class="title function_">valueOf</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="title function_">double</span>()</span><br><span class="line"><span class="comment">// abcabc</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">double</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">valueOf</span>() + <span class="variable language_">this</span>.<span class="title function_">valueOf</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="number">123</span>).<span class="title function_">double</span>() <span class="comment">// 246 // 不加括号时点运算符会被解释成小数点</span></span><br></pre></td></tr></table></figure>

<p> 上面代码在<code>String</code>和<code>Number</code>这两个对象的原型上面，分别自定义了一个方法，从而可以在所有实例对象上调用。注意，最后一张的<code>123</code>外面必须要加上圆括号，否则后面的点运算符（<code>.</code>）会被解释成小数点。</p>
<h2 id="五、Boolean对象"><a href="#五、Boolean对象" class="headerlink" title="五、Boolean对象"></a>五、Boolean对象</h2><h2 id="1、概述-2"><a href="#1、概述-2" class="headerlink" title="1、概述"></a>1、概述</h2><p> <code>Boolean</code>对象是 JavaScript 的三个包装对象之一。作为构造函数，它主要用于生成布尔值的包装对象实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">typeof</span> b <span class="comment">// object</span></span><br><span class="line">b.<span class="title function_">valueOf</span>() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码的变量<code>b</code>是一个<code>Boolean</code>对象的实例，它的类型是对象，值为布尔值<code>true</code>。</p>
<p>注意，<code>false</code>对应的包装对象实例，布尔运算结果也是<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">false</span>)) &#123; <span class="comment">// 返回的是一个对象，所有对象对应的布尔值都是true</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">&#125; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">false</span>).<span class="title function_">valueOf</span>()) &#123; <span class="comment">// 它的值为false</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">&#125; <span class="comment">// 无输出</span></span><br></pre></td></tr></table></figure>

<p>上面代码的第一个例子之所以得到<code>true</code>，是因为<code>false</code>对应的包装对象实例是一个对象，进行逻辑运算时，被自动转化成布尔值<code>true</code>（因为所有对象对应的布尔值都是<code>true</code>）。而实例的<code>valueOf</code>方法，则返回实例对应的原始值，本例为<code>false</code>。</p>
<h2 id="2、Boolean-函数的类型转换作用"><a href="#2、Boolean-函数的类型转换作用" class="headerlink" title="2、Boolean 函数的类型转换作用"></a>2、Boolean 函数的类型转换作用</h2><p><code>Boolean</code>对象除了可以作为构造函数，还可以单独使用，将任意值转为布尔值。这时<code>Boolean</code>就是一个<strong>单纯的工具方法</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Boolean</span>(<span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="title class_">NaN</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="string">&#x27;false&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Boolean</span>([]) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Boolean</span>(&#123;&#125;) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="regexp">/foo/</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中几种得到<code>true</code>的情况，<strong>都值得认真记住</strong>。</p>
<blockquote>
<p>直接使用上面方法括号内的参数进行if逻辑运行相当于调用了Boolean方法并传入参数</p>
</blockquote>
<p>顺便提一下，使用双重的否运算符（<code>!</code>）也可以将任意值转为对应的布尔值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!!<span class="literal">undefined</span> <span class="comment">// false</span></span><br><span class="line">!!<span class="literal">null</span> <span class="comment">// false</span></span><br><span class="line">!!<span class="number">0</span> <span class="comment">// false</span></span><br><span class="line">!!<span class="string">&#x27;&#x27;</span> <span class="comment">// false</span></span><br><span class="line">!!<span class="title class_">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">!!<span class="number">1</span> <span class="comment">// true</span></span><br><span class="line">!!<span class="string">&#x27;false&#x27;</span> <span class="comment">// true</span></span><br><span class="line">!![] <span class="comment">// true</span></span><br><span class="line">!!&#123;&#125; <span class="comment">// true</span></span><br><span class="line">!!<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// true</span></span><br><span class="line">!!<span class="regexp">/foo/</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<p>最后，对于一些特殊值，<code>Boolean</code>对象前面加不加<code>new</code>，会得到完全相反的结果，必须小心。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title class_">Boolean</span>(<span class="literal">false</span>)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">&#125; <span class="comment">// 无输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">false</span>)) &#123; <span class="comment">// 加new 转为对象，对象为true</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">&#125; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Boolean</span>(<span class="literal">null</span>)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">&#125; <span class="comment">// 无输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">null</span>)) &#123; <span class="comment">// 加new 转为对象，对象为true</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">&#125; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h2 id="六、Number对象"><a href="#六、Number对象" class="headerlink" title="六、Number对象"></a>六、Number对象</h2><h2 id="1、概述-3"><a href="#1、概述-3" class="headerlink" title="1、概述"></a>1、概述</h2><p><code>Number</code>对象是数值对应的包装对象，可以作为构造函数使用，也可以作为工具函数使用。</p>
<p>作为构造函数时，它用于生成值为数值的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n =<span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">1</span>) <span class="comment">// 作为构造函数时，生成值为数值的对象</span></span><br><span class="line"><span class="keyword">typeof</span> n <span class="comment">// object</span></span><br><span class="line">n.<span class="title function_">valueOf</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p> 上面代码中，<code>Number</code>对象作为构造函数使用，返回一个值为<code>1</code>的对象。</p>
<p> 作为工具函数时，它可以将任何类型的值转为数值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">false</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">Number</span>([]) <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>(&#123;&#125;) <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;123&#x27;</span>)<span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p> 上面代码将布尔值<code>true</code>转为数值<code>1</code>。<code>Number</code>作为工具函数的用法，详见《数据类型转换》一章。</p>
<h2 id="2、静态属性"><a href="#2、静态属性" class="headerlink" title="2、静态属性"></a>2、静态属性</h2><p> <code>Number</code>对象拥有以下一些静态属性（即直接定义在<code>Number</code>对象上的属性，而不是定义在实例上的属性）。</p>
<ul>
<li><code>Number.POSITIVE_INFINITY</code>：正的无限，指向<code>Infinity</code>。</li>
<li><code>Number.NEGATIVE_INFINITY</code>：负的无限，指向<code>-Infinity</code>。</li>
<li><code>Number.NaN</code>：表示非数值，指向<code>NaN</code>。</li>
<li><code>Number.MAX_VALUE</code>：表示最大的正数<code>1.7976931348623157e+308</code>，相应的，最小的负数为<code>-Number.MAN_VALUE</code>。</li>
<li><code>Number.MIN_VALUE</code>：表示最小的正数（即最接近0的正数，在64位浮点数体系中为<code>5e-324</code>），相应的，最接近0的负数为<code>-Number.MIN_VALUE</code>。</li>
<li><code>Number.MAX_SAFE_INTEGER</code>：表示能够精确表示的最大整数，即<code>9007199254740991</code>。</li>
<li><code>Number.MIN_SAFE_INTEGER</code>：表示能够精确表示的最小整数，即<code>-9007199254740991</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="property">POSITIVE_INFINITY</span> <span class="comment">// Infinity</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">NEGATIVE_INFINITY</span> <span class="comment">// -Infinity</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">NaN</span> <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">MAX_VALUE</span></span><br><span class="line"><span class="comment">// 1.7976931348623157e+308</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">MAX_VALUE</span> &lt; <span class="title class_">Infinity</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">MIN_VALUE</span></span><br><span class="line"><span class="comment">// 5e-324</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">MIN_VALUE</span> &gt; <span class="number">0</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span> <span class="comment">// 9007199254740991</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">MIN_SAFE_INTEGER</span> <span class="comment">// -9007199254740991</span></span><br></pre></td></tr></table></figure>

<h2 id="3、实例方法-1"><a href="#3、实例方法-1" class="headerlink" title="3、实例方法"></a>3、实例方法</h2><p> <code>Number</code>对象有<strong>4个实例方法</strong>，都跟<strong>将数值转换成指定格式有关</strong>。</p>
<h3 id="3-1-Number-prototype-toString-可转成多种进制字符串"><a href="#3-1-Number-prototype-toString-可转成多种进制字符串" class="headerlink" title="3.1 Number.prototype.toString() 可转成多种进制字符串"></a>3.1 Number.prototype.toString() 可转成多种进制字符串</h3><p><code>Number</code>对象部署了自己的<code>toString</code>方法，用来将一个数值转为字符串形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">10</span>).<span class="title function_">toString</span>() <span class="comment">// &quot;10&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>toString</code>方法可以<strong>接受一个参数</strong>，表示输出的<strong>进制</strong>。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">10</span>).<span class="title function_">toString</span>(<span class="number">2</span>) <span class="comment">// &quot;1010&quot;</span></span><br><span class="line">(<span class="number">10</span>).<span class="title function_">toString</span>(<span class="number">8</span>) <span class="comment">// &quot;12&quot;</span></span><br><span class="line">(<span class="number">10</span>).<span class="title function_">toString</span>(<span class="number">16</span>) <span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>10</code>一定要放在括号里，这样表明后面的点表示调用对象属性。如果不加括号，这个点会被 JavaScript 引擎解释成小数点，从而报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">10.</span><span class="title function_">toString</span>(<span class="number">2</span>) <span class="comment">// 不加括号会把点解释成小数点，从而报错</span></span><br><span class="line"><span class="comment">// SyntaxError: Unexpected token ILLEGAL</span></span><br></pre></td></tr></table></figure>

<p>只要能够让 JavaScript 引擎不混淆小数点和对象的点运算符，各种写法都能用。除了为<code>10</code>加上括号，还可以在<code>10</code>后面加两个点，JavaScript 会把第一个点理解成小数点（即<code>10.0</code>），把第二个点理解成调用对象属性，从而得到正确结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">10.</span>.<span class="title function_">toString</span>(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// &quot;1010&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他方法还包括</span></span><br><span class="line"><span class="number">10</span> .<span class="title function_">toString</span>(<span class="number">2</span>) <span class="comment">// &quot;1010&quot;</span></span><br><span class="line"><span class="number">10.0</span>.<span class="title function_">toString</span>(<span class="number">2</span>) <span class="comment">// &quot;1010&quot;</span></span><br></pre></td></tr></table></figure>

<p>这实际上意味着，可以直接对一个小数使用<code>toString</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">10.5</span>.<span class="title function_">toString</span>() <span class="comment">// &quot;10.5&quot;</span></span><br><span class="line"><span class="number">10.5</span>.<span class="title function_">toString</span>(<span class="number">2</span>) <span class="comment">// &quot;1010.1&quot;</span></span><br><span class="line"><span class="number">10.5</span>.<span class="title function_">toString</span>(<span class="number">8</span>) <span class="comment">// &quot;12.4&quot;</span></span><br><span class="line"><span class="number">10.5</span>.<span class="title function_">toString</span>(<span class="number">16</span>) <span class="comment">// &quot;a.8&quot;</span></span><br></pre></td></tr></table></figure>

<p>通过方括号运算符也可以调用<code>toString</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span>[<span class="string">&#x27;toString&#x27;</span>](<span class="number">2</span>) <span class="comment">// &quot;1010&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>toString</code>方法只能将十进制的数，转为其他进制的字符串。如果要将其他进制的数，转回十进制，需要使用<code>parseInt</code>方法。</p>
<h3 id="3-2-Number-prototype-toFixed-转成保留指定小数位数的字符串"><a href="#3-2-Number-prototype-toFixed-转成保留指定小数位数的字符串" class="headerlink" title="3.2 Number.prototype.toFixed() 转成保留指定小数位数的字符串"></a>3.2 Number.prototype.toFixed() 转成保留指定小数位数的字符串</h3><p><code>toFixed()</code>方法先将一个数转为指定位数的小数，然后返回这个小数对应的字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">10</span>).<span class="title function_">toFixed</span>(<span class="number">2</span>) <span class="comment">// &quot;10.00&quot;</span></span><br><span class="line"><span class="number">10.005</span>.<span class="title function_">toFixed</span>(<span class="number">2</span>) <span class="comment">// &quot;10.01&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>10</code>和<code>10.005</code>先转成2位小数，然后转成字符串。其中<code>10</code>必须放在括号里，否则后面的点会被处理成小数点。</p>
<p><code>toFixed()</code>方法的参数为小数位数，有效范围为0到20，超出这个范围将抛出 RangeError 错误。</p>
<p>由于浮点数的原因，小数<code>5</code>的四舍五入是不确定的，使用的时候必须小心。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">10.055</span>).<span class="title function_">toFixed</span>(<span class="number">2</span>) <span class="comment">// 10.05</span></span><br><span class="line">(<span class="number">10.005</span>).<span class="title function_">toFixed</span>(<span class="number">2</span>) <span class="comment">// 10.01</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-Number-prototype-toExponential-转成科学计数法形式字符串"><a href="#3-3-Number-prototype-toExponential-转成科学计数法形式字符串" class="headerlink" title="3.3 Number.prototype.toExponential() 转成科学计数法形式字符串"></a>3.3 Number.prototype.toExponential() 转成科学计数法形式字符串</h3><p><code>toExponential</code>方法用于将一个数转为科学计数法形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">10</span>).<span class="title function_">toExponential</span>()  <span class="comment">// &quot;1e+1&quot;</span></span><br><span class="line">(<span class="number">10</span>).<span class="title function_">toExponential</span>(<span class="number">1</span>) <span class="comment">// &quot;1.0e+1&quot;</span></span><br><span class="line">(<span class="number">10</span>).<span class="title function_">toExponential</span>(<span class="number">2</span>) <span class="comment">// &quot;1.00e+1&quot;</span></span><br><span class="line"></span><br><span class="line">(<span class="number">1234</span>).<span class="title function_">toExponential</span>()  <span class="comment">// &quot;1.234e+3&quot;</span></span><br><span class="line">(<span class="number">1234</span>).<span class="title function_">toExponential</span>(<span class="number">1</span>) <span class="comment">// &quot;1.2e+3&quot;</span></span><br><span class="line">(<span class="number">1234</span>).<span class="title function_">toExponential</span>(<span class="number">2</span>) <span class="comment">// &quot;1.23e+3&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>toExponential</code>方法的参数是小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个 RangeError 错误。</p>
<h3 id="3-4-Number-prototype-toPrecision-转为指定位数的有效数字"><a href="#3-4-Number-prototype-toPrecision-转为指定位数的有效数字" class="headerlink" title="3.4 Number.prototype.toPrecision()转为指定位数的有效数字"></a>3.4 Number.prototype.toPrecision()转为指定位数的有效数字</h3><p><code>Number.prototype.toPrecision()</code>方法用于将一个数转为指定位数的有效数字。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">12.34</span>).<span class="title function_">toPrecision</span>(<span class="number">1</span>) <span class="comment">// &quot;1e+1&quot;</span></span><br><span class="line">(<span class="number">12.34</span>).<span class="title function_">toPrecision</span>(<span class="number">2</span>) <span class="comment">// &quot;12&quot;</span></span><br><span class="line">(<span class="number">12.34</span>).<span class="title function_">toPrecision</span>(<span class="number">3</span>) <span class="comment">// &quot;12.3&quot;</span></span><br><span class="line">(<span class="number">12.34</span>).<span class="title function_">toPrecision</span>(<span class="number">4</span>) <span class="comment">// &quot;12.34&quot;</span></span><br><span class="line">(<span class="number">12.34</span>).<span class="title function_">toPrecision</span>(<span class="number">5</span>) <span class="comment">// &quot;12.340&quot;</span></span><br></pre></td></tr></table></figure>

<p>该方法的参数为有效数字的位数，范围是1到21，超出这个范围会抛出 RangeError 错误。</p>
<p>该方法用于四舍五入时不太可靠，跟浮点数不是精确储存有关。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">12.35</span>).<span class="title function_">toPrecision</span>(<span class="number">3</span>) <span class="comment">// &quot;12.3&quot;</span></span><br><span class="line">(<span class="number">12.25</span>).<span class="title function_">toPrecision</span>(<span class="number">3</span>) <span class="comment">// &quot;12.3&quot;</span></span><br><span class="line">(<span class="number">12.15</span>).<span class="title function_">toPrecision</span>(<span class="number">3</span>) <span class="comment">// &quot;12.2&quot;</span></span><br><span class="line">(<span class="number">12.45</span>).<span class="title function_">toPrecision</span>(<span class="number">3</span>) <span class="comment">// &quot;12.4&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-5-Number-prototype-toLocaleString"><a href="#4-5-Number-prototype-toLocaleString" class="headerlink" title="4.5 Number.prototype.toLocaleString()"></a>4.5 Number.prototype.toLocaleString()</h3><p><code>Number.prototype.toLocaleString()</code>方法接受一个地区码作为参数，返回一个字符串，表示当前数字在该地区的当地书写形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">123</span>).<span class="title function_">toLocaleString</span>(<span class="string">&#x27;zh-Hans-CN-u-nu-hanidec&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;一二三&quot;</span></span><br></pre></td></tr></table></figure>

<p>该方法还可以接受第二个参数配置对象，用来定制指定用途的返回字符串。该对象的<code>style</code>属性指定输出样式，默认值是<code>decimal</code>，表示输出十进制形式。如果值为<code>percent</code>，表示输出百分数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">123</span>).<span class="title function_">toLocaleString</span>(<span class="string">&#x27;zh-Hans-CN&#x27;</span>, &#123; <span class="attr">style</span>: <span class="string">&#x27;persent&#x27;</span> &#125;)</span><br><span class="line"><span class="comment">// &quot;12,300%&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果<code>style</code>属性的值为<code>currency</code>，则可以搭配<code>currency</code>属性，输出指定格式的货币字符串形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">123</span>).<span class="title function_">toLocaleString</span>(<span class="string">&#x27;zh-Hans-CN&#x27;</span>, &#123; <span class="attr">style</span>: <span class="string">&#x27;currency&#x27;</span>, <span class="attr">currency</span>: <span class="string">&#x27;CNY&#x27;</span> &#125;)</span><br><span class="line"><span class="comment">// &quot;￥123.00&quot;</span></span><br><span class="line"></span><br><span class="line">(<span class="number">123</span>).<span class="title function_">toLocaleString</span>(<span class="string">&#x27;de-DE&#x27;</span>, &#123; <span class="attr">style</span>: <span class="string">&#x27;currency&#x27;</span>, <span class="attr">currency</span>: <span class="string">&#x27;EUR&#x27;</span> &#125;)</span><br><span class="line"><span class="comment">// &quot;123,00 €&quot;</span></span><br><span class="line"></span><br><span class="line">(<span class="number">123</span>).<span class="title function_">toLocaleString</span>(<span class="string">&#x27;en-US&#x27;</span>, &#123; <span class="attr">style</span>: <span class="string">&#x27;currency&#x27;</span>, <span class="attr">currency</span>: <span class="string">&#x27;USD&#x27;</span> &#125;)</span><br><span class="line"><span class="comment">// &quot;$123.00&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果<code>Number.prototype.toLocaleString()</code>省略了参数，则由浏览器自行决定如何处理，通常会使用操作系统的地区设定。注意，该方法如果使用浏览器不认识的地区码，会抛出一个错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">123</span>).<span class="title function_">toLocaleString</span>(<span class="string">&#x27;123&#x27;</span>) <span class="comment">// 出错</span></span><br></pre></td></tr></table></figure>



<h4 id="应用-添加千位分隔符"><a href="#应用-添加千位分隔符" class="headerlink" title="应用-添加千位分隔符"></a>应用-添加千位分隔符</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">123456.789</span>).<span class="title function_">toLocaleString</span>()</span><br><span class="line"><span class="comment">// 输出 &quot;123,456.789&quot;，常用。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">1234566</span>).<span class="title function_">toLocaleString</span>(<span class="string">&#x27;zh-Hans-CN-u-nu-hanidec&#x27;</span>);</span><br><span class="line"><span class="comment">// 输出&quot;一,二三四,五六六&quot;</span></span><br><span class="line"></span><br><span class="line">(<span class="number">1234566</span>).<span class="title function_">toLocaleString</span>(<span class="string">&#x27;zh-Hans-CN-u-nu-hanidec&#x27;</span>,&#123;<span class="attr">useGrouping</span>: <span class="literal">true</span>&#125;);</span><br><span class="line"><span class="comment">// 给.toLocaleString()加第二个参数，依然输出&quot;一,二三四,五六六&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不带千位分隔符</span></span><br><span class="line">(<span class="number">1234566</span>).<span class="title function_">toLocaleString</span>(<span class="string">&#x27;zh-Hans-CN-u-nu-hanidec&#x27;</span>,&#123;<span class="attr">useGrouping</span>: <span class="literal">false</span>&#125;);</span><br><span class="line"><span class="comment">// 输出&quot;一二三四五六六&quot;，这个比较有用，也就是最简单的将阿拉伯数字变成汉字的办法。</span></span><br></pre></td></tr></table></figure>



<h2 id="4、自定义方法-1"><a href="#4、自定义方法-1" class="headerlink" title="4、自定义方法"></a>4、自定义方法</h2><p>与其他对象一样，<code>Number.prototype</code>对象上面可以自定义方法，被<code>Number</code>的实例继承。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">add</span> = <span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span> + x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">8</span>[<span class="string">&#x27;add&#x27;</span>](<span class="number">2</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>上面代码为<code>Number</code>对象实例定义了一个<code>add</code>方法。在数值上调用某个方法，数值会自动转为<code>Number</code>的实例对象，所以就可以调用<code>add</code>方法了。由于<code>add</code>方法返回的还是数值，所以可以链式运算。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">subtract</span> = <span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span> - x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="number">8</span>).<span class="title function_">add</span>(<span class="number">2</span>).<span class="title function_">subtract</span>(<span class="number">4</span>)</span><br><span class="line"><span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>上面代码在<code>Number</code>对象的实例上部署了<code>subtract</code>方法，它可以与<code>add</code>方法链式调用。</p>
<p>我们还可以部署更复杂的方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">iterate</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= <span class="variable language_">this</span>; i++) &#123;</span><br><span class="line">    result.<span class="title function_">push</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="number">8</span>).<span class="title function_">iterate</span>()</span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>

<p>上面代码在<code>Number</code>对象的原型上部署了<code>iterate</code>方法，将一个数值自动遍历为一个数组。</p>
<p><strong>注意</strong>，数值的自定义方法，只能定义在它的原型对象<code>Number.prototype</code>上面，数值本身是无法自定义属性的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line">n.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">n.<span class="property">x</span> <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>n</code>是一个原始类型的数值。直接在它上面新增一个属性<code>x</code>，不会报错，但毫无作用，总是返回<code>undefined</code>。这是因为一旦被调用属性，<code>n</code>就自动转为<code>Number</code>的实例对象，调用结束后，该对象自动销毁。所以，下一次调用<code>n</code>的属性时，实际取到的是另一个对象，属性<code>x</code>当然就读不出来。</p>
<h2 id="七、String对象"><a href="#七、String对象" class="headerlink" title="七、String对象"></a>七、String对象</h2><h2 id="1、概述-4"><a href="#1、概述-4" class="headerlink" title="1、概述"></a>1、概述</h2><p><code>String</code>对象是 JavaScript 原生提供的三个包装对象之一，用来生成字符串对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;abc&#x27;</span>); <span class="comment">// 使用new关键字会变成包装对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> s1 <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> s2 <span class="comment">// &quot;object&quot;</span></span><br><span class="line"></span><br><span class="line">s2.<span class="title function_">valueOf</span>() <span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>s1</code>是字符串，<code>s2</code>是对象。由于<code>s2</code>是字符串对象，<code>s2.valueOf</code>方法返回的就是它所对应的原始字符串。</p>
<p><strong>字符串对象是一个类似数组的对象</strong>（很像数组，但不是数组）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> strObj = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="comment">// String &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3&#125;</span></span><br><span class="line"></span><br><span class="line">strObj[<span class="number">1</span>] <span class="comment">// &quot;b&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，字符串<code>abc</code>对应的字符串对象，有数值键（<code>0</code>、<code>1</code>、<code>2</code>）和<code>length</code>属性，所以可以像数组那样取值。</p>
<p>除了用作构造函数，<code>String</code>对象还可以当作工具方法使用，将任意类型的值转为字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">String</span>(<span class="literal">true</span>) <span class="comment">// &quot;true&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">false</span>) <span class="comment">// &quot;false&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="number">5</span>) <span class="comment">// &quot;5&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">null</span>) <span class="comment">// &#x27;null&#x27;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">undefined</span>) <span class="comment">//&#x27;undefined&#x27;</span></span><br><span class="line"><span class="title class_">String</span>(&#123;&#125;) <span class="comment">// &#x27;[object Object]&#x27;</span></span><br><span class="line"><span class="title class_">String</span>([]) <span class="comment">// &#x27;&#x27;</span></span><br><span class="line"><span class="title class_">String</span>([<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>]) <span class="comment">// &#x27;1,2&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面代码将各种类型的值，分别转换为字符串。</p>
<h2 id="2、静态方法-1"><a href="#2、静态方法-1" class="headerlink" title="2、静态方法"></a>2、静态方法</h2><h3 id="String-fromCharCode"><a href="#String-fromCharCode" class="headerlink" title="String.fromCharCode()"></a>String.fromCharCode()</h3><p><code>String</code>对象提供的静态方法（即定义在对象本身，而不是定义在对象实例的方法），主要是<code>String.fromCharCode()</code>。<strong>该方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">String</span>.<span class="title function_">fromCharCode</span>() <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">97</span>) <span class="comment">// &quot;a&quot;</span></span><br><span class="line"><span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>)</span><br><span class="line"><span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>String.fromCharCode</code>方法的参数为空，就返回空字符串；否则，返回参数对应的 Unicode 字符串。</p>
<p>注意，该方法不支持 Unicode 码点大于<code>0xFFFF</code>的字符，即传入的参数不能大于<code>0xFFFF</code>（即十进制的 65535）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">0x20BB7</span>)</span><br><span class="line"><span class="comment">// &quot;ஷ&quot;</span></span><br><span class="line"><span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">0x20BB7</span>) === <span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">0x0BB7</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>String.fromCharCode</code>参数<code>0x20BB7</code>大于<code>0xFFFF</code>，导致返回结果出错。<code>0x20BB7</code>对应的字符是汉字<code>𠮷</code>，但是返回结果却是另一个字符（码点<code>0x0BB7</code>）。这是因为<code>String.fromCharCode</code>发现参数值大于<code>0xFFFF</code>，就会忽略多出的位（即忽略<code>0x20BB7</code>里面的<code>2</code>）。</p>
<p>这种现象的根本原因在于，码点大于<code>0xFFFF</code>的字符占用四个字节，而 JavaScript 默认支持两个字节的字符。这种情况下，必须把<code>0x20BB7</code>拆成两个字符表示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">0xD842</span>, <span class="number">0xDFB7</span>)</span><br><span class="line"><span class="comment">// &quot;𠮷&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>0x20BB7</code>拆成两个字符<code>0xD842</code>和<code>0xDFB7</code>（即两个两字节字符，合成一个四字节字符），就能得到正确的结果。码点大于<code>0xFFFF</code>的字符的四字节表示法，由 UTF-16 编码方法决定。</p>
<h2 id="3、实例属性"><a href="#3、实例属性" class="headerlink" title="3、实例属性"></a>3、实例属性</h2><h3 id="String-prototype-length"><a href="#String-prototype-length" class="headerlink" title="String.prototype.length"></a>String.prototype.length</h3><p>字符串实例的<code>length</code>属性返回字符串的长度。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="property">length</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>



<h2 id="4、实例方法"><a href="#4、实例方法" class="headerlink" title="4、实例方法"></a>4、实例方法</h2><h3 id="4-1-String-prototype-charAt-返回指定位置的字符"><a href="#4-1-String-prototype-charAt-返回指定位置的字符" class="headerlink" title="4.1 String.prototype.charAt() 返回指定位置的字符"></a>4.1 String.prototype.charAt() 返回指定位置的字符</h3><p><code>charAt</code>方法<strong>返回指定位置的字符</strong>，参数是从<code>0</code>开始编号的位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line"></span><br><span class="line">s.<span class="title function_">charAt</span>(<span class="number">1</span>) <span class="comment">// &quot;b&quot;</span></span><br><span class="line">s.<span class="title function_">charAt</span>(s.<span class="property">length</span> - <span class="number">1</span>) <span class="comment">// &quot;c&quot;</span></span><br></pre></td></tr></table></figure>

<p>这个方法完全可以用数组下标替代。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="title function_">charAt</span>(<span class="number">1</span>) <span class="comment">// &quot;b&quot;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>[<span class="number">1</span>] <span class="comment">// &quot;b&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果参数为负数，或大于等于字符串的长度，<code>charAt</code>返回空字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="title function_">charAt</span>(-<span class="number">1</span>) <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="title function_">charAt</span>(<span class="number">3</span>) <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="4-2-String-prototype-charCodeAt-返回字符串指定位置的-Unicode-码点（十进制表示）"><a href="#4-2-String-prototype-charCodeAt-返回字符串指定位置的-Unicode-码点（十进制表示）" class="headerlink" title="4.2 String.prototype.charCodeAt()返回字符串指定位置的 Unicode 码点（十进制表示）"></a>4.2 String.prototype.charCodeAt()返回字符串指定位置的 Unicode 码点（十进制表示）</h3><p><code>charCodeAt</code>方法<strong>返回字符串指定位置的 Unicode 码点（十进制表示）</strong>，相当于<code>String.fromCharCode()</code>的逆操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="title function_">charCodeAt</span>(<span class="number">1</span>) <span class="comment">// 98</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>abc</code>的<code>1</code>号位置的字符是<code>b</code>，它的 Unicode 码点是<code>98</code>。</p>
<p>如果没有任何参数，<code>charCodeAt</code>返回首字符的 Unicode 码点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="title function_">charCodeAt</span>() <span class="comment">// 97</span></span><br></pre></td></tr></table></figure>

<p>如果参数为负数，或大于等于字符串的长度，<code>charCodeAt</code>返回<code>NaN</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="title function_">charCodeAt</span>(-<span class="number">1</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="title function_">charCodeAt</span>(<span class="number">4</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>，<code>charCodeAt</code>方法返回的 Unicode 码点不会大于65536（0xFFFF），也就是说，只返回两个字节的字符的码点。如果遇到码点大于 65536 的字符（四个字节的字符），必需连续使用两次<code>charCodeAt</code>，不仅读入<code>charCodeAt(i)</code>，还要读入<code>charCodeAt(i+1)</code>，将两个值放在一起，才能得到准确的字符。</p>
<h3 id="4-3-String-prototype-concat-合并字符串，返回新字符串，不改变原字符串"><a href="#4-3-String-prototype-concat-合并字符串，返回新字符串，不改变原字符串" class="headerlink" title="4.3 String.prototype.concat() 合并字符串，返回新字符串，不改变原字符串"></a>4.3 String.prototype.concat() 合并字符串，返回新字符串，不改变原字符串</h3><p><code>concat</code>方法<strong>用于连接两个字符串，返回一个新字符串，不改变原字符串</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var s1 = &#x27;abc&#x27;;</span><br><span class="line">var s2 = &#x27;def&#x27;;</span><br><span class="line"></span><br><span class="line">s1.concat(s2) // &quot;abcdef&quot;</span><br><span class="line">s1 // &quot;abc&quot;</span><br></pre></td></tr></table></figure>

<p>该方法可以接受多个参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;a&#x27;.concat(&#x27;b&#x27;, &#x27;c&#x27;) // &quot;abc&quot;</span><br></pre></td></tr></table></figure>

<p>如果参数不是字符串，<code>concat</code>方法会将其先转为字符串，然后再连接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var one = 1;</span><br><span class="line">var two = 2;</span><br><span class="line">var three = &#x27;3&#x27;;</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;.concat(one, two, three) // &quot;123&quot;</span><br><span class="line">one + two + three // &quot;33&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>concat</code>方法将参数先转成字符串再连接，所以返回的是一个三个字符的字符串。作为对比，加号运算符在两个运算数都是数值时，不会转换类型，所以返回的是一个两个字符的字符串。</p>
<h3 id="4-4-String-prototype-slice-取出部分子字符串，不改变原字符串"><a href="#4-4-String-prototype-slice-取出部分子字符串，不改变原字符串" class="headerlink" title="4.4 String.prototype.slice() 取出部分子字符串，不改变原字符串"></a>4.4 String.prototype.slice() 取出部分子字符串，不改变原字符串</h3><p><code>slice</code>方法<strong>用于从原字符串取出子字符串并返回，不改变原字符串</strong>。它的第一个参数是子字符串的<strong>开始位置</strong>，第二个参数是子字符串的<strong>结束位置（不含该位置）</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;JavaScript&#x27;</span>.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">4</span>) <span class="comment">// &quot;Java&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果省略第二个参数，则表示子字符串一直到原字符串结束。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;JavaScript&#x27;</span>.<span class="title function_">slice</span>(<span class="number">4</span>) <span class="comment">// &quot;Script&quot; 省略参数二，会取到结束</span></span><br></pre></td></tr></table></figure>

<p>如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。</p>
<h5 id="负数表示倒数"><a href="#负数表示倒数" class="headerlink" title="负数表示倒数"></a>负数表示倒数</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;JavaScript&#x27;</span>.<span class="title function_">slice</span>(-<span class="number">6</span>) <span class="comment">// &quot;Script&quot;</span></span><br><span class="line"><span class="string">&#x27;JavaScript&#x27;</span>.<span class="title function_">slice</span>(<span class="number">0</span>, -<span class="number">6</span>) <span class="comment">// &quot;Java&quot;</span></span><br><span class="line"><span class="string">&#x27;JavaScript&#x27;</span>.<span class="title function_">slice</span>(-<span class="number">2</span>, -<span class="number">1</span>) <span class="comment">// &quot;p&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果第一个参数大于第二个参数，<code>slice</code>方法返回一个空字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;JavaScript&#x27;</span>.<span class="title function_">slice</span>(<span class="number">2</span>, <span class="number">1</span>) <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="4-5-String-prototype-substring-和slice类似"><a href="#4-5-String-prototype-substring-和slice类似" class="headerlink" title="4.5 String.prototype.substring() 和slice类似"></a>4.5 String.prototype.substring() 和slice类似</h3><p><code>substring</code>方法<strong>用于从原字符串取出子字符串并返回，不改变原字符串</strong>，跟<code>slice</code>方法很相像。它的第一个参数表示子字符串的<strong>开始位置</strong>，第二个位置表示<strong>结束位置（返回结果不含该位置）</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;JavaScript&#x27;</span>.<span class="title function_">substring</span>(<span class="number">0</span>, <span class="number">4</span>) <span class="comment">// &quot;Java&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果省略第二个参数，则表示子字符串一直到原字符串的结束。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;JavaScript&#x27;</span>.<span class="title function_">substring</span>(<span class="number">4</span>) <span class="comment">// &quot;Script&quot; 省略参数二，会取到结束</span></span><br></pre></td></tr></table></figure>

<p>如果第一个参数大于第二个参数，<code>substring</code>方法会自动更换两个参数的位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;JavaScript&#x27;</span>.<span class="title function_">substring</span>(<span class="number">10</span>, <span class="number">4</span>) <span class="comment">// &quot;Script&quot;   // substring自动更换位置，slice则是返回空字符</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="string">&#x27;JavaScript&#x27;</span>.<span class="title function_">substring</span>(<span class="number">4</span>, <span class="number">10</span>) <span class="comment">// &quot;Script&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，调换<code>substring</code>方法的两个参数，都得到同样的结果。</p>
<p>如果参数是负数，<code>substring</code>方法会自动将负数转为0。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;JavaScript&#x27;</span>.<span class="title function_">substring</span>(-<span class="number">3</span>) <span class="comment">// &quot;JavaScript&quot;  // substring负数自动转为0，slice负数表示倒数</span></span><br><span class="line"><span class="string">&#x27;JavaScript&#x27;</span>.<span class="title function_">substring</span>(<span class="number">4</span>, -<span class="number">3</span>) <span class="comment">// &quot;Java&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，第二个例子的参数<code>-3</code>会自动变成<code>0</code>，等同于<code>&#39;JavaScript&#39;.substring(4, 0)</code>。由于第二个参数小于第一个参数，会自动互换位置，所以返回<code>Java</code>。</p>
<p>由于这些规则违反直觉，因此**不建议使用<code>substring</code>方法，应该优先使用<code>slice</code>**。</p>
<h4 id="小总结：substring-和-slice-的区别，有两个。"><a href="#小总结：substring-和-slice-的区别，有两个。" class="headerlink" title="小总结：substring() 和 slice() 的区别，有两个。"></a>小总结：substring() 和 slice() 的区别，有两个。</h4><blockquote>
<ul>
<li>负数参数：substring负数自动转为0，slice负数表示倒数</li>
<li>参数一大于参数二：substring自动更换位置，slice则是返回空字符</li>
</ul>
</blockquote>
<h3 id="4-6-String-prototype-substr-和-slice、substring类似，区别是参数二表示长度"><a href="#4-6-String-prototype-substr-和-slice、substring类似，区别是参数二表示长度" class="headerlink" title="4.6 String.prototype.substr() 和 slice、substring类似，区别是参数二表示长度"></a>4.6 String.prototype.substr() 和 slice、substring类似，区别是参数二表示长度</h3><p><code>substr</code>方法用于<strong>从原字符串取出子字符串并返回，不改变原字符串</strong>，跟<code>slice</code>和<code>substring</code>方法的作用相同。</p>
<p><code>substr</code>方法的第一个参数是子字符串的开始位置（从0开始计算），<strong>第二个参数是子字符串的长度</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;JavaScript&#x27;</span>.<span class="title function_">substr</span>(<span class="number">4</span>, <span class="number">6</span>) <span class="comment">// &quot;Script&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果省略第二个参数，则表示子字符串一直到原字符串的结束。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;JavaScript&#x27;</span>.<span class="title function_">substr</span>(<span class="number">4</span>) <span class="comment">// &quot;Script&quot; 省略参数二，会取到结束</span></span><br></pre></td></tr></table></figure>

<p>如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;JavaScript&#x27;</span>.<span class="title function_">substr</span>(-<span class="number">6</span>) <span class="comment">// &quot;Script&quot; 参数一是负数表示倒数</span></span><br><span class="line"><span class="string">&#x27;JavaScript&#x27;</span>.<span class="title function_">substr</span>(<span class="number">4</span>, -<span class="number">1</span>) <span class="comment">// &quot;&quot;  参数二是负数转为0</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，第二个例子的参数<code>-1</code>自动转为<code>0</code>，表示子字符串长度为<code>0</code>，所以返回空字符串。</p>
<h3 id="4-7-String-prototype-indexOf-搜索子串第一个出现的位置，String-prototype-lastIndexOf-搜索子串最后出现的位置"><a href="#4-7-String-prototype-indexOf-搜索子串第一个出现的位置，String-prototype-lastIndexOf-搜索子串最后出现的位置" class="headerlink" title="4.7 String.prototype.indexOf() 搜索子串第一个出现的位置，String.prototype.lastIndexOf() 搜索子串最后出现的位置"></a>4.7 String.prototype.indexOf() 搜索子串第一个出现的位置，String.prototype.lastIndexOf() 搜索子串最后出现的位置</h3><p><code>indexOf</code>方法<strong>用于确定一个字符串在另一个字符串中第一次出现的位置</strong>，<strong>返回结果是匹配开始的位置</strong>。如果返回<code>-1</code>，就表示不匹配。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;hello world&#x27;</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;o&#x27;</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="string">&#x27;JavaScript&#x27;</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;script&#x27;</span>) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<p><code>indexOf</code>方法还可以接受第二个参数，表示从该位置开始向后匹配。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;hello world&#x27;</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;o&#x27;</span>, <span class="number">6</span>) <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<p><code>lastIndexOf</code>方法的用法跟<code>indexOf</code>方法一致，主要的区别是<code>lastIndexOf</code>从尾部开始匹配，<code>indexOf</code>则是从头部开始匹配。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;hello world&#x27;</span>.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;o&#x27;</span>) <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<p>另外，<code>lastIndexOf</code>的第二个参数表示从该位置起向前匹配。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;hello world&#x27;</span>.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;o&#x27;</span>, <span class="number">6</span>) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>



<h3 id="4-8-String-prototype-trim-‘’修剪’‘两端空格，不改变原字符串"><a href="#4-8-String-prototype-trim-‘’修剪’‘两端空格，不改变原字符串" class="headerlink" title="4.8 String.prototype.trim()  ‘’修剪’‘两端空格，不改变原字符串"></a>4.8 String.prototype.trim()  ‘’修剪’‘两端空格，不改变原字符串</h3><p><code>trim</code>方法<strong>用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;  hello world  &#x27;</span>.<span class="title function_">trim</span>()</span><br><span class="line"><span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<p>该方法去除的不仅是空格，还包括<strong>制表符（<code>\t</code>、<code>\v</code>）、换行符（<code>\n</code>）和回车符（<code>\r</code>）</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;\r\nabc \t&#x27;</span>.<span class="title function_">trim</span>() <span class="comment">// &#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="4-9-String-prototype-toLowerCase-全转小写，String-prototype-toUpperCase-全转大写，都不改变原字符串"><a href="#4-9-String-prototype-toLowerCase-全转小写，String-prototype-toUpperCase-全转大写，都不改变原字符串" class="headerlink" title="4.9 String.prototype.toLowerCase() 全转小写，String.prototype.toUpperCase() 全转大写，都不改变原字符串"></a>4.9 String.prototype.toLowerCase() 全转小写，String.prototype.toUpperCase() 全转大写，都不改变原字符串</h3><p><code>toLowerCase</code>方法用于将一个字符串<strong>全部转为小写</strong>，<code>toUpperCase</code>则是<strong>全部转为大写</strong>。它们都<strong>返回一个新字符串，不改变原字符串</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;Hello World&#x27;</span>.<span class="title function_">toLowerCase</span>()</span><br><span class="line"><span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;Hello World&#x27;</span>.<span class="title function_">toUpperCase</span>()</span><br><span class="line"><span class="comment">// &quot;HELLO WORLD&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="4-10-String-prototype-match-匹配子串，返回数组（数组带index、input属性）"><a href="#4-10-String-prototype-match-匹配子串，返回数组（数组带index、input属性）" class="headerlink" title="4.10 String.prototype.match() 匹配子串，返回数组（数组带index、input属性）"></a>4.10 String.prototype.match() 匹配子串，返回数组（数组带index、input属性）</h3><p><code>match</code>方法<strong>用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串</strong>。如果没有找到匹配，则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;cat, bat, sat, fat&#x27;</span>.<span class="title function_">match</span>(<span class="string">&#x27;at&#x27;</span>) <span class="comment">// [&quot;at&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;at&quot;, index: 1, input: &quot;cat, bat, sat, fat&quot;, groups: undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;catbatsatbat&#x27;</span>.<span class="title function_">match</span>(<span class="string">&#x27;bat&#x27;</span>) <span class="comment">// [&quot;bat&quot;]</span></span><br><span class="line"><span class="comment">//[&quot;bat&quot;, index: 3, input: &quot;catbatsatbat&quot;, groups: undefined]</span></span><br><span class="line"><span class="comment">// index属性为bat首次出现的索引</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;cat, bat, sat, fat&#x27;</span>.<span class="title function_">match</span>(<span class="string">&#x27;xt&#x27;</span>) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>返回的数组还有**<code>index</code>属性<strong>和</strong><code>input</code>属性<strong>，分别表示匹配字符串</strong>开始的位置<strong>和</strong>原始字符串**。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> matches = <span class="string">&#x27;cat, bat, sat, fat&#x27;</span>.<span class="title function_">match</span>(<span class="string">&#x27;at&#x27;</span>);</span><br><span class="line">matches.<span class="property">index</span> <span class="comment">// 1  子串首次出现的索引位置</span></span><br><span class="line">matches.<span class="property">input</span> <span class="comment">// &quot;cat, bat, sat, fat&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>match</code>方法还可以使用<strong>正则表达式</strong>作为参数，详见《正则表达式》一章。</p>
<h3 id="4-11-String-prototype-search-搜索子串第一次出现的位置，没有则返-1，String-prototype-replace-替换子串，参数二替换参数一，不改变原字符串"><a href="#4-11-String-prototype-search-搜索子串第一次出现的位置，没有则返-1，String-prototype-replace-替换子串，参数二替换参数一，不改变原字符串" class="headerlink" title="4.11 String.prototype.search() 搜索子串第一次出现的位置，没有则返-1，String.prototype.replace() 替换子串，参数二替换参数一，不改变原字符串"></a>4.11 String.prototype.search() 搜索子串第一次出现的位置，没有则返-1，String.prototype.replace() 替换子串，参数二替换参数一，不改变原字符串</h3><p><code>search</code>方法的用法基本等同于<code>match</code>，但是<strong>返回值为匹配的第一个位置。如果没有找到匹配，则返回<code>-1</code>。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;cat, bat, sat, fat&#x27;</span>.<span class="title function_">search</span>(<span class="string">&#x27;at&#x27;</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p><code>search</code>方法还可以使用正则表达式作为参数，详见《正则表达式》一节。</p>
<p><code>replace</code>方法<strong>用于替换匹配的子字符串</strong>，一般情况下只替换第一个匹配（除非使用带有<code>g</code>修饰符的正则表达式）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;aaa&#x27;</span>;</span><br><span class="line">str.<span class="title function_">replace</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>) <span class="comment">// &quot;baa&quot; 一般情况只替换第一个，除非带有g的正则</span></span><br><span class="line">str <span class="comment">// &#x27;aaa&#x27; 不改变原字符串</span></span><br><span class="line">str.<span class="title function_">replace</span>(<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;b&#x27;</span>) <span class="comment">// &#x27;aaa&#x27; 匹配不到返回原字符串</span></span><br></pre></td></tr></table></figure>

<p><code>replace</code>方法还可以使用正则表达式作为参数，详见《正则表达式》一节。</p>
<h3 id="4-12-String-prototype-split-按给定规则分割字符串，返回数组"><a href="#4-12-String-prototype-split-按给定规则分割字符串，返回数组" class="headerlink" title="4.12 String.prototype.split() 按给定规则分割字符串，返回数组"></a>4.12 String.prototype.split() 按给定规则分割字符串，返回数组</h3><p><code>split</code>方法<strong>按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a|b|c&#x27;</span>.<span class="title function_">split</span>(<span class="string">&#x27;|&#x27;</span>) <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure>

<p>如果分割规则为空字符串，则返回数组的成员是原字符串的每一个字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a|b|c&#x27;</span>.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// [&quot;a&quot;, &quot;|&quot;, &quot;b&quot;, &quot;|&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure>

<p>如果<strong>省略参数，则返回数组的唯一成员就是原字符串</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a|b|c&#x27;</span>.<span class="title function_">split</span>() <span class="comment">// [&quot;a|b|c&quot;]</span></span><br></pre></td></tr></table></figure>

<p>如果满足分割规则的两个部分紧邻着（即两个分割符中间没有其他字符），则返回数组之中会有一个空字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a||c&#x27;</span>.<span class="title function_">split</span>(<span class="string">&#x27;|&#x27;</span>) <span class="comment">// [&#x27;a&#x27;, &#x27;&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>如果满足分割规则的部分处于字符串的开头或结尾（即它的前面或后面没有其他字符），则返回数组的第一个或最后一个成员是一个空字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;|b|c&#x27;</span>.<span class="title function_">split</span>(<span class="string">&#x27;|&#x27;</span>) <span class="comment">// [&quot;&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"><span class="string">&#x27;a|b|&#x27;</span>.<span class="title function_">split</span>(<span class="string">&#x27;|&#x27;</span>) <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;&quot;]</span></span><br></pre></td></tr></table></figure>

<p><code>split</code>方法还可以接受<strong>第二个参数</strong>，<strong>限定返回数组的最大成员数（数组长度）</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a|b|c&#x27;</span>.<span class="title function_">split</span>(<span class="string">&#x27;|&#x27;</span>, <span class="number">0</span>) <span class="comment">// []</span></span><br><span class="line"><span class="string">&#x27;a|b|c&#x27;</span>.<span class="title function_">split</span>(<span class="string">&#x27;|&#x27;</span>, <span class="number">1</span>) <span class="comment">// [&quot;a&quot;]</span></span><br><span class="line"><span class="string">&#x27;a|b|c&#x27;</span>.<span class="title function_">split</span>(<span class="string">&#x27;|&#x27;</span>, <span class="number">2</span>) <span class="comment">// [&quot;a&quot;, &quot;b&quot;]</span></span><br><span class="line"><span class="string">&#x27;a|b|c&#x27;</span>.<span class="title function_">split</span>(<span class="string">&#x27;|&#x27;</span>, <span class="number">3</span>) <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"><span class="string">&#x27;a|b|c&#x27;</span>.<span class="title function_">split</span>(<span class="string">&#x27;|&#x27;</span>, <span class="number">4</span>) <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>split</code>方法的第二个参数，决定了返回数组的成员数。</p>
<p><code>split</code>方法还可以使用正则表达式作为参数，详见《正则表达式》一节。</p>
<h3 id="4-13-String-prototype-localeCompare-比较两个字符串，返回整数。"><a href="#4-13-String-prototype-localeCompare-比较两个字符串，返回整数。" class="headerlink" title="4.13 String.prototype.localeCompare() 比较两个字符串，返回整数。"></a>4.13 String.prototype.localeCompare() 比较两个字符串，返回整数。</h3><p><code>localeCompare</code>方法 <strong>用于比较两个字符串。它返回一个整数</strong>，<strong>如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;apple&#x27;</span>.<span class="title function_">localeCompare</span>(<span class="string">&#x27;banana&#x27;</span>) <span class="comment">// -1</span></span><br><span class="line"><span class="string">&#x27;apple&#x27;</span>.<span class="title function_">localeCompare</span>(<span class="string">&#x27;apple&#x27;</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>该方法的最大特点，就是会考虑自然语言的顺序。举例来说，正常情况下，大写的英文字母小于小写字母。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;B&#x27;</span> &gt; <span class="string">&#x27;a&#x27;</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，字母<code>B</code>小于字母<code>a</code>。因为 JavaScript 采用的是 Unicode 码点比较，<code>B</code>的码点是66，而<code>a</code>的码点是97。</p>
<p>但是，<code>localeCompare</code>方法会考虑自然语言的排序情况，将<code>B</code>排在<code>a</code>的前面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;B&#x27;</span>.<span class="title function_">localeCompare</span>(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>localeCompare</code>方法返回整数1，表示<code>B</code>较大。</p>
<p><code>localeCompare</code>还可以有第二个参数，指定所使用的语言（默认是英语），然后根据该语言的规则进行比较。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;ä&#x27;</span>.<span class="title function_">localeCompare</span>(<span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;de&#x27;</span>) <span class="comment">// -1</span></span><br><span class="line"><span class="string">&#x27;ä&#x27;</span>.<span class="title function_">localeCompare</span>(<span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;sv&#x27;</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>de</code>表示德语，<code>sv</code>表示瑞典语。德语中，<code>ä</code>小于<code>z</code>，所以返回<code>-1</code>；瑞典语中，<code>ä</code>大于<code>z</code>，所以返回<code>1</code>。</p>
<h2 id="八、Math对象"><a href="#八、Math对象" class="headerlink" title="八、Math对象"></a>八、Math对象</h2><p> <code>Math</code>是 JavaScript 的原生对象，提供各种<strong>数学</strong>功能。该对象<strong>不是构造函数，不能生成实例</strong>，所有的属性和方法都必须在<code>Math</code>对象上调用。</p>
<h2 id="1、静态属性"><a href="#1、静态属性" class="headerlink" title="1、静态属性"></a>1、静态属性</h2><p><code>Math</code>对象的静态属性，提供以下一些数学常数。</p>
<ul>
<li><code>Math.E</code>：常数<code>e</code>。</li>
<li><code>Math.LN2</code>：2 的自然对数。</li>
<li><code>Math.LN10</code>：10 的自然对数。</li>
<li><code>Math.LOG2E</code>：以 2 为底的<code>e</code>的对数。</li>
<li><code>Math.LOG10E</code>：以 10 为底的<code>e</code>的对数。</li>
<li><code>Math.PI</code>：常数<code>π</code>。</li>
<li><code>Math.SQRT1_2</code>：0.5 的平方根。</li>
<li><code>Math.SQRT2</code>：2 的平方根。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="property">E</span> <span class="comment">// 2.718281828459045</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="property">LN2</span> <span class="comment">// 0.6931471805599453</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="property">LN10</span> <span class="comment">// 2.302585092994046</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="property">LOG2E</span> <span class="comment">// 1.4426950408889634</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="property">LOG10E</span> <span class="comment">// 0.4342944819032518</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="property">PI</span> <span class="comment">// 3.141592653589793</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="property">SQRT1_2</span> <span class="comment">// 0.7071067811865476</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="property">SQRT2</span> <span class="comment">// 1.4142135623730951</span></span><br></pre></td></tr></table></figure>

<p>这些属性都是<strong>只读的</strong>，不能修改。</p>
<h2 id="2、静态方法-2"><a href="#2、静态方法-2" class="headerlink" title="2、静态方法"></a>2、静态方法</h2><p><code>Math</code>对象提供以下一些静态方法。</p>
<ul>
<li><code>Math.abs()</code>：绝对值</li>
<li><code>Math.ceil()</code>：向上取整</li>
<li><code>Math.floor()</code>：向下取整</li>
<li><code>Math.max()</code>：最大值</li>
<li><code>Math.min()</code>：最小值</li>
<li><code>Math.pow()</code>：指数运算</li>
<li><code>Math.sqrt()</code>：平方根</li>
<li><code>Math.log()</code>：自然对数</li>
<li><code>Math.exp()</code>：<code>e</code>的指数</li>
<li><code>Math.round()</code>：四舍五入</li>
<li><code>Math.random()</code>：随机数</li>
</ul>
<h3 id="2-1-Math-abs-绝对值"><a href="#2-1-Math-abs-绝对值" class="headerlink" title="2.1 Math.abs() 绝对值"></a>2.1 Math.abs() 绝对值</h3><p><code>Math.abs</code>方法<strong>返回参数值的绝对值</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">abs</span>(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">abs</span>(-<span class="number">1</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-Math-max-最大值，Math-min-最-小值"><a href="#2-2-Math-max-最大值，Math-min-最-小值" class="headerlink" title="2.2 Math.max() 最大值，Math.min()最 小值"></a>2.2 Math.max() 最大值，Math.min()最 小值</h3><p><code>Math.max</code>方法<strong>返回参数之中最大的那个值</strong>，<code>Math.min</code><strong>返回最小的那个值</strong>。如果参数为空, <code>Math.min</code>返回<code>Infinity</code>, <code>Math.max</code>返回<code>-Infinity</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">2</span>, -<span class="number">1</span>, <span class="number">5</span>) <span class="comment">// 5</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="number">2</span>, -<span class="number">1</span>, <span class="number">5</span>) <span class="comment">// -1</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">min</span>() <span class="comment">// Infinity</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">max</span>() <span class="comment">// -Infinity</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-Math-floor-向下取整，Math-ceil-向上取整"><a href="#2-3-Math-floor-向下取整，Math-ceil-向上取整" class="headerlink" title="2.3 Math.floor() 向下取整，Math.ceil() 向上取整"></a>2.3 Math.floor() 向下取整，Math.ceil() 向上取整</h3><p><code>Math.floor</code>方法<strong>返回小于参数值的最大整数（地板值）</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">3.2</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>(-<span class="number">3.2</span>) <span class="comment">// -4</span></span><br></pre></td></tr></table></figure>

<p><code>Math.ceil</code>方法<strong>返回大于参数值的最小整数（天花板值）</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="number">3.2</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">ceil</span>(-<span class="number">3.2</span>) <span class="comment">// -3</span></span><br></pre></td></tr></table></figure>

<p>这两个方法可以结合起来，实现一个<strong>总是返回数值的整数部分的函数</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ToInteger</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  x = <span class="title class_">Number</span>(x);</span><br><span class="line">  <span class="keyword">return</span> x &lt; <span class="number">0</span> ? <span class="title class_">Math</span>.<span class="title function_">ceil</span>(x) : <span class="title class_">Math</span>.<span class="title function_">floor</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ToInteger</span>(<span class="number">3.2</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="title class_">ToInteger</span>(<span class="number">3.5</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="title class_">ToInteger</span>(<span class="number">3.8</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="title class_">ToInteger</span>(-<span class="number">3.2</span>) <span class="comment">// -3</span></span><br><span class="line"><span class="title class_">ToInteger</span>(-<span class="number">3.5</span>) <span class="comment">// -3</span></span><br><span class="line"><span class="title class_">ToInteger</span>(-<span class="number">3.8</span>) <span class="comment">// -3</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，不管正数或负数，<code>ToInteger</code>函数总是返回一个数值的整数部分。</p>
<h3 id="2-4-Math-round-四舍五入"><a href="#2-4-Math-round-四舍五入" class="headerlink" title="2.4 Math.round() 四舍五入"></a>2.4 Math.round() 四舍五入</h3><p><code>Math.round</code>方法用于<strong>四舍五入</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="number">0.1</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="number">0.5</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="number">0.6</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>，它对负数的处理（主要是对<code>.5</code>的处理）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">round</span>(-<span class="number">1.1</span>) <span class="comment">// -1</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">round</span>(-<span class="number">1.5</span>) <span class="comment">// -1</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">round</span>(-<span class="number">1.6</span>) <span class="comment">// -2</span></span><br></pre></td></tr></table></figure>

<h3 id="2-5-Math-pow-指数运算-（次方运算）"><a href="#2-5-Math-pow-指数运算-（次方运算）" class="headerlink" title="2.5 Math.pow() 指数运算 （次方运算）"></a>2.5 Math.pow() 指数运算 （次方运算）</h3><p><code>Math.pow</code>方法返回<strong>以第一个参数为底数、第二个参数为幂的指数值</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等同于 2 ** 2</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">2</span>) <span class="comment">// 4   2的2次方</span></span><br><span class="line"><span class="comment">// 等同于 2 ** 3</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 8   2的3次方</span></span><br></pre></td></tr></table></figure>

<p>下面是<strong>计算圆面积的方法</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> radius = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> area = <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="title class_">Math</span>.<span class="title function_">pow</span>(radius, <span class="number">2</span>); <span class="comment">// 1256.6370614359173</span></span><br></pre></td></tr></table></figure>

<h3 id="2-6-Math-sqrt-平方根"><a href="#2-6-Math-sqrt-平方根" class="headerlink" title="2.6 Math.sqrt() 平方根"></a>2.6 Math.sqrt() 平方根</h3><p><code>Math.sqrt</code>方法<strong>返回参数值的平方根</strong>。如果参数是一个负值，则返回<code>NaN</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">sqrt</span>(<span class="number">4</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">sqrt</span>(-<span class="number">4</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h3 id="2-7-Math-log-自然对数"><a href="#2-7-Math-log-自然对数" class="headerlink" title="2.7 Math.log() 自然对数"></a>2.7 Math.log() 自然对数</h3><p><code>Math.log</code>方法返回以<code>e</code>为底的自然对数值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="property">E</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">log</span>(<span class="number">10</span>) <span class="comment">// 2.302585092994046</span></span><br></pre></td></tr></table></figure>

<p>如果要计算以10为底的对数，可以先用<code>Math.log</code>求出自然对数，然后除以<code>Math.LN10</code>；求以2为底的对数，可以除以<code>Math.LN2</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">log</span>(<span class="number">100</span>)/<span class="title class_">Math</span>.<span class="property">LN10</span> <span class="comment">// 2</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">log</span>(<span class="number">8</span>)/<span class="title class_">Math</span>.<span class="property">LN2</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h3 id="2-8-Math-exp-e的指数"><a href="#2-8-Math-exp-e的指数" class="headerlink" title="2.8 Math.exp() e的指数"></a>2.8 Math.exp() <code>e</code>的指数</h3><p><code>Math.exp</code>方法返回常数<code>e</code>的参数次方。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">exp</span>(<span class="number">1</span>) <span class="comment">// 2.718281828459045</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">exp</span>(<span class="number">3</span>) <span class="comment">// 20.085536923187668</span></span><br></pre></td></tr></table></figure>

<h3 id="2-9-Math-random-0到1的随机数（可能等于0，但一定小于1）"><a href="#2-9-Math-random-0到1的随机数（可能等于0，但一定小于1）" class="headerlink" title="2.9 Math.random() 0到1的随机数（可能等于0，但一定小于1）"></a>2.9 Math.random() 0到1的随机数（可能等于0，但一定小于1）</h3><p><code>Math.random()</code>返回<strong>0到1之间的一个伪随机数</strong>，可能等于0，但是一定小于1。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">random</span>() <span class="comment">// 0.7151307314634323</span></span><br></pre></td></tr></table></figure>

<p><strong>任意范围的随机数生成函数</strong>如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getRandomArbitrary</span>(<span class="params">min, max</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">random</span>() * (max - min) + min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getRandomArbitrary</span>(<span class="number">1.5</span>, <span class="number">6.5</span>)</span><br><span class="line"><span class="comment">// 2.4942810038223864</span></span><br></pre></td></tr></table></figure>

<p><strong>任意范围的随机整数生成函数</strong>如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getRandomInt</span>(<span class="params">min, max</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (max - min + <span class="number">1</span>)) + min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getRandomInt</span>(<span class="number">1</span>, <span class="number">6</span>) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>返回<strong>随机字符</strong>的例子如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">random_str</span>(<span class="params">length</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="variable constant_">ALPHABET</span> = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="line">  <span class="variable constant_">ALPHABET</span> += <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span>;</span><br><span class="line">  <span class="variable constant_">ALPHABET</span> += <span class="string">&#x27;0123456789-_&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> str = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">    <span class="keyword">var</span> rand = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="variable constant_">ALPHABET</span>.<span class="property">length</span>);</span><br><span class="line">    str += <span class="variable constant_">ALPHABET</span>.<span class="title function_">substring</span>(rand, rand + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">random_str</span>(<span class="number">6</span>) <span class="comment">// &quot;NdQKOr&quot; 参数为指定字符长度</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>random_str</code>函数接受一个整数作为参数，返回变量<code>ALPHABET</code>内的随机字符所组成的指定长度的字符串。</p>
<h3 id="2-10-三角函数方法"><a href="#2-10-三角函数方法" class="headerlink" title="2.10 三角函数方法"></a>2.10 三角函数方法</h3><p><code>Math</code>对象还提供一系列三角函数方法。</p>
<ul>
<li><code>Math.sin()</code>：返回参数的正弦（参数为弧度值）</li>
<li><code>Math.cos()</code>：返回参数的余弦（参数为弧度值）</li>
<li><code>Math.tan()</code>：返回参数的正切（参数为弧度值）</li>
<li><code>Math.asin()</code>：返回参数的反正弦（返回值为弧度值）</li>
<li><code>Math.acos()</code>：返回参数的反余弦（返回值为弧度值）</li>
<li><code>Math.atan()</code>：返回参数的反正切（返回值为弧度值）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">sin</span>(<span class="number">0</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">cos</span>(<span class="number">0</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">tan</span>(<span class="number">0</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">sin</span>(<span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">2</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">asin</span>(<span class="number">1</span>) <span class="comment">// 1.5707963267948966</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">acos</span>(<span class="number">1</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">atan</span>(<span class="number">1</span>) <span class="comment">// 0.7853981633974483</span></span><br></pre></td></tr></table></figure>

<p>三角函数的应用相关知识：&lt; <a href="https://www.w3cplus.com/javascript/trigonometry-you-must-know.html">https://www.w3cplus.com/javascript/trigonometry-you-must-know.html</a> &gt;</p>
<h2 id="九、Date对象"><a href="#九、Date对象" class="headerlink" title="九、Date对象"></a>九、Date对象</h2><p> <code>Date</code>对象是 JavaScript 原生的时间库。它以国际标准时间（UTC）1970年1月1日00:00:00作为时间的零点，可以表示的时间范围是前后各1亿天（单位为毫秒）。</p>
<h2 id="1、普通函数的用法"><a href="#1、普通函数的用法" class="headerlink" title="1、普通函数的用法"></a>1、普通函数的用法</h2><p><code>Date</code>对象可以作为普通函数直接调用，返回一个代表当前时间的<strong>字符串</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Date</span>()</span><br><span class="line"><span class="comment">// &quot;Tue Dec 01 2015 09:34:43 GMT+0800 (CST)&quot; 字符串类型</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>，即使带有参数，<code>Date</code>作为普通函数使用时，返回的还是当前时间。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Date</span>(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 作为普通函数使用时带有参数返回的也是当前时间</span></span><br><span class="line"><span class="comment">// &quot;Tue Dec 01 2015 09:34:43 GMT+0800 (CST)&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码说明，<strong>无论有没有参数，直接调用<code>Date</code>总是返回当前时间</strong>。</p>
<h2 id="2、构造函数的用法"><a href="#2、构造函数的用法" class="headerlink" title="2、构造函数的用法"></a>2、构造函数的用法</h2><p><code>Date</code>还可以当作构造函数使用。对它使用<code>new</code>命令，会返回一个<code>Date</code>对象的实例。如果不加参数，实例代表的就是当前时间。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> today = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br></pre></td></tr></table></figure>

<p><code>Date</code>实例有一个独特的地方。其他对象求值的时候，都是默认调用<code>.valueOf()</code>方法，但是<code>Date</code>实例求值的时候，默认调用的是<code>toString()</code>方法。这导致对<code>Date</code>实例求值，返回的是一个字符串，代表该实例对应的时间。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> today = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line">today</span><br><span class="line"><span class="comment">// &quot;Tue Dec 01 2015 09:34:43 GMT+0800 (CST)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">today.<span class="title function_">toString</span>()</span><br><span class="line"><span class="comment">// &quot;Tue Dec 01 2015 09:34:43 GMT+0800 (CST)&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>today</code>是<code>Date</code>的实例，<strong>直接求值等同于调用<code>toString</code>方法</strong>。</p>
<p>作为构造函数时，<code>Date</code>对象可<strong>以接受多种格式的参数</strong>，返回一个该参数对应的时间实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数为时间零点开始计算的毫秒数</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1378218728000</span>)</span><br><span class="line"><span class="comment">// Tue Sep 03 2013 22:32:08 GMT+0800 (CST)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数为日期字符串</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;January 6, 2013&#x27;</span>);</span><br><span class="line"><span class="comment">// Sun Jan 06 2013 00:00:00 GMT+0800 (CST)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数为多个整数，</span></span><br><span class="line"><span class="comment">// 代表年、月、日、小时、分钟、秒、毫秒</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>

<p>关于<code>Date</code>构造函数的参数，有几点说明。</p>
<p><strong>第一点</strong>，参数可以是负整数，代表1970年元旦之前的时间。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(-<span class="number">1378218728000</span>)</span><br><span class="line"><span class="comment">// Fri Apr 30 1926 17:27:52 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>

<p><strong>第二点</strong>，只要是能被<code>Date.parse()</code>方法解析的字符串，都可以当作参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2013-2-15&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2013/2/15&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;02/15/2013&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2013-FEB-15&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;FEB, 15, 2013&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;FEB 15, 2013&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;February, 15, 2013&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;February 15, 2013&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;15 Feb 2013&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;15, February, 2013&#x27;</span>)</span><br><span class="line"><span class="comment">// Fri Feb 15 2013 00:00:00 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>

<p>上面多种日期字符串的写法，返回的都是同一个时间。</p>
<p><strong>第三</strong>，参数为年、月、日等多个整数时，年和月是不能省略的，其他参数都可以省略的。也就是说，这时至少需要两个参数，因为如果只使用“年”这一个参数，<code>Date</code>会将其解释为毫秒数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2013</span>) <span class="comment">// 只有一个数字的参数会解释为毫秒数</span></span><br><span class="line"><span class="comment">// Thu Jan 01 1970 08:00:02 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，2013被解释为毫秒数，而不是年份。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2013</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，不管有几个参数，返回的都是2013年1月1日零点。</p>
<p>最后，各个参数的取值范围如下。</p>
<ul>
<li>年：使用四位数年份，比如<code>2000</code>。如果写成两位数或个位数，则加上<code>1900</code>，即<code>10</code>代表1910年。如果是负数，表示公元前。</li>
<li>月：**<code>0</code>表示一月，依次类推，<code>11</code>表示12月**。</li>
<li>日：<code>1</code>到<code>31</code>。</li>
<li>小时：<code>0</code>到<code>23</code>。</li>
<li>分钟：<code>0</code>到<code>59</code>。</li>
<li>秒：<code>0</code>到<code>59</code></li>
<li>毫秒：<code>0</code>到<code>999</code>。</li>
</ul>
<p>注意，月份从<code>0</code>开始计算，但是，天数从<code>1</code>开始计算。另外，除了日期的默认值为<code>1</code>，小时、分钟、秒钟和毫秒的默认值都是<code>0</code>。</p>
<p>这些参数如果超出了正常范围，会被自动折算。比如，如果月设为<code>15</code>，就折算为下一年的4月。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2013</span>, <span class="number">15</span>)</span><br><span class="line"><span class="comment">// Tue Apr 01 2014 00:00:00 GMT+0800 (CST)</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// Mon Dec 31 2012 00:00:00 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>

<p>上面代码的第二个例子，日期设为<code>0</code>，就代表上个月的最后一天。</p>
<p>参数还可以使用负数，表示扣去的时间。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2013</span>, -<span class="number">1</span>)</span><br><span class="line"><span class="comment">// Sat Dec 01 2012 00:00:00 GMT+0800 (CST)</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line"><span class="comment">// Sun Dec 30 2012 00:00:00 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，分别对月和日使用了负数，表示从基准日扣去相应的时间。</p>
<h2 id="3、日期的运算"><a href="#3、日期的运算" class="headerlink" title="3、日期的运算"></a>3、日期的运算</h2><p>类型自动转换时，<code>Date</code>实例如果转为数值，则等于对应的毫秒数；如果转为字符串，则等于对应的日期字符串。所以，两个日期实例对象进行减法运算时，返回的是它们间隔的毫秒数；进行加法运算时，返回的是两个字符串连接而成的新字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d1 = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2000</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> d2 = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2000</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">d2 - d1 <span class="comment">// 减法运算返回毫秒数</span></span><br><span class="line"><span class="comment">// 2678400000</span></span><br><span class="line">d2 + d1 <span class="comment">// 加法运算返回日期字符串</span></span><br><span class="line"><span class="comment">// &quot;Sat Apr 01 2000 00:00:00 GMT+0800 (CST)Wed Mar 01 2000 00:00:00 GMT+0800 (CST)&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="4、静态方法"><a href="#4、静态方法" class="headerlink" title="4、静态方法"></a>4、静态方法</h2><h3 id="4-1-Date-now-当前时间戳"><a href="#4-1-Date-now-当前时间戳" class="headerlink" title="4.1 Date.now() 当前时间戳"></a>4.1 Date.now() 当前时间戳</h3><p><code>Date.now</code>方法<strong>返回当前时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数（即时间戳）</strong>，相当于 Unix 时间戳乘以1000。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Date</span>.<span class="title function_">now</span>() <span class="comment">// 1364026285194</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-Date-parse-解析日期字符串，返回该时间点的时间戳"><a href="#4-2-Date-parse-解析日期字符串，返回该时间点的时间戳" class="headerlink" title="4.2 Date.parse() 解析日期字符串，返回该时间点的时间戳"></a>4.2 Date.parse() 解析日期字符串，返回该时间点的时间戳</h3><p><code>Date.parse</code>方法用来<strong>解析日期字符串，返回该时间距离时间零点（1970年1月1日 00:00:00）的毫秒数</strong>。</p>
<p>日期字符串应该符合 RFC 2822 和 ISO 8061 这两个标准，即<code>YYYY-MM-DDTHH:mm:ss.sssZ</code>格式，其中最后的<code>Z</code>表示时区。但是，其他格式也可以被解析，请看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Date</span>.<span class="title function_">parse</span>(<span class="string">&#x27;Aug 9, 1995&#x27;</span>)</span><br><span class="line"><span class="title class_">Date</span>.<span class="title function_">parse</span>(<span class="string">&#x27;January 26, 2011 13:51:50&#x27;</span>)</span><br><span class="line"><span class="title class_">Date</span>.<span class="title function_">parse</span>(<span class="string">&#x27;Mon, 25 Dec 1995 13:30:00 GMT&#x27;</span>)</span><br><span class="line"><span class="title class_">Date</span>.<span class="title function_">parse</span>(<span class="string">&#x27;Mon, 25 Dec 1995 13:30:00 +0430&#x27;</span>)</span><br><span class="line"><span class="title class_">Date</span>.<span class="title function_">parse</span>(<span class="string">&#x27;2011-10-10&#x27;</span>)</span><br><span class="line"><span class="title class_">Date</span>.<span class="title function_">parse</span>(<span class="string">&#x27;2011-10-10T14:48:00&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>上面的日期字符串都可以解析。</p>
<p>如果解析失败，返回<code>NaN</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Date</span>.<span class="title function_">parse</span>(<span class="string">&#x27;xxx&#x27;</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-Date-UTC-以年、月、日等变量作为参数，返回该时间点的时间戳"><a href="#4-3-Date-UTC-以年、月、日等变量作为参数，返回该时间点的时间戳" class="headerlink" title="4.3 Date.UTC() 以年、月、日等变量作为参数，返回该时间点的时间戳"></a>4.3 Date.UTC() 以年、月、日等变量作为参数，返回该时间点的时间戳</h3><p><code>Date.UTC</code>方法<strong>接受年、月、日等变量作为参数，返回该时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 格式</span></span><br><span class="line"><span class="title class_">Date</span>.<span class="title function_">UTC</span>(year, month[, date[, hrs[, min[, sec[, ms]]]]])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="title class_">Date</span>.<span class="title function_">UTC</span>(<span class="number">2011</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">567</span>)</span><br><span class="line"><span class="comment">// 1293847384567</span></span><br></pre></td></tr></table></figure>

<p>该方法的参数用法与<code>Date</code>构造函数完全一致，比如月从<code>0</code>开始计算，日期从<code>1</code>开始计算。区别在于<code>Date.UTC</code>方法的参数，会被解释为 UTC 时间（世界标准时间），<code>Date</code>构造函数的参数会被解释为当前时区的时间。</p>
<h2 id="5、实例方法"><a href="#5、实例方法" class="headerlink" title="5、实例方法"></a>5、实例方法</h2><p><code>Date</code>的实例对象，有几十个自己的方法，除了<code>valueOf</code>和<code>toString</code>，可以分为以下三类。</p>
<ul>
<li><code>to</code>类：从<code>Date</code>对象返回一个字符串，表示指定的时间。</li>
<li><code>get</code>类：获取<code>Date</code>对象的日期和时间。</li>
<li><code>set</code>类：设置<code>Date</code>对象的日期和时间。</li>
</ul>
<h3 id="5-1-Date-prototype-valueOf-返回时间戳，等同于getTime-。（减法运算默认调用）"><a href="#5-1-Date-prototype-valueOf-返回时间戳，等同于getTime-。（减法运算默认调用）" class="headerlink" title="5.1 Date.prototype.valueOf() 返回时间戳，等同于getTime()。（减法运算默认调用）"></a>5.1 Date.prototype.valueOf() 返回时间戳，等同于getTime()。（减法运算默认调用）</h3><p><code>valueOf</code>方法<strong>返回实例对象距离时间零点（1970年1月1日00:00:00 UTC）对应的毫秒数</strong>，该方法等同于<code>getTime</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line">d.<span class="title function_">valueOf</span>() <span class="comment">// 1362790014817</span></span><br><span class="line">d.<span class="title function_">getTime</span>() <span class="comment">// 1362790014817</span></span><br></pre></td></tr></table></figure>

<p>预期为数值的场合，<code>Date</code>实例会自动调用该方法，所以<strong>可以用下面的方法计算时间的间隔</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">var</span> end = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">var</span> elapsed = end - start; <span class="comment">// 自动调用valueOf()方法，返回时间戳的减法运算</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-to-类方法（返回字符串相关）"><a href="#5-2-to-类方法（返回字符串相关）" class="headerlink" title="5.2 to 类方法（返回字符串相关）"></a>5.2 to 类方法（返回字符串相关）</h3><h4 id="（1）Date-prototype-toString-返回一个完整的日期字符串（直接读取实例默认调用此方法）"><a href="#（1）Date-prototype-toString-返回一个完整的日期字符串（直接读取实例默认调用此方法）" class="headerlink" title="（1）Date.prototype.toString() 返回一个完整的日期字符串（直接读取实例默认调用此方法）"></a>（1）Date.prototype.toString() 返回一个完整的日期字符串（直接读取实例默认调用此方法）</h4><p><code>toString</code>方法<strong>返回一个完整的日期字符串</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var d = new Date(2013, 0, 1);</span><br><span class="line"></span><br><span class="line">d.toString()</span><br><span class="line">// &quot;Tue Jan 01 2013 00:00:00 GMT+0800 (CST)&quot;</span><br><span class="line">d</span><br><span class="line">// &quot;Tue Jan 01 2013 00:00:00 GMT+0800 (CST)&quot;</span><br></pre></td></tr></table></figure>

<p>因为<code>toString</code>是<strong>默认的调用方法</strong>，所以如果<strong>直接读取<code>Date</code>实例，就相当于调用这个方法</strong>。</p>
<h4 id="（2）Date-prototype-toUTCString-返回对应的UTC时间（世界标准时），比北京时间晚8小时"><a href="#（2）Date-prototype-toUTCString-返回对应的UTC时间（世界标准时），比北京时间晚8小时" class="headerlink" title="（2）Date.prototype.toUTCString() 返回对应的UTC时间（世界标准时），比北京时间晚8小时"></a>（2）Date.prototype.toUTCString() 返回对应的UTC时间（世界标准时），比北京时间晚8小时</h4><p><code>toUTCString</code>方法返回对应的 UTC 时间，也就是比北京时间晚8个小时。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">d.<span class="title function_">toUTCString</span>()</span><br><span class="line"><span class="comment">// &quot;Mon, 31 Dec 2012 16:00:00 GMT&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="（3）Date-prototype-toISOString-返回对应时间的-ISO8601-写法（UTC时间）"><a href="#（3）Date-prototype-toISOString-返回对应时间的-ISO8601-写法（UTC时间）" class="headerlink" title="（3）Date.prototype.toISOString() 返回对应时间的 ISO8601 写法（UTC时间）"></a>（3）Date.prototype.toISOString() 返回对应时间的 ISO8601 写法（UTC时间）</h4><p><code>toISOString</code>方法返回对应时间的 ISO8601 写法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">d.<span class="title function_">toISOString</span>()</span><br><span class="line"><span class="comment">// &quot;2012-12-31T16:00:00.000Z&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意，<code>toISOString</code>方法返回的总是 UTC 时区的时间。</strong></p>
<h4 id="（4）Date-prototype-toJSON-返回符合JSON格式字符串，与toISOString方法的返回结果完全相同。"><a href="#（4）Date-prototype-toJSON-返回符合JSON格式字符串，与toISOString方法的返回结果完全相同。" class="headerlink" title="（4）Date.prototype.toJSON() 返回符合JSON格式字符串，与toISOString方法的返回结果完全相同。"></a>（4）Date.prototype.toJSON() 返回符合JSON格式字符串，与<code>toISOString</code>方法的返回结果完全相同。</h4><p><code>toJSON</code>方法返回一个符合 JSON 格式的 ISO 日期字符串，与<code>toISOString</code>方法的返回结果完全相同。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">d.<span class="title function_">toJSON</span>()</span><br><span class="line"><span class="comment">// &quot;2012-12-31T16:00:00.000Z&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="（5）Date-prototype-toDateString-返回日期字符串（不含时分秒）"><a href="#（5）Date-prototype-toDateString-返回日期字符串（不含时分秒）" class="headerlink" title="（5）Date.prototype.toDateString() 返回日期字符串（不含时分秒）"></a>（5）Date.prototype.toDateString() 返回日期字符串（不含时分秒）</h4><p><code>toDateString</code>方法<strong>返回日期字符串（不含小时、分和秒）</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">d.<span class="title function_">toDateString</span>() <span class="comment">// &quot;Tue Jan 01 2013&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="（6）Date-prototype-toTimeString-返回时间字符串（不含年月日）"><a href="#（6）Date-prototype-toTimeString-返回时间字符串（不含年月日）" class="headerlink" title="（6）Date.prototype.toTimeString() 返回时间字符串（不含年月日）"></a>（6）Date.prototype.toTimeString() 返回时间字符串（不含年月日）</h4><p><code>toTimeString</code>方法<strong>返回时间字符串（不含年月日）</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">d.<span class="title function_">toTimeString</span>() <span class="comment">// &quot;00:00:00 GMT+0800 (CST)&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="（7）本地时间"><a href="#（7）本地时间" class="headerlink" title="（7）本地时间"></a>（7）本地时间</h4><p>以下三种方法，可以将 Date 实例转为表示本地时间的字符串。</p>
<ul>
<li><code>Date.prototype.toLocaleString()</code>：完整的本地时间。</li>
<li><code>Date.prototype.toLocaleDateString()</code>：本地日期（不含小时、分和秒）。</li>
<li><code>Date.prototype.toLocaleTimeString()</code>：本地时间（不含年月日）。</li>
</ul>
<p>下面是用法实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">d.<span class="title function_">toLocaleString</span>()</span><br><span class="line"><span class="comment">// 中文版浏览器为&quot;2013年1月1日 上午12:00:00&quot;</span></span><br><span class="line"><span class="comment">// 英文版浏览器为&quot;1/1/2013 12:00:00 AM&quot;</span></span><br><span class="line"></span><br><span class="line">d.<span class="title function_">toLocaleDateString</span>()</span><br><span class="line"><span class="comment">// 中文版浏览器为&quot;2013年1月1日&quot;</span></span><br><span class="line"><span class="comment">// 英文版浏览器为&quot;1/1/2013&quot;</span></span><br><span class="line"></span><br><span class="line">d.<span class="title function_">toLocaleTimeString</span>()</span><br><span class="line"><span class="comment">// 中文版浏览器为&quot;上午12:00:00&quot;</span></span><br><span class="line"><span class="comment">// 英文版浏览器为&quot;12:00:00 AM&quot;</span></span><br></pre></td></tr></table></figure>

<p>这三个方法都有两个可选的参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dateObj.<span class="title function_">toLocaleString</span>([locales[, options]])</span><br><span class="line">dateObj.<span class="title function_">toLocaleDateString</span>([locales[, options]])</span><br><span class="line">dateObj.<span class="title function_">toLocaleTimeString</span>([locales[, options]])</span><br></pre></td></tr></table></figure>

<p>这两个参数中，<code>locales</code>是一个<strong>指定所用语言的字符串</strong>，<code>options</code>是一个<strong>配置对象</strong>。下面是<code>locales</code>的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">d.<span class="title function_">toLocaleString</span>(<span class="string">&#x27;en-US&#x27;</span>) <span class="comment">// &quot;1/1/2013, 12:00:00 AM&quot;</span></span><br><span class="line">d.<span class="title function_">toLocaleString</span>(<span class="string">&#x27;zh-CN&#x27;</span>) <span class="comment">// &quot;2013/1/1 上午12:00:00&quot;</span></span><br><span class="line"></span><br><span class="line">d.<span class="title function_">toLocaleDateString</span>(<span class="string">&#x27;en-US&#x27;</span>) <span class="comment">// &quot;1/1/2013&quot;</span></span><br><span class="line">d.<span class="title function_">toLocaleDateString</span>(<span class="string">&#x27;zh-CN&#x27;</span>) <span class="comment">// &quot;2013/1/1&quot;</span></span><br><span class="line"></span><br><span class="line">d.<span class="title function_">toLocaleTimeString</span>(<span class="string">&#x27;en-US&#x27;</span>) <span class="comment">// &quot;12:00:00 AM&quot;</span></span><br><span class="line">d.<span class="title function_">toLocaleTimeString</span>(<span class="string">&#x27;zh-CN&#x27;</span>) <span class="comment">// &quot;上午12:00:00&quot;</span></span><br></pre></td></tr></table></figure>

<p>下面是<code>options</code>的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间格式</span></span><br><span class="line"><span class="comment">// 下面的设置是，星期和月份为完整文字，年份和日期为数字</span></span><br><span class="line">d.<span class="title function_">toLocaleDateString</span>(<span class="string">&#x27;en-US&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">weekday</span>: <span class="string">&#x27;long&#x27;</span>,</span><br><span class="line">  <span class="attr">year</span>: <span class="string">&#x27;numeric&#x27;</span>,</span><br><span class="line">  <span class="attr">month</span>: <span class="string">&#x27;long&#x27;</span>,</span><br><span class="line">  <span class="attr">day</span>: <span class="string">&#x27;numeric&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &quot;Tuesday, January 1, 2013&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定时区</span></span><br><span class="line">d.<span class="title function_">toLocaleTimeString</span>(<span class="string">&#x27;en-US&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">timeZone</span>: <span class="string">&#x27;UTC&#x27;</span>,</span><br><span class="line">  <span class="attr">timeZoneName</span>: <span class="string">&#x27;short&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &quot;4:00:00 PM UTC&quot;</span></span><br><span class="line"></span><br><span class="line">d.<span class="title function_">toLocaleTimeString</span>(<span class="string">&#x27;en-US&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">timeZone</span>: <span class="string">&#x27;Asia/Shanghai&#x27;</span>,</span><br><span class="line">  <span class="attr">timeZoneName</span>: <span class="string">&#x27;long&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &quot;12:00:00 AM China Standard Time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 小时周期为12还是24</span></span><br><span class="line">d.<span class="title function_">toLocaleTimeString</span>(<span class="string">&#x27;en-US&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">hour12</span>: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &quot;00:00:00&quot;</span></span><br><span class="line"></span><br><span class="line">d.<span class="title function_">toLocaleTimeString</span>(<span class="string">&#x27;en-US&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">hour12</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &quot;12:00:00 AM&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="5-3-get类-（获取年、月、日、时、分、秒等）"><a href="#5-3-get类-（获取年、月、日、时、分、秒等）" class="headerlink" title="5.3 get类 （获取年、月、日、时、分、秒等）"></a>5.3 get类 （获取年、月、日、时、分、秒等）</h3><p><code>Date</code>对象提供了一系列<code>get*</code>方法，用来获取实例对象某个方面的值。</p>
<ul>
<li><code>getTime()</code>：返回实例距离1970年1月1日00:00:00的毫秒数，等同于<code>valueOf</code>方法。<strong>（时间戳）</strong></li>
<li><code>getDate()</code>：返回实例对象对应每个月的几号（从1开始）。<strong>（日）</strong></li>
<li><code>getDay()</code>：返回星期几，星期日为0，星期一为1，以此类推。<strong>（星期）</strong></li>
<li><code>getFullYear()</code>：返回四位的年份。<strong>（年）</strong></li>
<li><code>getMonth()</code>：返回月份（0表示1月，11表示12月）。<strong>（月）</strong></li>
<li><code>getHours()</code>：返回小时（0-23）。<strong>（时）</strong></li>
<li><code>getMilliseconds()</code>：返回毫秒（0-999）。<strong>（毫秒）</strong></li>
<li><code>getMinutes()</code>：返回分钟（0-59）。<strong>（分）</strong></li>
<li><code>getSeconds()</code>：返回秒（0-59）。<strong>（秒）</strong></li>
<li><code>getTimezoneOffset()</code>：返回当前时间与 UTC 的时区差异，以分钟表示，返回结果考虑到了夏令时因素。<strong>（与UTC差异）</strong></li>
</ul>
<p>所有这些<code>get*</code>方法返回的都是<strong>整数</strong>，不同方法返回值的范围不一样。</p>
<ul>
<li>分钟和秒：0 到 59</li>
<li>小时：0 到 23</li>
<li>星期：0（星期天）到 6（星期六）</li>
<li>日期：1 到 31</li>
<li>月份：0（一月）到 11（十二月）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;January 6, 2013&#x27;</span>);</span><br><span class="line"></span><br><span class="line">d.<span class="title function_">getDate</span>() <span class="comment">// 6</span></span><br><span class="line">d.<span class="title function_">getMonth</span>() <span class="comment">// 0</span></span><br><span class="line">d.<span class="title function_">getFullYear</span>() <span class="comment">// 2013</span></span><br><span class="line">d.<span class="title function_">getTimezoneOffset</span>() <span class="comment">// -480   UTC时间减去当前时间，单位是分钟</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，最后一行返回<code>-480</code>，即 UTC 时间减去当前时间，单位是分钟。<code>-480</code>表示 UTC 比当前时间少480分钟，即当前时区比 UTC 早8个小时。</p>
<h6 id="例子：计算本年度还剩下多少天"><a href="#例子：计算本年度还剩下多少天" class="headerlink" title="例子：计算本年度还剩下多少天"></a>例子：计算本年度还剩下多少天</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">leftDays</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> today = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">  <span class="keyword">var</span> endYear = <span class="keyword">new</span> <span class="title class_">Date</span>(today.<span class="title function_">getFullYear</span>(), <span class="number">11</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999</span>);</span><br><span class="line">  <span class="keyword">var</span> msPerDay = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>; <span class="comment">// 一天的毫秒数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">round</span>((endYear.<span class="title function_">getTime</span>() - today.<span class="title function_">getTime</span>()) / msPerDay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这些<code>get*</code>方法返回的都是当前时区的时间，<code>Date</code>对象还提供了这些方法对应的 UTC 版本，用来返回 UTC 时间。</p>
<p><strong>获取UTC时区相关方法：</strong></p>
<ul>
<li><code>getUTCDate()</code></li>
<li><code>getUTCFullYear()</code></li>
<li><code>getUTCMonth()</code></li>
<li><code>getUTCDay()</code></li>
<li><code>getUTCHours()</code></li>
<li><code>getUTCMinutes()</code></li>
<li><code>getUTCSeconds()</code></li>
<li><code>getUTCMilliseconds()</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;January 6, 2013&#x27;</span>);</span><br><span class="line"></span><br><span class="line">d.<span class="title function_">getDate</span>() <span class="comment">// 6</span></span><br><span class="line">d.<span class="title function_">getUTCDate</span>() <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，实例对象<code>d</code>表示当前时区（东八时区）的1月6日0点0分0秒，这个时间对于当前时区来说是1月6日，所以<code>getDate</code>方法返回6，对于 UTC 时区来说是1月5日，所以<code>getUTCDate</code>方法返回5。</p>
<h3 id="5-4-set-类方法"><a href="#5-4-set-类方法" class="headerlink" title="5.4 set 类方法"></a>5.4 set 类方法</h3><p><code>Date</code>对象提供了一系列<code>set*</code>方法，用来设置实例对象的各个方面。</p>
<ul>
<li><code>setDate(date)</code>：设置实例对象对应的每个月的几<strong>号</strong>（1-31），返回改变后毫秒时间戳。</li>
<li><code>setFullYear(year [, month, date])</code>：设置四位<strong>年份</strong>。</li>
<li><code>setHours(hour [, min, sec, ms])</code>：设置<strong>小时</strong>（0-23）。</li>
<li><code>setMilliseconds()</code>：设置<strong>毫秒</strong>（0-999）。</li>
<li><code>setMinutes(min [, sec, ms])</code>：设置<strong>分钟</strong>（0-59）。</li>
<li><code>setMonth(month [, date])</code>：设置<strong>月份</strong>（0-11）。</li>
<li><code>setSeconds(sec [, ms])</code>：设置<strong>秒</strong>（0-59）。</li>
<li><code>setTime(milliseconds)</code>：设置<strong>毫秒时间戳</strong>。</li>
</ul>
<p>这些方法基本是跟<code>get*</code>方法一一对应的，但是没有<code>setDay</code>方法，因为星期几是计算出来的，而不是设置的。另外，需要注意的是，凡是涉及到设置月份，都是从0开始算的，即<code>0</code>是1月，<code>11</code>是12月。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span> (<span class="string">&#x27;January 6, 2013&#x27;</span>);</span><br><span class="line"></span><br><span class="line">d <span class="comment">// Sun Jan 06 2013 00:00:00 GMT+0800 (CST)</span></span><br><span class="line">d.<span class="title function_">setDate</span>(<span class="number">9</span>) <span class="comment">// 1357660800000</span></span><br><span class="line">d <span class="comment">// Wed Jan 09 2013 00:00:00 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>

<p><code>set*</code>方法的参数都会自动折算。以<code>setDate</code>为例，如果参数超过当月的最大天数，则向下一个月顺延，如果参数是负数，表示从上个月的最后一天开始减去的天数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d1 = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;January 6, 2013&#x27;</span>);</span><br><span class="line"></span><br><span class="line">d1.<span class="title function_">setDate</span>(<span class="number">32</span>) <span class="comment">// 1359648000000</span></span><br><span class="line">d1 <span class="comment">// Fri Feb 01 2013 00:00:00 GMT+0800 (CST)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d2 = <span class="keyword">new</span> <span class="title class_">Date</span> (<span class="string">&#x27;January 6, 2013&#x27;</span>);</span><br><span class="line"></span><br><span class="line">d.<span class="title function_">setDate</span>(-<span class="number">1</span>) <span class="comment">// 1356796800000</span></span><br><span class="line">d <span class="comment">// Sun Dec 30 2012 00:00:00 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>

<p><code>**set</code>类方法和<code>get</code>类方法，可以结合使用，得到相对时间。**</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将日期向后推1000天</span></span><br><span class="line">d.<span class="title function_">setDate</span>(d.<span class="title function_">getDate</span>() + <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 将时间设为6小时后</span></span><br><span class="line">d.<span class="title function_">setHours</span>(d.<span class="title function_">getHours</span>() + <span class="number">6</span>);</span><br><span class="line"><span class="comment">// 将年份设为去年</span></span><br><span class="line">d.<span class="title function_">setFullYear</span>(d.<span class="title function_">getFullYear</span>() - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><code>set*</code>系列方法除了<code>setTime()</code>，都有对应的 UTC 版本，即<strong>设置 UTC 时区的时间</strong>。</p>
<ul>
<li><code>setUTCDate()</code></li>
<li><code>setUTCFullYear()</code></li>
<li><code>setUTCHours()</code></li>
<li><code>setUTCMilliseconds()</code></li>
<li><code>setUTCMinutes()</code></li>
<li><code>setUTCMonth()</code></li>
<li><code>setUTCSeconds()</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;January 6, 2013&#x27;</span>);</span><br><span class="line">d.<span class="title function_">getUTCHours</span>() <span class="comment">// 16</span></span><br><span class="line">d.<span class="title function_">setUTCHours</span>(<span class="number">22</span>) <span class="comment">// 1357423200000</span></span><br><span class="line">d <span class="comment">// Sun Jan 06 2013 06:00:00 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，本地时区（东八时区）的1月6日0点0分，是 UTC 时区的前一天下午16点。设为 UTC 时区的22点以后，就变为本地时区的上午6点。</p>
<h2 id="十、RegExp-对象"><a href="#十、RegExp-对象" class="headerlink" title="十、RegExp 对象"></a>十、RegExp 对象</h2><p> <code>RegExp</code>对象提供正则表达式的功能。</p>
<h2 id="1、概述-5"><a href="#1、概述-5" class="headerlink" title="1、概述"></a>1、概述</h2><p><strong>正则表达式（regular expression）是一种表达文本模式（即字符串结构）的方法，有点像字符串的模板，常常用来按照“给定模式”匹配文本</strong>。比如，正则表达式给出一个 Email 地址的模式，然后用它来确定一个字符串是否为 Email 地址。JavaScript 的正则表达式体系是参照 Perl 5 建立的。</p>
<p><strong>新建正则表达式有两种方法：</strong></p>
<p><strong>一种是使用字面量，以斜杠表示开始和结束。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/xyz/</span>; <span class="comment">// 效率较高，且直观，推荐。</span></span><br></pre></td></tr></table></figure>

<p><strong>另一种是使用<code>RegExp</code>构造函数。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;xyz&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面两种写法是等价的，都新建了一个内容为<code>xyz</code>的正则表达式对象。它们的主要区别是，第一种方法在引擎编译代码时，就会新建正则表达式，第二种方法在运行时新建正则表达式，所以前者的效率较高。而且，前者比较便利和直观，所以实际应用中，基本上都采用字面量定义正则表达式。</p>
<p><code>RegExp</code>构造函数还可以接受第二个参数，表示修饰符（详细解释见下文）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;xyz&#x27;</span>, <span class="string">&#x27;i&#x27;</span>); <span class="comment">// i为修饰符</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/xyz/i</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，正则表达式<code>/xyz/</code>有一个修饰符<code>i</code>。</p>
<h2 id="2、实例属性"><a href="#2、实例属性" class="headerlink" title="2、实例属性"></a>2、实例属性</h2><p>正则对象的实例属性分成两类。</p>
<p>一类是<strong>修饰符相关</strong>，用于了解设置了什么修饰符。</p>
<ul>
<li><code>RegExp.prototype.ignoreCase</code>：返回一个布尔值，表示是否设置了<code>i</code>修饰符。</li>
<li><code>RegExp.prototype.global</code>：返回一个布尔值，表示是否设置了<code>g</code>修饰符。</li>
<li><code>RegExp.prototype.multiline</code>：返回一个布尔值，表示是否设置了<code>m</code>修饰符。</li>
<li><code>RegExp.prototype.flags</code>：返回一个字符串，包含了已经设置的所有修饰符，按字母排序。</li>
</ul>
<p>上面四个属性都是<strong>只读</strong>的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/abc/igm</span>;</span><br><span class="line"></span><br><span class="line">r.<span class="property">ignoreCase</span> <span class="comment">// true 是否设置i修饰符</span></span><br><span class="line">r.<span class="property">global</span> <span class="comment">// true 是否设置g修饰符</span></span><br><span class="line">r.<span class="property">multiline</span> <span class="comment">// true 是否设置m修饰符</span></span><br><span class="line">r.<span class="property">flags</span> <span class="comment">// &#x27;gim&#x27; 字符串，包含设置的所有修饰符，按字母排序</span></span><br></pre></td></tr></table></figure>

<p>另一类是与<strong>修饰符无关的属性</strong>，主要是下面两个。</p>
<ul>
<li><code>RegExp.prototype.lastIndex</code>：返回一个整数，表示下一次开始搜索的位置。该属性可读写，但是只在进行连续搜索时有意义，详细介绍请看后文。</li>
<li><code>RegExp.prototype.source</code>：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/abc/igm</span>;</span><br><span class="line"></span><br><span class="line">r.<span class="property">lastIndex</span> <span class="comment">// 0</span></span><br><span class="line">r.<span class="property">source</span> <span class="comment">// &quot;abc&quot; 正则表达式的字符串形式</span></span><br></pre></td></tr></table></figure>



<h2 id="3、实例方法-2"><a href="#3、实例方法-2" class="headerlink" title="3、实例方法"></a>3、实例方法</h2><h3 id="3-1-RegExp-prototype-test-当前模式是否匹配参数字符串，返回布尔值"><a href="#3-1-RegExp-prototype-test-当前模式是否匹配参数字符串，返回布尔值" class="headerlink" title="3.1 RegExp.prototype.test() 当前模式是否匹配参数字符串，返回布尔值"></a>3.1 RegExp.prototype.test() 当前模式是否匹配参数字符串，返回布尔值</h3><p>正则实例对象的<code>test</code>方法<strong>返回一个布尔值，表示当前模式是否能匹配参数字符串</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/cat/.<span class="title function_">test</span>(<span class="string">&#x27;cats and dogs&#x27;</span>) <span class="comment">// true 验证字符串是否包含cat</span></span><br></pre></td></tr></table></figure>

<p>上面代码验证参数字符串之中是否包含<code>cat</code>，结果返回<code>true</code>。</p>
<p>如果正则表达式带有<code>g</code>修饰符，则每一次<code>test</code>方法都从上一次结束的位置开始向后匹配。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/x/g</span>; <span class="comment">// 带有g全局匹配修饰符</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;_x_x&#x27;</span>;</span><br><span class="line"></span><br><span class="line">r.<span class="property">lastIndex</span> <span class="comment">// 0  下一次开始搜索的位置</span></span><br><span class="line">r.<span class="title function_">test</span>(s) <span class="comment">// true 内部原理：从0位置开始匹配，匹配到&#x27;x&#x27;在1位置，返回true，并把lastIndex属性设置为2，</span></span><br><span class="line"></span><br><span class="line">r.<span class="property">lastIndex</span> <span class="comment">// 2 下一次开始搜索的位置</span></span><br><span class="line">r.<span class="title function_">test</span>(s) <span class="comment">// true  内部原理：从2位置开始匹配，匹配到&#x27;x&#x27;在3位置，返回true，并把lastIndex属性设置为4</span></span><br><span class="line"></span><br><span class="line">r.<span class="property">lastIndex</span> <span class="comment">// 4 下一次开始搜索的位置</span></span><br><span class="line">r.<span class="title function_">test</span>(s) <span class="comment">// false 内部原理：从4位置开始匹配，匹配不到’x‘,返回false</span></span><br></pre></td></tr></table></figure>

<p>上面代码的正则表达式使用了<code>g</code>修饰符，表示是全局搜索，会有多个结果。接着，三次使用<code>test</code>方法，每一次开始搜索的位置都是上一次匹配的后一个位置。</p>
<p>带有<code>g</code>修饰符时，可以通过正则对象的<code>lastIndex</code>属性指定开始搜索的位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/x/g</span>;</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;_x_x&#x27;</span>;</span><br><span class="line"></span><br><span class="line">r.<span class="property">lastIndex</span> = <span class="number">4</span>; <span class="comment">// lastIndex属性可读写，改写后，test方法将从该位置开始匹配</span></span><br><span class="line">r.<span class="title function_">test</span>(s) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">r.<span class="property">lastIndex</span> <span class="comment">// 0  重置为0</span></span><br><span class="line">r.<span class="title function_">test</span>(s) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码指定从字符串的第五个位置开始搜索，这个位置为空，所以返回<code>false</code>。同时，<code>lastIndex</code>属性重置为<code>0</code>，所以第二次执行<code>r.test(s)</code>会返回<code>true</code>。</p>
<p><strong>注意</strong>，<strong>带有<code>g</code>修饰符时，正则表达式内部会记住上一次的<code>lastIndex</code>属性</strong>，这时不应该更换所要匹配的字符串，否则会有一些难以察觉的错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/bb/g</span>;</span><br><span class="line">r.<span class="title function_">test</span>(<span class="string">&#x27;bb&#x27;</span>) <span class="comment">// true  由于带有g修饰符，匹配后会把lastIndex属性修改为了2</span></span><br><span class="line">r.<span class="title function_">test</span>(<span class="string">&#x27;-bb-&#x27;</span>) <span class="comment">// false 从2位置开始匹配&#x27;bb&#x27;,并没有匹配到</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，由于正则表达式<code>r</code>是从上一次的<code>lastIndex</code>位置开始匹配，导致第二次执行<code>test</code>方法时出现预期以外的结果。</p>
<p><code>lastIndex</code>属性只对同一个正则表达式有效，所以下面这样写是错误的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="regexp">/a/g</span>.<span class="title function_">test</span>(<span class="string">&#x27;babaa&#x27;</span>)) count++;</span><br></pre></td></tr></table></figure>

<p>上面代码会导致无限循环，因为<code>while</code>循环的每次匹配条件都是一个新的正则表达式，导致<code>lastIndex</code>属性总是等于0。</p>
<p>如果正则模式是一个<strong>空字符串，则匹配所有字符串</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">test</span>(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h3 id="3-2-RegExp-prototype-exec-返回匹配结果，如匹配则返回一个数组，成员是匹配到的子字符串，否则返回null"><a href="#3-2-RegExp-prototype-exec-返回匹配结果，如匹配则返回一个数组，成员是匹配到的子字符串，否则返回null" class="headerlink" title="3.2 RegExp.prototype.exec() 返回匹配结果，如匹配则返回一个数组，成员是匹配到的子字符串，否则返回null"></a>3.2 RegExp.prototype.exec() 返回匹配结果，如匹配则返回一个数组，成员是匹配到的子字符串，否则返回null</h3><p>正则实例对象的<code>exec</code>方法，用来<strong>返回匹配结果。如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回<code>null</code>。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;_x_x&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/x/</span>;</span><br><span class="line"><span class="keyword">var</span> r2 = <span class="regexp">/y/</span>;</span><br><span class="line"></span><br><span class="line">r1.<span class="title function_">exec</span>(s) <span class="comment">// [&quot;x&quot;] 返回一个成员</span></span><br><span class="line">r2.<span class="title function_">exec</span>(s) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，正则对象<code>r1</code>匹配成功，返回一个数组，成员是匹配结果；正则对象<code>r2</code>匹配失败，返回<code>null</code>。</p>
<p><strong>如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员</strong>。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的<code>length</code>属性等于组匹配的数量再加1。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;_x_x&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> r = <span class="regexp">/_(x)/</span>; <span class="comment">// 含有圆括号，组匹配</span></span><br><span class="line"></span><br><span class="line">r.<span class="title function_">exec</span>(s) <span class="comment">// [&quot;_x&quot;, &quot;x&quot;]  返回多个成员，第一个成员是整个匹配的结果，第二个成员是圆括号匹配的结果</span></span><br></pre></td></tr></table></figure>

<p>上面代码的<code>exec</code>方法，返回一个数组。第一个成员是整个匹配的结果，第二个成员是圆括号匹配的结果。</p>
<p><code>exec</code>方法的返回数组还包含以下两个属性：</p>
<ul>
<li><code>input</code>：整个原字符串。</li>
<li><code>index</code>：整个模式匹配成功的开始位置（从0开始计数）。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/a(b+)a/</span>;</span><br><span class="line"><span class="keyword">var</span> arr = r.<span class="title function_">exec</span>(<span class="string">&#x27;_abbba_aba_&#x27;</span>);</span><br><span class="line"></span><br><span class="line">arr <span class="comment">// [&quot;abbba&quot;, &quot;bbb&quot;] // 第一个成员是整个匹配的结果，第二个成员是圆括号匹配的结果</span></span><br><span class="line"></span><br><span class="line">arr.<span class="property">index</span> <span class="comment">// 1  表示是在1位置开始匹配成功的</span></span><br><span class="line">arr.<span class="property">input</span> <span class="comment">// &quot;_abbba_aba_&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中的<code>index</code>属性等于1，是因为从原字符串的第二个位置开始匹配成功。</p>
<p>如果正则表达式加上<code>g</code>修饰符，则可以使用多次<code>exec</code>方法，下一次搜索的位置从上一次匹配成功结束的位置开始。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a/g</span>; <span class="comment">// 带&#x27;g&#x27;修饰符</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;abc_abc_abc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r1 = reg.<span class="title function_">exec</span>(str);</span><br><span class="line">r1 <span class="comment">// [&quot;a&quot;]</span></span><br><span class="line">r1.<span class="property">index</span> <span class="comment">// 0 在0位置匹配成功</span></span><br><span class="line">reg.<span class="property">lastIndex</span> <span class="comment">// 1  下一次匹配开始位置为1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r2 = reg.<span class="title function_">exec</span>(str);</span><br><span class="line">r2 <span class="comment">// [&quot;a&quot;]</span></span><br><span class="line">r2.<span class="property">index</span> <span class="comment">// 4 在4位置匹配成功</span></span><br><span class="line">reg.<span class="property">lastIndex</span> <span class="comment">// 5 下一次匹配开始位置为5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r3 = reg.<span class="title function_">exec</span>(str);</span><br><span class="line">r3 <span class="comment">// [&quot;a&quot;]</span></span><br><span class="line">r3.<span class="property">index</span> <span class="comment">// 8 在8位置匹配成功</span></span><br><span class="line">reg.<span class="property">lastIndex</span> <span class="comment">// 9 下一次匹配开始位置为9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r4 = reg.<span class="title function_">exec</span>(str);</span><br><span class="line">r4 <span class="comment">// null 没有匹配到返回null</span></span><br><span class="line">reg.<span class="property">lastIndex</span> <span class="comment">// 0 下一次匹配位置为0</span></span><br></pre></td></tr></table></figure>

<p>上面代码连续用了四次<code>exec</code>方法，前三次都是从上一次匹配结束的位置向后匹配。当第三次匹配结束以后，整个字符串已经到达尾部，匹配结果返回<code>null</code>，正则实例对象的<code>lastIndex</code>属性也重置为<code>0</code>，意味着第四次匹配将从头开始。</p>
<p>利用<code>g</code>修饰符允许多次匹配的特点，可以用一个循环完成全部匹配。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;abc_abc_abc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> match = reg.<span class="title function_">exec</span>(str);</span><br><span class="line">  <span class="keyword">if</span> (!match) <span class="keyword">break</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;#&#x27;</span> + match.<span class="property">index</span> + <span class="string">&#x27;:&#x27;</span> + match[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// #0:a</span></span><br><span class="line"><span class="comment">// #4:a</span></span><br><span class="line"><span class="comment">// #8:a</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，只要<code>exec</code>方法不返回<code>null</code>，就会一直循环下去，每次输出匹配的位置和匹配的文本。</p>
<p>正则实例对象的<code>lastIndex</code>属性不仅可读，还可写。设置了<code>g</code>修饰符的时候，只要手动设置了<code>lastIndex</code>的值，就会从指定位置开始匹配。</p>
<h2 id="4、字符串的实例方法"><a href="#4、字符串的实例方法" class="headerlink" title="4、字符串的实例方法"></a>4、字符串的实例方法</h2><p><strong>字符串的实例方法之中，有4种与正则表达式有关。</strong></p>
<ul>
<li><code>String.prototype.match()</code>：返回一个数组，成员是所有匹配的子字符串。</li>
<li><code>String.prototype.search()</code>：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。</li>
<li><code>String.prototype.replace()</code>：按照给定的正则表达式进行替换，返回替换后的字符串。</li>
<li><code>String.prototype.split()</code>：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。</li>
</ul>
<h3 id="4-1-String-prototype-match-匹配，返回匹配结果数组或null"><a href="#4-1-String-prototype-match-匹配，返回匹配结果数组或null" class="headerlink" title="4.1 String.prototype.match() 匹配，返回匹配结果数组或null"></a>4.1 String.prototype.match() 匹配，返回匹配结果数组或null</h3><p>字符串实例对象的<code>match</code>方法<strong>对字符串进行正则匹配，返回匹配结果</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;_x_x&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/x/</span>;</span><br><span class="line"><span class="keyword">var</span> r2 = <span class="regexp">/y/</span>;</span><br><span class="line"></span><br><span class="line">s.<span class="title function_">match</span>(r1) <span class="comment">// [&quot;x&quot;] // 未带g修饰符，匹配到一个即返回结果</span></span><br><span class="line">s.<span class="title function_">match</span>(r2) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>从上面代码可以看到，字符串的<code>match</code>方法与正则对象的<code>exec</code>方法非常类似：匹配成功返回一个数组，匹配失败返回<code>null</code>。</p>
<p>如果正则表达式带有<code>g</code>修饰符，则该方法与正则对象的<code>exec</code>方法行为不同，会一次性返回所有匹配成功的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;abba&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> r = <span class="regexp">/a/g</span>;</span><br><span class="line"></span><br><span class="line">s.<span class="title function_">match</span>(r) <span class="comment">// [&quot;a&quot;, &quot;a&quot;]  带g修饰符，会返回全部结果到数组成员</span></span><br><span class="line">r.<span class="title function_">exec</span>(s) <span class="comment">// [&quot;a&quot;] 正则实例的exec方法只返回一个</span></span><br></pre></td></tr></table></figure>

<p>设置<strong>正则表达式的<code>lastIndex</code>属性，对<code>match</code>方法无效</strong>，匹配总是从字符串的第一个字符开始。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/a|b/g</span>;</span><br><span class="line">r.<span class="property">lastIndex</span> = <span class="number">7</span>;</span><br><span class="line"><span class="string">&#x27;xaxb&#x27;</span>.<span class="title function_">match</span>(r) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;]</span></span><br><span class="line">r.<span class="property">lastIndex</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，设置正则对象的<code>lastIndex</code>属性是无效的。</p>
<h3 id="4-2-String-prototype-search-返回第一个满足匹配条件的位置，不满足则返-1"><a href="#4-2-String-prototype-search-返回第一个满足匹配条件的位置，不满足则返-1" class="headerlink" title="4.2 String.prototype.search() 返回第一个满足匹配条件的位置，不满足则返-1"></a>4.2 String.prototype.search() 返回第一个满足匹配条件的位置，不满足则返-1</h3><p>字符串对象的<code>search</code>方法，<strong>返回第一个满足条件的匹配结果在整个字符串中的位置</strong>。<strong>如果没有任何匹配，则返回<code>-1</code>。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;_x_x&#x27;</span>.<span class="title function_">search</span>(<span class="regexp">/x/</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，第一个匹配结果出现在字符串的<code>1</code>号位置。</p>
<h3 id="4-3-String-prototype-replace-替换匹配的值，参数一是子串或正则，参数二是替换内容"><a href="#4-3-String-prototype-replace-替换匹配的值，参数一是子串或正则，参数二是替换内容" class="headerlink" title="4.3 String.prototype.replace() 替换匹配的值，参数一是子串或正则，参数二是替换内容"></a>4.3 String.prototype.replace() 替换匹配的值，参数一是子串或正则，参数二是替换内容</h3><p>字符串对象的<code>replace</code>方法可以<strong>替换匹配的值</strong>。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">str.<span class="title function_">replace</span>(search, replacement)</span><br></pre></td></tr></table></figure>

<p>正则表达式如果不加<code>g</code>修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;aaa&#x27;</span>.<span class="title function_">replace</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>) <span class="comment">// &quot;baa&quot;</span></span><br><span class="line"><span class="string">&#x27;aaa&#x27;</span>.<span class="title function_">replace</span>(<span class="regexp">/a/</span>, <span class="string">&#x27;b&#x27;</span>) <span class="comment">// &quot;baa&quot; 不带g修饰符，只匹配并替换第一个</span></span><br><span class="line"><span class="string">&#x27;aaa&#x27;</span>.<span class="title function_">replace</span>(<span class="regexp">/a/g</span>, <span class="string">&#x27;b&#x27;</span>) <span class="comment">// &quot;bbb&quot; 带g修饰符，匹配全局，并替换全部匹配到的值</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，最后一个正则表达式使用了<code>g</code>修饰符，导致所有的<code>b</code>都被替换掉了。</p>
<p><code>replace</code>方法的一个应用，就是消除字符串首尾两端的空格。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;  #id div.class  &#x27;</span>;</span><br><span class="line"></span><br><span class="line">str.<span class="title function_">replace</span>(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;#id div.class&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>replace</code>方法的<strong>第二个参数可以使用美元符号<code>$</code>，用来指代所替换的内容</strong>。</p>
<ul>
<li><code>$&amp;</code>：匹配的子字符串。</li>
<li>$&#96;：匹配结果前面的文本。</li>
<li><code>$&#39;</code>：匹配结果后面的文本。</li>
<li><code>$n</code>：匹配成功的第<code>n</code>组内容，<code>n</code>是从1开始的自然数。</li>
<li><code>$$</code>：指代美元符号<code>$</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;hello world&#x27;</span>.<span class="title function_">replace</span>(<span class="regexp">/(\w+)\s(\w+)/</span>, <span class="string">&#x27;$2 $1&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;world hello&quot;</span></span><br><span class="line"><span class="comment">/*说明：</span></span><br><span class="line"><span class="comment">$n 用于组内容，$2为匹配到的第二组，即world； $1为匹配到的第一组，即hello</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="title function_">replace</span>(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;[$`-$&amp;-$\&#x27;-$$]&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;a[a-b-c-$]c&quot;</span></span><br><span class="line"><span class="comment">/*说明：</span></span><br><span class="line"><span class="comment">$`为匹配结果 b 前面的文本，即 a</span></span><br><span class="line"><span class="comment">$&amp;为匹配的子字符串，即 b</span></span><br><span class="line"><span class="comment">$’为匹配结果 b 后面的文本，即 c</span></span><br><span class="line"><span class="comment">$$代表$符号本身</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，第一个例子是将匹配的组互换位置，第二个例子是改写匹配的值。</p>
<p><code>replace</code>方法的第<strong>二个参数还可以是一个函数，将每一个匹配内容替换为函数返回值</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;3 and 5&#x27;</span>.<span class="title function_">replace</span>(<span class="regexp">/[0-9]+/g</span>, <span class="keyword">function</span> (<span class="params">match</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * match; <span class="comment">// match参数是匹配到的内容</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &quot;6 and 10&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;The quick brown fox jumped over the lazy dog.&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/quick|brown|lazy/ig</span>;</span><br><span class="line"></span><br><span class="line">a.<span class="title function_">replace</span>(pattern, <span class="keyword">function</span> <span class="title function_">replacer</span>(<span class="params">match</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> match.<span class="title function_">toUpperCase</span>();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// The QUICK BROWN fox jumped over the LAZY dog.</span></span><br></pre></td></tr></table></figure>

<p>作为<code>replace</code>方法第二个参数的替换函数，可以接受多个参数。其中，第一个参数是捕捉到的内容，第二个参数是捕捉到的组匹配（<strong>有多少个组匹配，就有多少个对应的参数</strong>）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置（比如从第五个位置开始），最后一个参数是原字符串。下面是一个网页模板替换的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> prices = &#123;</span><br><span class="line">  <span class="string">&#x27;p1&#x27;</span>: <span class="string">&#x27;$1.99&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;p2&#x27;</span>: <span class="string">&#x27;$9.99&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;p3&#x27;</span>: <span class="string">&#x27;$5.00&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> template = <span class="string">&#x27;&lt;span id=&quot;p1&quot;&gt;&lt;/span&gt;&#x27;</span></span><br><span class="line">  + <span class="string">&#x27;&lt;span id=&quot;p2&quot;&gt;&lt;/span&gt;&#x27;</span></span><br><span class="line">  + <span class="string">&#x27;&lt;span id=&quot;p3&quot;&gt;&lt;/span&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">template.<span class="title function_">replace</span>(</span><br><span class="line">  <span class="regexp">/(&lt;span id=&quot;)(.*?)(&quot;&gt;)(&lt;\/span&gt;)/g</span>,</span><br><span class="line">  <span class="keyword">function</span>(<span class="params">match, $1, $2, $3, $4, index, str</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> $1 + $2 + $3 + prices[$2] + $4;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// &quot;&lt;span id=&quot;p1&quot;&gt;$1.99&lt;/span&gt;&lt;span id=&quot;p2&quot;&gt;$9.99&lt;/span&gt;&lt;span id=&quot;p3&quot;&gt;$5.00&lt;/span&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 说明：</span></span><br><span class="line"><span class="comment">// match 整个匹配到的内容：&lt;span id=&quot;p*&quot;&gt;&lt;/span&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下参数分别是匹配到的组内容，有多少组就对应多少个参数</span></span><br><span class="line"><span class="comment">// $1 &lt;span id=&quot;</span></span><br><span class="line"><span class="comment">// $2  p1~p3</span></span><br><span class="line"><span class="comment">// $3  &quot;&gt;</span></span><br><span class="line"><span class="comment">// $4  &lt;/span&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 后面还可以接受两个参数：</span></span><br><span class="line"><span class="comment">// 倒数第二个是：捕捉到的内容(即match的内容)在整个字符串中的位置</span></span><br><span class="line"><span class="comment">// 最后一个是：原字符串</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码的捕捉模式中，有四个括号，所以会产生四个组匹配，在匹配函数中用<code>$1</code>到<code>$4</code>表示。匹配函数的作用是将价格插入模板中。</p>
<h3 id="4-4-String-prototype-split-按给定规则分割字符串，返回数组"><a href="#4-4-String-prototype-split-按给定规则分割字符串，返回数组" class="headerlink" title="4.4 String.prototype.split() 按给定规则分割字符串，返回数组"></a>4.4 String.prototype.split() 按给定规则分割字符串，返回数组</h3><p>字符串对象的<code>split</code>方法<strong>按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">str.<span class="title function_">split</span>(separator, [limit])</span><br></pre></td></tr></table></figure>

<p>该方法接受<strong>两个参数</strong>，第一个参数是正则表达式，表示分隔规则，第二个参数是返回数组的最大成员数（数组长度）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非正则分隔</span></span><br><span class="line"><span class="string">&#x27;a,  b,c, d&#x27;</span>.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;  b&#x27;, &#x27;c&#x27;, &#x27; d&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正则分隔，去除多余的空格</span></span><br><span class="line"><span class="string">&#x27;a,  b,c, d&#x27;</span>.<span class="title function_">split</span>(<span class="regexp">/, */</span>)</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定返回数组的最大成员（数组长度）</span></span><br><span class="line"><span class="string">&#x27;a,  b,c, d&#x27;</span>.<span class="title function_">split</span>(<span class="regexp">/, */</span>, <span class="number">2</span>)</span><br><span class="line">[ <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span> ]</span><br></pre></td></tr></table></figure>

<p>上面代码使用正则表达式，去除了子字符串的逗号后面的空格。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="string">&#x27;aaa*a*&#x27;</span>.<span class="title function_">split</span>(<span class="regexp">/a*/</span>)</span><br><span class="line"><span class="comment">// [ &#x27;&#x27;, &#x27;*&#x27;, &#x27;*&#x27; ]  分隔符，即被过滤的符号，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="string">&#x27;aaa**a*&#x27;</span>.<span class="title function_">split</span>(<span class="regexp">/a*/</span>)</span><br><span class="line"><span class="comment">// [&quot;&quot;, &quot;*&quot;, &quot;*&quot;, &quot;*&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码的分割规则是0次或多次的<code>a</code>，由于正则默认是贪婪匹配，所以例一的第一个分隔符是<code>aaa</code>，第二个分割符是<code>a</code>，将字符串分成三个部分，包含开始处的空字符串。例二的第一个分隔符是<code>aaa</code>，第二个分隔符是0个<code>a</code>（即空字符），第三个分隔符是<code>a</code>，所以将字符串分成四个部分。</p>
<p>如果正则表达式<strong>带有括号</strong>，则括号匹配的部分也会作为数组成员返回。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;aaa*a*&#x27;</span>.<span class="title function_">split</span>(<span class="regexp">/(a*)/</span>)</span><br><span class="line"><span class="comment">// [ &#x27;&#x27;, &#x27;aaa&#x27;, &#x27;*&#x27;, &#x27;a&#x27;, &#x27;*&#x27; ]</span></span><br></pre></td></tr></table></figure>

<p>上面代码的正则表达式使用了括号，第一个组匹配是<code>aaa</code>，第二个组匹配是<code>a</code>，它们都作为数组成员返回。</p>
<h2 id="5、匹配规则"><a href="#5、匹配规则" class="headerlink" title="5、匹配规则"></a>5、匹配规则</h2><p>搭配菜鸟教程一起学习更容易理解：<a href="https://www.runoob.com/regexp/regexp-tutorial.html">https://www.runoob.com/regexp/regexp-tutorial.html</a></p>
<p>正则表达式在线测试与常用正则表达式：<a href="http://c.runoob.com/front-end/854">http://c.runoob.com/front-end/854</a></p>
<p>正则表达式的规则很复杂，下面一一介绍这些规则。</p>
<h3 id="5-1-字面量字符和元字符"><a href="#5-1-字面量字符和元字符" class="headerlink" title="5.1 字面量字符和元字符"></a>5.1 字面量字符和元字符</h3><p>**大部分字符在正则表达式中，就是字面的含义，比如<code>/a/</code>匹配<code>a</code>，<code>/b/</code>匹配<code>b</code>**。如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的<code>a</code>和<code>b</code>），那么它们就叫做“字面量字符”（literal characters）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/dog/.test(&#x27;old dog&#x27;) // true</span><br></pre></td></tr></table></figure>

<p>上面代码中正则表达式的<code>dog</code>，就是字面量字符，所以<code>/dog/</code>匹配<code>old dog</code>，因为它就表示<code>d</code>、<code>o</code>、<code>g</code>三个字母连在一起。</p>
<p>除了字面量字符以外，还<strong>有一部分字符有特殊含义，不代表字面的意思。它们叫做“元字符”</strong>（metacharacters），主要有以下几个。</p>
<h4 id="（1）点字符（-类似通配"><a href="#（1）点字符（-类似通配" class="headerlink" title="（1）点字符（.)   类似通配"></a>（1）点字符（.)   类似通配</h4><p>点字符（<code>.</code>）<strong>匹配除回车（<code>\r</code>）、换行(<code>\n</code>) 、行分隔符（<code>\u2028</code>）和段分隔符（<code>\u2029</code>）以外的任何单个字符</strong>。注意，对于码点大于<code>0xFFFF</code>字符，点字符不能正确匹配，会认为这是两个字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/c.<span class="property">t</span>/        <span class="comment">//匹配c和t之间包含任意一个字符的情况,注意：一个.只匹配一个字符</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;cet c2t c-t c.t coot c我t&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/c.t/g</span>)</span><br><span class="line"><span class="comment">// [&quot;cet&quot;, &quot;c2t&quot;, &quot;c-t&quot;, &quot;c.t&quot;, &quot;c我t&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;cet c2t c-t c.t coot c我t&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/c..t/g</span>)</span><br><span class="line"><span class="comment">//[&quot;coot&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>c.t</code>匹配<code>c</code>和<code>t</code>之间包含任意一个字符的情况，只要这三个字符在同一行，比如<code>cat</code>、<code>c2t</code>、<code>c-t</code>等等，但是不匹配<code>coot</code>。</p>
<h4 id="（2）位置字符-开始位置和结束位置"><a href="#（2）位置字符-开始位置和结束位置" class="headerlink" title="（2）位置字符(^) ($)  开始位置和结束位置"></a>（2）位置字符(^) ($)  开始位置和结束位置</h4><p>位置字符用来提示字符所处的位置，主要有两个字符。</p>
<ul>
<li><strong><code>^</code> 表示字符串的开始位置</strong></li>
<li><strong><code>$</code> 表示字符串的结束位置</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test必须出现在开始位置</span></span><br><span class="line">/^test/.<span class="title function_">test</span>(<span class="string">&#x27;test123&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test必须出现在结束位置</span></span><br><span class="line">/test$/.<span class="title function_">test</span>(<span class="string">&#x27;new test&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从开始位置到结束位置只有test</span></span><br><span class="line">/^test$/.<span class="title function_">test</span>(<span class="string">&#x27;test&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/^test$/.<span class="title function_">test</span>(<span class="string">&#x27;test test&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="（3）选择符（-）-表示’’或关系’’"><a href="#（3）选择符（-）-表示’’或关系’’" class="headerlink" title="（3）选择符（|） 表示’’或关系’’"></a>（3）选择符（<code>|</code>） 表示’’或关系’’</h4><p>竖线符号（<code>|</code>）在正则表达式中表示“<strong>或关系</strong>”（OR），即<code>cat|dog</code>表示匹配<code>cat</code>或<code>dog</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/<span class="number">11</span>|<span class="number">22</span>/.<span class="title function_">test</span>(<span class="string">&#x27;911&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，正则表达式指定必须匹配<code>11</code>或<code>22</code>。</p>
<p>多个选择符可以联合使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配fred、barney、betty之中的一个</span></span><br><span class="line">/fred|barney|betty/</span><br></pre></td></tr></table></figure>

<p>选择符会包括它前后的多个字符，比如<code>/ab|cd/</code>指的是匹配<code>ab</code>或者<code>cd</code>，而不是指匹配<code>b</code>或者<code>c</code>。如果想修改这个行为，可以使用圆括号。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/<span class="title function_">a</span>( |\t)b/.<span class="title function_">test</span>(<span class="string">&#x27;a\tb&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码指的是，<code>a</code>和<code>b</code>之间有一个空格或者一个制表符。</p>
<p>其他的元字符还包括<code>\</code>、<code>\*</code>、<code>+</code>、<code>?</code>、<code>()</code>、<code>[]</code>、<code>&#123;&#125;</code>等，将在下文解释。</p>
<h3 id="5-2-转义符（-反斜杠）"><a href="#5-2-转义符（-反斜杠）" class="headerlink" title="5.2 转义符（\ 反斜杠）"></a>5.2 转义符（\ 反斜杠）</h3><p>正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配<code>+</code>，就要写成<code>\+</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/<span class="number">1</span>+<span class="number">1</span>/.<span class="title function_">test</span>(<span class="string">&#x27;1+1&#x27;</span>)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">/<span class="number">1</span>\+<span class="number">1</span>/.<span class="title function_">test</span>(<span class="string">&#x27;1+1&#x27;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，第一个正则表达式之所以不匹配，因为加号是元字符，不代表自身。第二个正则表达式使用反斜杠对加号转义，就能匹配成功。</p>
<p>正则表达式中，<strong>需要反斜杠转义的，一共有12个字符</strong>：<code>^</code>、<code>.</code>、<code>[</code>、<code>$</code>、<code>(</code>、<code>)</code>、<code>|</code>、<code>*</code>、<code>+</code>、<code>?</code>、<code>&#123;</code>和<code>\</code>。需要特别注意的是，如果使用<code>RegExp</code>方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;1\+1&#x27;</span>)).<span class="title function_">test</span>(<span class="string">&#x27;1+1&#x27;</span>)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;1\\+1&#x27;</span>)).<span class="title function_">test</span>(<span class="string">&#x27;1+1&#x27;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>RegExp</code>作为构造函数，参数是一个字符串。但是，在字符串内部，反斜杠也是转义字符，所以它会先被反斜杠转义一次，然后再被正则表达式转义一次，因此需要两个反斜杠转义。</p>
<h3 id="5-3-特殊字符"><a href="#5-3-特殊字符" class="headerlink" title="5.3 特殊字符"></a>5.3 特殊字符</h3><p>正则表达式对一些不能打印的特殊字符，提供了表达方法。</p>
<ul>
<li><p><code>\cX</code> 表示<code>Ctrl-[X]</code>，其中的<code>X</code>是A-Z之中任一个英文字母，用来匹配控制字符。</p>
</li>
<li><p><code>[\b]</code> 匹配退格键(U+0008)，不要与<code>\b</code>混淆。</p>
</li>
<li><p><code>\n</code> 匹配换行键。</p>
</li>
<li><p><code>\r</code> 匹配回车键。</p>
</li>
<li><p><code>\t</code> 匹配制表符 tab（U+0009）。</p>
</li>
<li><p><code>\v</code> 匹配垂直制表符（U+000B）。</p>
</li>
<li><p><code>\f</code> 匹配换页符（U+000C）。</p>
</li>
<li><p><code>\0</code> 匹配<code>null</code>字符（U+0000）。</p>
</li>
<li><p><code>\xhh</code> 匹配一个以两位十六进制数（<code>\x00</code>-<code>\xFF</code>）表示的字符。</p>
</li>
<li><p><code>\uhhhh</code> 匹配一个以四位十六进制数（<code>\u0000</code>-<code>\uFFFF</code>）表示的 Unicode 字符。</p>
</li>
</ul>
<h3 id="5-4-字符类"><a href="#5-4-字符类" class="headerlink" title="5.4 字符类"></a>5.4 字符类</h3><p>字符类（class）<strong>表示有一系列字符可供选择，只要匹配其中一个就可以了</strong>。所有可供选择的字符都放在<strong>方括号</strong>内，比如<code>[xyz]</code> 表示<code>x</code>、<code>y</code>、<code>z</code>之中任选一个匹配。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/[abc]/.<span class="title function_">test</span>(<span class="string">&#x27;hello world&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/[abc]/.<span class="title function_">test</span>(<span class="string">&#x27;apple&#x27;</span>) <span class="comment">// true  a、b、c其中任意一个</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，字符串<code>hello world</code>不包含<code>a</code>、<code>b</code>、<code>c</code>这三个字母中的任一个，所以返回<code>false</code>；字符串<code>apple</code>包含字母<code>a</code>，所以返回<code>true</code>。</p>
<p>有两个字符在字符类中有特殊含义。</p>
<h5 id="（1）脱字符（-排除）"><a href="#（1）脱字符（-排除）" class="headerlink" title="（1）脱字符（^  排除）"></a>（1）脱字符（^  排除）</h5><p>如果方括号内的第一个字符是<code>[^]</code>，则表示<strong>除了字符类之中的字符，其他字符都可以匹配</strong>。比如，<code>[^xyz]</code>表示除了<code>x</code>、<code>y</code>、<code>z</code>之外都可以匹配。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/[^abc]/.<span class="title function_">test</span>(<span class="string">&#x27;bbc news&#x27;</span>) <span class="comment">// true  字符串中包含了a、b、c以为的字符</span></span><br><span class="line">/[^abc]/.<span class="title function_">test</span>(<span class="string">&#x27;bbc&#x27;</span>) <span class="comment">// false  字符串中没有除了a、b、c以外的字符</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，字符串<code>bbc news</code>包含<code>a</code>、<code>b</code>、<code>c</code>以外的其他字符，所以返回<code>true</code>；字符串<code>bbc</code>不包含<code>a</code>、<code>b</code>、<code>c</code>以外的其他字符，所以返回<code>false</code>。</p>
<p>如果方括号内没有其他字符，即<strong>只有<code>[^]</code>，就表示匹配一切字符，其中包括换行符</strong>。相比之下，点号作为元字符（<code>.</code>）是不包括换行符的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Please yes\nmake my day!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">s.<span class="title function_">match</span>(<span class="regexp">/yes.*day/</span>) <span class="comment">// null</span></span><br><span class="line">s.<span class="title function_">match</span>(<span class="regexp">/yes[^]*day/</span>) <span class="comment">// [ &#x27;yes\nmake my day&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，字符串<code>s</code>含有一个换行符，点号不包括换行符，所以第一个正则表达式匹配失败；第二个正则表达式<code>[^]</code>包含一切字符，所以匹配成功。</p>
<blockquote>
<p>注意，脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面含义。</p>
</blockquote>
<h5 id="（2）连字符（-字符连续范围）"><a href="#（2）连字符（-字符连续范围）" class="headerlink" title="（2）连字符（- 字符连续范围）"></a>（2）连字符（- 字符连续范围）</h5><p>某些情况下，对于连续序列的字符，连字符（<code>-</code>）用来提供简写形式，表示<strong>字符的连续范围</strong>。比如，<code>[abc]</code>可以写成<code>[a-c]</code>，<code>[0123456789]</code>可以写成<code>[0-9]</code>，同理<code>[A-Z]</code>表示26个大写字母。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/a-z/.<span class="title function_">test</span>(<span class="string">&#x27;b&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/[a-z]/.<span class="title function_">test</span>(<span class="string">&#x27;b&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，当连字号（dash）不出现在方括号之中，就不具备简写的作用，只代表字面的含义，所以不匹配字符<code>b</code>。只有当连字号用在方括号之中，才表示连续的字符序列。</p>
<p>以下都是合法的字符类简写形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>-<span class="number">9.</span>,]</span><br><span class="line">[<span class="number">0</span>-9a-fA-F]</span><br><span class="line">[a-zA-<span class="variable constant_">Z0</span>-<span class="number">9</span>-]</span><br><span class="line">[<span class="number">1</span>-<span class="number">31</span>] <span class="comment">// 注意：不代表1到31，只代表1到3</span></span><br></pre></td></tr></table></figure>

<p>上面代码中最后一个字符类<code>[1-31]</code>，不代表<code>1</code>到<code>31</code>，只代表<code>1</code>到<code>3</code>。</p>
<p>连字符还可以用来指定 Unicode 字符的范围。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;\u0130\u0131\u0132&quot;</span>;</span><br><span class="line"><span class="regexp">/[\u0128-\uFFFF]/</span>.<span class="title function_">test</span>(str)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>\u0128-\uFFFF</code>表示匹配码点在<code>0128</code>到<code>FFFF</code>之间的所有字符。</p>
<p>另外，不要过分使用连字符，设定一个很大的范围，否则很可能选中意料之外的字符。最典型的例子就是<code>[A-z]</code>，表面上它是选中从大写的<code>A</code>到小写的<code>z</code>之间52个字母，但是由于在 ASCII 编码之中，大写字母与小写字母之间还有其他字符，结果就会出现意料之外的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/[A-z]/.<span class="title function_">test</span>(<span class="string">&#x27;\\&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，由于反斜杠（’\‘）的ASCII码在大写字母与小写字母之间，结果会被选中。</p>
<h3 id="5-5-预定义模式-常见模式简写-d-D-w-W-s-S-b-B"><a href="#5-5-预定义模式-常见模式简写-d-D-w-W-s-S-b-B" class="headerlink" title="5.5 预定义模式 (常见模式简写\d\D\w\W\s\S\b\B)"></a>5.5 预定义模式 (常见模式简写\d\D\w\W\s\S\b\B)</h3><p>预定义模式指的是<strong>某些常见模式的简写方式</strong>。</p>
<ul>
<li><code>\d</code> 匹配0-9之间的任一数字，相当于<code>[0-9]</code>。**(数字)**</li>
<li><code>\D</code> 匹配所有0-9以外的字符，相当于<code>[^0-9]</code>。**(非数字)**</li>
<li><code>\w</code> 匹配任意的字母、数字和下划线，相当于<code>[A-Za-z0-9_]</code>。**(字母、数字、下划线)**</li>
<li><code>\W</code> 除所有字母、数字和下划线以外的字符，相当于<code>[^A-Za-z0-9_]</code>。**(非：字母、数字、下划线)**</li>
<li><code>\s</code> 匹配空格（包括换行符、制表符、空格符等），相等于<code>[ \t\r\n\v\f]</code>。**(空格)**</li>
<li><code>\S</code> 匹配非空格的字符，相当于<code>[^ \t\r\n\v\f]</code>。**(非空格)**</li>
<li><code>\b</code> 匹配词的边界。**(单词边界)**</li>
<li><code>\B</code> 匹配非词边界，即在词的内部。**(非单词边界)**</li>
</ul>
<p>下面是一些例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \s 的例子</span></span><br><span class="line">/\s\w*<span class="regexp">/.exec(&#x27;hello world&#x27;) /</span><span class="regexp">/ [&quot; world&quot;]</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ \b 的例子</span></span><br><span class="line"><span class="regexp">/</span>\bworld/.<span class="title function_">test</span>(<span class="string">&#x27;hello world&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/\bworld/.<span class="title function_">test</span>(<span class="string">&#x27;hello-world&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/\bworld/.<span class="title function_">test</span>(<span class="string">&#x27;helloworld&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// \B 的例子</span></span><br><span class="line">/\<span class="title class_">Bworld</span>/.<span class="title function_">test</span>(<span class="string">&#x27;hello-world&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/\<span class="title class_">Bworld</span>/.<span class="title function_">test</span>(<span class="string">&#x27;helloworld&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>\s</code>表示空格，所以匹配结果会包括空格。<code>\b</code>表示词的边界，所以<code>world</code>的词首必须独立（词尾是否独立未指定），才会匹配。同理，<code>\B</code>表示非词的边界，只有<code>world</code>的词首不独立，才会匹配。</p>
<p>通常，正则表达式遇到换行符（<code>\n</code>）就会停止匹配。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="string">&quot;&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="regexp">/.*/</span>.<span class="title function_">exec</span>(html)[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// &quot;&lt;b&gt;Hello&lt;/b&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，字符串<code>html</code>包含一个换行符，结果点字符（<code>.</code>）不匹配换行符，导致匹配结果可能不符合原意。这时使用<code>\s</code>字符类，就能包括换行符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="string">&quot;&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="regexp">/[\S\s]*/</span>.<span class="title function_">exec</span>(html)[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// &quot;&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>[\S\s]</code>指代一切字符。</p>
<h3 id="5-6-重复类-（-n-n-n-m-）"><a href="#5-6-重复类-（-n-n-n-m-）" class="headerlink" title="5.6 重复类 （ {n} {n,} {n,m} ）"></a>5.6 重复类 （ {n} {n,} {n,m} ）</h3><p>模式的精确匹配次数，使用大括号（<code>&#123;&#125;</code>）表示。<code>&#123;n&#125;</code>表示恰好重复<code>n</code>次，<code>&#123;n,&#125;</code>表示至少重复<code>n</code>次，<code>&#123;n,m&#125;</code>表示重复不少于<code>n</code>次，不多于<code>m</code>次。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/lo&#123;<span class="number">2</span>&#125;k/.<span class="title function_">test</span>(<span class="string">&#x27;look&#x27;</span>) <span class="comment">// true  2个o</span></span><br><span class="line">/lo&#123;<span class="number">2</span>,<span class="number">5</span>&#125;k/.<span class="title function_">test</span>(<span class="string">&#x27;looook&#x27;</span>) <span class="comment">// true   2到5个o</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，第一个模式指定<code>o</code>连续出现2次，第二个模式指定<code>o</code>连续出现2次到5次之间。</p>
<h3 id="5-7-量词符（-）（-）（-）"><a href="#5-7-量词符（-）（-）（-）" class="headerlink" title="5.7 量词符（?）（*）（+）"></a>5.7 量词符（?）（*）（+）</h3><p>量词符用来设定<strong>某个模式出现的次数</strong>。</p>
<ul>
<li><code>?</code> 问号表示某个模式出现<strong>0次或1次</strong>，等同于<code>&#123;0, 1&#125;</code>。</li>
<li><code>*</code> 星号表示某个模式出现<strong>0次或多次</strong>，等同于<code>&#123;0,&#125;</code>。</li>
<li><code>+</code> 加号表示某个模式出现<strong>1次或多次</strong>，等同于<code>&#123;1,&#125;</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// t 出现0次或1次</span></span><br><span class="line">/t?est/.<span class="title function_">test</span>(<span class="string">&#x27;test&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/t?est/.<span class="title function_">test</span>(<span class="string">&#x27;est&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// t 出现1次或多次</span></span><br><span class="line">/t+est/.<span class="title function_">test</span>(<span class="string">&#x27;test&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/t+est/.<span class="title function_">test</span>(<span class="string">&#x27;ttest&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/t+est/.<span class="title function_">test</span>(<span class="string">&#x27;est&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// t 出现0次或多次</span></span><br><span class="line">/t*est/.<span class="title function_">test</span>(<span class="string">&#x27;test&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/t*est/.<span class="title function_">test</span>(<span class="string">&#x27;ttest&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/t*est/.<span class="title function_">test</span>(<span class="string">&#x27;tttest&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/t*est/.<span class="title function_">test</span>(<span class="string">&#x27;est&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h3 id="5-8-贪婪模式（对量词符可使用非贪婪模式）"><a href="#5-8-贪婪模式（对量词符可使用非贪婪模式）" class="headerlink" title="5.8 贪婪模式（对量词符可使用非贪婪模式）"></a>5.8 贪婪模式（对量词符可使用非贪婪模式）</h3><p>上一小节的三个量词符，默认情况下都是最大可能匹配，即<strong>匹配直到下一个字符不满足匹配规则为止</strong>。这被称为贪婪模式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;aaa&#x27;</span>;</span><br><span class="line">s.<span class="title function_">match</span>(<span class="regexp">/a+/</span>) <span class="comment">// [&quot;aaa&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，模式是<code>/a+/</code>，表示匹配1个<code>a</code>或多个<code>a</code>，那么到底会匹配几个<code>a</code>呢？因为默认是贪婪模式，会一直匹配到字符<code>a</code>不出现为止，所以匹配结果是3个<code>a</code>。</p>
<p>如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;aaa&#x27;</span>;</span><br><span class="line">s.<span class="title function_">match</span>(<span class="regexp">/a+?/</span>) <span class="comment">// [&quot;a&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，模式结尾添加了一个问号<code>/a+?/</code>，这时就改为<strong>非贪婪模式，一旦条件满足，就不再往下匹配</strong>。</p>
<p>除了非贪婪模式的加号，还有非贪婪模式的星号（<code>*</code>）和非贪婪模式的问号（<code>?</code>）。</p>
<ul>
<li><code>+?</code>：表示某个模式出现1次或多次，匹配时采用非贪婪模式。</li>
<li><code>*?</code>：表示某个模式出现0次或多次，匹配时采用非贪婪模式。</li>
<li><code>??</code>：表格某个模式出现0次或1次，匹配时采用非贪婪模式。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abb&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/ab*b/</span>) <span class="comment">// [&quot;abb&quot;]</span></span><br><span class="line"><span class="string">&#x27;abb&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/ab*?b/</span>) <span class="comment">// [&quot;ab&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;abb&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/ab?b/</span>) <span class="comment">// [&quot;abb&quot;]</span></span><br><span class="line"><span class="string">&#x27;abb&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/ab??b/</span>) <span class="comment">// [&quot;ab&quot;]</span></span><br></pre></td></tr></table></figure>



<h3 id="5-9-修饰符"><a href="#5-9-修饰符" class="headerlink" title="5.9 修饰符"></a>5.9 修饰符</h3><p>修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部。</p>
<p>修饰符可以单个使用，也可以多个一起使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单个修饰符</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/test/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个修饰符</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/test/ig</span>;</span><br></pre></td></tr></table></figure>

<h4 id="（1）g-修饰符-（全局匹配）"><a href="#（1）g-修饰符-（全局匹配）" class="headerlink" title="（1）g 修饰符 （全局匹配）"></a>（1）g 修饰符 （全局匹配）</h4><p>默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。<code>g</code>修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/b/</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;abba&#x27;</span>;</span><br><span class="line"></span><br><span class="line">regex.<span class="title function_">test</span>(str); <span class="comment">// true</span></span><br><span class="line">regex.<span class="title function_">test</span>(str); <span class="comment">// true</span></span><br><span class="line">regex.<span class="title function_">test</span>(str); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，正则模式不含<code>g</code>修饰符，每次都是从字符串头部开始匹配。所以，连续做了三次匹配，都返回<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/b/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;abba&#x27;</span>;</span><br><span class="line"></span><br><span class="line">regex.<span class="title function_">test</span>(str); <span class="comment">// true</span></span><br><span class="line">regex.<span class="title function_">test</span>(str); <span class="comment">// true</span></span><br><span class="line">regex.<span class="title function_">test</span>(str); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，正则模式含有<code>g</code>修饰符，每次都是从上一次匹配成功处，开始向后匹配。因为字符串<code>abba</code>只有两个<code>b</code>，所以前两次匹配结果为<code>true</code>，第三次匹配结果为<code>false</code>。</p>
<h4 id="（2）i-修饰符-（不区分大小写）"><a href="#（2）i-修饰符-（不区分大小写）" class="headerlink" title="（2）i 修饰符 （不区分大小写）"></a>（2）i 修饰符 （不区分大小写）</h4><p>默认情况下，正则对象区分字母的大小写，加上<code>i</code>修饰符以后表示忽略大小写（ignoreCase）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/abc/.<span class="title function_">test</span>(<span class="string">&#x27;ABC&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/abc/i.<span class="title function_">test</span>(<span class="string">&#x27;ABC&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，加了<code>i</code>修饰符以后，不考虑大小写，所以模式<code>abc</code>匹配字符串<code>ABC</code>。</p>
<h4 id="（3）m-修饰符（让-和-识别换行符）"><a href="#（3）m-修饰符（让-和-识别换行符）" class="headerlink" title="（3）m 修饰符（让^和$识别换行符）"></a>（3）m 修饰符（让^和$识别换行符）</h4><p><code>m</code>修饰符表示多行模式（multiline），会修改<code>^</code>和<code>$</code>的行为。默认情况下（即不加<code>m</code>修饰符时），<code>^</code>和<code>$</code>匹配字符串的开始处和结尾处，加上<code>m</code>修饰符以后，<code>^</code>和<code>$</code>还会匹配行首和行尾，即<code>^</code>和<code>$</code>会识别换行符（<code>\n</code>）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/world$/.<span class="title function_">test</span>(<span class="string">&#x27;hello world\n&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/world$/m.<span class="title function_">test</span>(<span class="string">&#x27;hello world\n&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，字符串结尾处有一个换行符。如果不加<code>m</code>修饰符，匹配不成功，因为字符串的结尾不是<code>world</code>；加上以后，<code>$</code>可以匹配行尾。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/^b/m.<span class="title function_">test</span>(<span class="string">&#x27;a\nb&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码要求匹配行首的<code>b</code>，如果不加<code>m</code>修饰符，就相当于<code>b</code>只能处在字符串的开始处。加上<code>m</code>修饰符以后，换行符<code>\n</code>也会被认为是一行的开始。</p>
<h3 id="5-10-组匹配"><a href="#5-10-组匹配" class="headerlink" title="5.10 组匹配"></a>5.10 组匹配</h3><h4 id="（1）概述-（圆括号分组）"><a href="#（1）概述-（圆括号分组）" class="headerlink" title="（1）概述 （圆括号分组）"></a>（1）概述 （圆括号分组）</h4><p>正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/fred+<span class="regexp">/.test(&#x27;fredd&#x27;) /</span><span class="regexp">/ true +加号表示重复字母d</span></span><br><span class="line"><span class="regexp">/</span>(fred)+<span class="regexp">/.test(&#x27;fredfred&#x27;) /</span><span class="regexp">/ true  +加号表示重复单词fred</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，第一个模式没有括号，结果<code>+</code>只表示重复字母<code>d</code>，第二个模式有括号，结果<code>+</code>就表示匹配<code>fred</code>这个词。</p>
<p>下面是另外一个分组捕获的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="string">&#x27;abcabc&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/(.)b(.)/</span>);</span><br><span class="line">m</span><br><span class="line"><span class="comment">// [&#x27;abc&#x27;, &#x27;a&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，正则表达式<code>/(.)b(.)/</code>一共使用两个括号，第一个括号捕获<code>a</code>，第二个括号捕获<code>c</code>。</p>
<p>注意，使用组匹配时，不宜同时使用<code>g</code>修饰符，否则<code>match</code>方法不会捕获分组的内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="string">&#x27;abcabc&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/(.)b(.)/g</span>);</span><br><span class="line">m <span class="comment">// [&#x27;abc&#x27;, &#x27;abc&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码使用带<code>g</code>修饰符的正则表达式，结果<code>match</code>方法只捕获了匹配整个表达式的部分。这时必须使用正则表达式的<code>exec</code>方法，配合循环，才能读到每一轮匹配的组捕获。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;abcabc&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(.)b(.)/g</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = reg.<span class="title function_">exec</span>(str);</span><br><span class="line">  <span class="keyword">if</span> (!result) <span class="keyword">break</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;abc&quot;, &quot;a&quot;, &quot;c&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;abc&quot;, &quot;a&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure>

<p>正则表达式内部，还可以用<code>\n</code>引用括号匹配的内容，<code>n</code>是从1开始的自然数，表示对应顺序的括号。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/(.)<span class="title function_">b</span>(.)\1b\<span class="number">2</span>/.<span class="title function_">test</span>(<span class="string">&quot;abcabc&quot;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，<code>\1</code>表示第一个括号匹配的内容（即<code>a</code>），<code>\2</code>表示第二个括号匹配的内容（即<code>c</code>）。</p>
<p>下面是另外一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/<span class="title function_">y</span>(..)(.)\<span class="number">2</span>\<span class="number">1</span>/.<span class="title function_">test</span>(<span class="string">&#x27;yabccab&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>括号还可以嵌套。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/<span class="title function_">y</span>((..)\<span class="number">2</span>)\<span class="number">1</span>/.<span class="title function_">test</span>(<span class="string">&#x27;yabababab&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>\1</code>指向外层括号，<code>\2</code>指向内层括号。</p>
<p>组匹配非常有用，下面是一个匹配网页标签的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tagName = <span class="regexp">/&lt;([^&gt;]+)&gt;[^&lt;]*&lt;\/\1&gt;/</span>;</span><br><span class="line"></span><br><span class="line">tagName.<span class="title function_">exec</span>(<span class="string">&quot;&lt;b&gt;bold&lt;/b&gt;&quot;</span>)[<span class="number">1</span>]</span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，圆括号匹配尖括号之中的标签，而<code>\1</code>就表示对应的闭合标签。</p>
<p>上面代码略加修改，就能捕获带有属性的标签。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="string">&#x27;&lt;b class=&quot;hello&quot;&gt;Hello&lt;/b&gt;&lt;i&gt;world&lt;/i&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> tag = <span class="regexp">/&lt;(\w+)([^&gt;]*)&gt;(.*?)&lt;\/\1&gt;/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> match = tag.<span class="title function_">exec</span>(html);</span><br><span class="line"></span><br><span class="line">match[<span class="number">1</span>] <span class="comment">// &quot;b&quot;</span></span><br><span class="line">match[<span class="number">2</span>] <span class="comment">// &quot; class=&quot;hello&quot;&quot;</span></span><br><span class="line">match[<span class="number">3</span>] <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line">match = tag.<span class="title function_">exec</span>(html);</span><br><span class="line"></span><br><span class="line">match[<span class="number">1</span>] <span class="comment">// &quot;i&quot;</span></span><br><span class="line">match[<span class="number">2</span>] <span class="comment">// &quot;&quot;</span></span><br><span class="line">match[<span class="number">3</span>] <span class="comment">// &quot;world&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="（2）非捕获组"><a href="#（2）非捕获组" class="headerlink" title="（2）非捕获组"></a>（2）非捕获组</h4><p><code>(?:x)</code>称为非捕获组（Non-capturing group），表示<strong>不返回该组匹配的内容，即匹配的结果中不计入这个括号</strong>。</p>
<p>非捕获组的作用请考虑这样一个场景，假定需要匹配<code>foo</code>或者<code>foofoo</code>，正则表达式就应该写成<code>/(foo)&#123;1, 2&#125;/</code>，但是这样会占用一个组匹配。这时，就可以使用非捕获组，将正则表达式改为<code>/(?:foo)&#123;1, 2&#125;/</code>，它的作用与前一个正则是一样的，但是不会单独输出括号内部的内容。</p>
<p>请看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="string">&#x27;abc&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/(?:.)b(.)/</span>);</span><br><span class="line">m <span class="comment">// [&quot;abc&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中的模式，一共使用了两个括号。其中第一个括号是非捕获组，所以最后返回的结果中没有第一个括号，只有第二个括号匹配的内容。</p>
<p>下面是用来分解网址的正则表达式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常匹配</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="regexp">/(http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/</span>;</span><br><span class="line"></span><br><span class="line">url.<span class="title function_">exec</span>(<span class="string">&#x27;http://google.com/&#x27;</span>);</span><br><span class="line"><span class="comment">// [&quot;http://google.com/&quot;, &quot;http&quot;, &quot;google.com&quot;, &quot;/&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非捕获组匹配</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="regexp">/(?:http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/</span>;</span><br><span class="line"></span><br><span class="line">url.<span class="title function_">exec</span>(<span class="string">&#x27;http://google.com/&#x27;</span>);</span><br><span class="line"><span class="comment">// [&quot;http://google.com/&quot;, &quot;google.com&quot;, &quot;/&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，前一个正则表达式是正常匹配，第一个括号返回网络协议；后一个正则表达式是非捕获匹配，返回结果中不包括网络协议。</p>
<h4 id="（3）先行断言"><a href="#（3）先行断言" class="headerlink" title="（3）先行断言"></a>（3）先行断言</h4><p><code>x(?=y)</code>称为先行断言（Positive look-ahead）<strong>，<code>x</code>只有在<code>y</code>前面才匹配，<code>y</code>不会被计入返回结果</strong>。比如，要匹配后面跟着百分号的数字，可以写成<code>/\d+(?=%)/</code>。</p>
<p>“先行断言”中，括号里的部分是不会返回的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="string">&#x27;abc&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/b(?=c)/</span>);</span><br><span class="line">m <span class="comment">// [&quot;b&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面的代码使用了先行断言，<code>b</code>在<code>c</code>前面所以被匹配，但是括号对应的<code>c</code>不会被返回。</p>
<h4 id="（4）先行否定断言"><a href="#（4）先行否定断言" class="headerlink" title="（4）先行否定断言"></a>（4）先行否定断言</h4><p><code>x(?!y)</code>称为先行否定断言（Negative look-ahead），**<code>x</code>只有不在<code>y</code>前面才匹配，<code>y</code>不会被计入返回结果**。比如，要匹配后面跟的不是百分号的数字，就要写成<code>/\d+(?!%)/</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/\d+(?!\.)/.<span class="title function_">exec</span>(<span class="string">&#x27;3.14&#x27;</span>)</span><br><span class="line"><span class="comment">// [&quot;14&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，正则表达式指定，只有不在小数点前面的数字才会被匹配，因此返回的结果就是<code>14</code>。</p>
<p>“先行否定断言”中，括号里的部分是不会返回的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="string">&#x27;abd&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/b(?!c)/</span>);</span><br><span class="line">m <span class="comment">// [&#x27;b&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>上面的代码使用了先行否定断言，<code>b</code>不在<code>c</code>前面所以被匹配，而且括号对应的<code>d</code>不会被返回。</p>
<h2 id="十一、JSON对象"><a href="#十一、JSON对象" class="headerlink" title="十一、JSON对象"></a>十一、JSON对象</h2><h2 id="1、JSON-格式"><a href="#1、JSON-格式" class="headerlink" title="1、JSON 格式"></a>1、JSON 格式</h2><p>JSON 格式（JavaScript Object Notation 的缩写）是一种用于数据交换的文本格式，2001年由 Douglas Crockford 提出，目的是取代繁琐笨重的 XML 格式。</p>
<p>相比 XML 格式，JSON 格式有两个显著的优点：书写简单，一目了然；符合 JavaScript 原生语法，可以由解释引擎直接处理，不用另外添加解析代码。所以，JSON 迅速被接受，已经成为各大网站交换数据的标准格式，并被写入标准。</p>
<p><strong>每个 JSON 对象就是一个值，可能是一个数组或对象，也可能是一个原始类型的值</strong>。总之，<strong>只能是一个值</strong>，不能是两个或更多的值。</p>
<p>JSON 对值的类型和格式有严格的<strong>规定</strong>。</p>
<blockquote>
<ol>
<li>复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。</li>
<li>原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和<code>null</code>（不能使用<code>NaN</code>, <code>Infinity</code>, <code>-Infinity</code>和<code>undefined</code>）。</li>
<li>字符串必须使用双引号表示，不能使用单引号。</li>
<li>对象的键名必须放在双引号里面。</li>
<li>数组或对象最后一个成员的后面，不能加逗号。</li>
</ol>
</blockquote>
<p>以下都是合法的 JSON。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>]</span><br><span class="line"></span><br><span class="line">&#123; <span class="string">&quot;one&quot;</span>: <span class="number">1</span>, <span class="string">&quot;two&quot;</span>: <span class="number">2</span>, <span class="string">&quot;three&quot;</span>: <span class="number">3</span> &#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&quot;names&quot;</span>: [<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>] &#125;</span><br><span class="line"></span><br><span class="line">[ &#123; <span class="string">&quot;name&quot;</span>: <span class="string">&quot;张三&quot;</span>&#125;, &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;李四&quot;</span>&#125; ]</span><br></pre></td></tr></table></figure>

<p>以下都是不合法的 JSON。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">32</span> &#125;  <span class="comment">// 属性名必须使用双引号</span></span><br><span class="line"></span><br><span class="line">[<span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>, <span class="number">0xFFF</span>] <span class="comment">// 不能使用十六进制值</span></span><br><span class="line"></span><br><span class="line">&#123; <span class="string">&quot;name&quot;</span>: <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="literal">undefined</span> &#125; <span class="comment">// 不能使用 undefined</span></span><br><span class="line"></span><br><span class="line">&#123; <span class="string">&quot;name&quot;</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  <span class="string">&quot;birthday&quot;</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;Fri, 26 Aug 2011 07:13:10 GMT&#x27;</span>),</span><br><span class="line">  <span class="string">&quot;getName&quot;</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">// 属性值不能使用函数和日期对象</span></span><br></pre></td></tr></table></figure>

<p><strong>注意，<code>null</code>、空数组和空对象都是合法的 JSON 值。</strong></p>
<h2 id="2、JSON-对象"><a href="#2、JSON-对象" class="headerlink" title="2、JSON 对象"></a>2、JSON 对象</h2><p><code>JSON</code>对象是 JavaScript 的原生对象，用来处理 JSON 格式数据。它有两个静态方法：<code>JSON.stringify()</code>和<code>JSON.parse()</code>。</p>
<h2 id="3、JSON-stringify-转为JSON字符串"><a href="#3、JSON-stringify-转为JSON字符串" class="headerlink" title="3、JSON.stringify() 转为JSON字符串"></a>3、JSON.stringify() 转为JSON字符串</h2><h3 id="3-1-基本用法"><a href="#3-1-基本用法" class="headerlink" title="3.1 基本用法"></a>3.1 基本用法</h3><p><code>JSON.stringify</code>方法用于<strong>将一个值转为 JSON 字符串</strong>。该字符串符合 JSON 格式，并且可以被<code>JSON.parse</code>方法还原。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单个字符串、数值、布尔值、null、空数组、空对象，都是合法json格式。</span></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">// &quot;&quot;abc&quot;&quot; 注意：字符串会转json字符串会有两对双引号</span></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="number">1</span>) <span class="comment">// &quot;1&quot;</span></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="literal">false</span>) <span class="comment">// &quot;false&quot;</span></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="literal">null</span>) <span class="comment">// &quot;null&quot;</span></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>([]) <span class="comment">// &quot;[]&quot;</span></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;&#125;) <span class="comment">// &quot;&#123;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>([<span class="number">1</span>, <span class="string">&quot;false&quot;</span>, <span class="literal">false</span>])</span><br><span class="line"><span class="comment">// &#x27;[1,&quot;false&quot;,false]&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span> &#125;)</span><br><span class="line"><span class="comment">// &#x27;&#123;&quot;name&quot;:&quot;张三&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面代码将各种类型的值，转成 JSON 字符串。</p>
<p>注意，<strong>对于原始类型的字符串，转换结果会带双引号</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="string">&#x27;foo&#x27;</span>) === <span class="string">&quot;foo&quot;</span> <span class="comment">// false</span></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="string">&#x27;foo&#x27;</span>) === <span class="string">&quot;\&quot;foo\&quot;&quot;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，字符串<code>foo</code>，被转成了<code>&quot;\&quot;foo\&quot;&quot;</code>。这是因为将来还原的时候，内层双引号可以让 JavaScript 引擎知道，这是一个字符串，而不是其他类型的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="literal">false</span>) <span class="comment">// &quot;false&quot;</span></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="string">&#x27;false&#x27;</span>) <span class="comment">// &quot;\&quot;false\&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，如果不是内层的双引号，将来还原的时候，引擎就无法知道原始值是布尔值还是字符串。</p>
<p><strong>如果对象的属性是<code>undefined</code>、函数或 XML 对象，该属性会被<code>JSON.stringify</code>过滤</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj) <span class="comment">// &quot;&#123;&#125;&quot; 对象属性是undefined、函数或 XML 对象会被过滤掉</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>obj</code>的<code>a</code>属性是<code>undefined</code>，而<code>b</code>属性是一个函数，结果都被<code>JSON.stringify</code>过滤。</p>
<p><strong>如果数组的成员是<code>undefined</code>、函数或 XML 对象，则这些值被转成<code>null</code>。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="literal">undefined</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;];</span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arr) <span class="comment">// &quot;[null,null]&quot; 数组成员是undefined、函数或 XML 对象会被转成null</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，数组<code>arr</code>的成员是<code>undefined</code>和函数，它们都被转成了<code>null</code>。</p>
<p><strong>正则对象会被转成空对象</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="regexp">/foo/</span>) <span class="comment">// &quot;&#123;&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>JSON.stringify</code>方法会<strong>忽略对象的不可遍历的属性</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(obj, &#123;</span><br><span class="line">  <span class="string">&#x27;foo&#x27;</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;bar&#x27;</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj); <span class="comment">// &quot;&#123;&quot;foo&quot;:1&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>bar</code>是<code>obj</code>对象的不可遍历属性，<code>JSON.stringify</code>方法会忽略这个属性。</p>
<h3 id="3-2-第二个参数-（一个数组，对象属性白名单；或一个函数，改写返回值）"><a href="#3-2-第二个参数-（一个数组，对象属性白名单；或一个函数，改写返回值）" class="headerlink" title="3.2 第二个参数 （一个数组，对象属性白名单；或一个函数，改写返回值）"></a>3.2 第二个参数 （一个数组，对象属性白名单；或一个函数，改写返回值）</h3><p><code>JSON.stringify</code>方法还<strong>可以接受一个数组，作为第二个参数，指定需要转成字符串的属性</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="string">&#x27;prop1&#x27;</span>: <span class="string">&#x27;value1&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;prop2&#x27;</span>: <span class="string">&#x27;value2&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;prop3&#x27;</span>: <span class="string">&#x27;value3&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> selectedProperties = [<span class="string">&#x27;prop1&#x27;</span>, <span class="string">&#x27;prop2&#x27;</span>]; <span class="comment">// 指定prop1、prop2属性转成字符串</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj, selectedProperties)</span><br><span class="line"><span class="comment">// &quot;&#123;&quot;prop1&quot;:&quot;value1&quot;,&quot;prop2&quot;:&quot;value2&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>JSON.stringify</code>方法的第二个参数指定，只转<code>prop1</code>和<code>prop2</code>两个属性。</p>
<p>这个<strong>类似白名单的数组，只对对象的属性有效，对数组无效。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], [<span class="string">&#x27;0&#x27;</span>])</span><br><span class="line"><span class="comment">// &quot;[&quot;a&quot;,&quot;b&quot;]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>&#125;, [<span class="string">&#x27;0&#x27;</span>])</span><br><span class="line"><span class="comment">// &quot;&#123;&quot;0&quot;:&quot;a&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，第二个参数指定 JSON 格式只转<code>0</code>号属性，实际上对数组是无效的，只对对象有效。</p>
<p>第二个参数还<strong>可以是一个函数</strong>，用来更改<code>JSON.stringify</code>的返回值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">key, value</span>) &#123; <span class="comment">// 接收两个参数：键名、键值</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    value = <span class="number">2</span> * value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;, f)</span><br><span class="line"><span class="comment">// &#x27;&#123;&quot;a&quot;: 2,&quot;b&quot;: 4&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中的<code>f</code>函数，<strong>接受两个参数</strong>，分别是被转换的对象的<strong>键名和键值</strong>。如果键值是数值，就将它乘以<code>2</code>，否则就原样返回。</p>
<p>注意，这个处理函数是<strong>递归处理所有的键</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">key, value</span>) &#123; <span class="comment">// 每一次处理的对象，都是前一次返回的值</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[&quot;</span>+ key +<span class="string">&quot;]:&quot;</span> + value);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(o, f)</span><br><span class="line"><span class="comment">// []:[object Object]  第一次键名 空，键值是o整个对象</span></span><br><span class="line"><span class="comment">// [a]:[object Object] 第二次键名 a，键值是&#123;b:1&#125;</span></span><br><span class="line"><span class="comment">// [b]:1               第三次键名 b，键值是 1</span></span><br><span class="line"><span class="comment">// &#x27;&#123;&quot;a&quot;:&#123;&quot;b&quot;:1&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>o</code>一共会被<code>f</code>函数处理三次，最后那行是<code>JSON.stringify</code>的输出。第一次键名为空，键值是整个对象<code>o</code>；第二次键名为<code>a</code>，键值是<code>&#123;b: 1&#125;</code>；第三次键名为<code>b</code>，键值为1。</p>
<p>递归处理中，<strong>每一次处理的对象，都是前一次返回的值</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(o, f)</span><br><span class="line"><span class="comment">// &quot;&#123;&quot;b&quot;: 4&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>f</code>函数修改了对象<code>o</code>，接着<code>JSON.stringify</code>方法就递归处理修改后的对象<code>o</code>。</p>
<p>如果<strong>处理函数返回<code>undefined</code>或没有返回值，则该属性会被忽略</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">typeof</span>(value) === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">a</span>: <span class="string">&quot;abc&quot;</span>, <span class="attr">b</span>: <span class="number">123</span> &#125;, f)</span><br><span class="line"><span class="comment">// &#x27;&#123;&quot;b&quot;: 123&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>a</code>属性经过处理后，返回<code>undefined</code>，于是该属性被忽略了。</p>
<h3 id="3-3-第三个参数-（增加返回JSON字符串的可读性；json格式）"><a href="#3-3-第三个参数-（增加返回JSON字符串的可读性；json格式）" class="headerlink" title="3.3 第三个参数 （增加返回JSON字符串的可读性；json格式）"></a>3.3 第三个参数 （增加返回JSON字符串的可读性；json格式）</h3><p><code>JSON.stringify</code>还可以接受第三个参数，用于<strong>增加返回的 JSON 字符串的可读性</strong>。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">p1</span>: <span class="number">1</span>, <span class="attr">p2</span>: <span class="number">2</span> &#125;, <span class="literal">null</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&quot;&#123;</span></span><br><span class="line"><span class="comment">  &quot;p1&quot;: 1,</span></span><br><span class="line"><span class="comment">  &quot;p2&quot;: 2</span></span><br><span class="line"><span class="comment">&#125;&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 参数三是数值在使用JSON.parse()解析时正常</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">p1</span>:<span class="number">1</span>, <span class="attr">p2</span>:<span class="number">2</span> &#125;, <span class="literal">null</span>, <span class="string">&#x27;|-&#x27;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&quot;&#123;</span></span><br><span class="line"><span class="comment">|-&quot;p1&quot;: 1,</span></span><br><span class="line"><span class="comment">|-&quot;p2&quot;: 2</span></span><br><span class="line"><span class="comment">&#125;&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 参数三是字符串在使用JSON.parse()解析时报错</span></span><br></pre></td></tr></table></figure>



<h3 id="3-4-参数对象的-toJSON-方法（对象自定义toJSON方法，转字符串只取该方法返回值）"><a href="#3-4-参数对象的-toJSON-方法（对象自定义toJSON方法，转字符串只取该方法返回值）" class="headerlink" title="3.4 参数对象的 toJSON 方法（对象自定义toJSON方法，转字符串只取该方法返回值）"></a>3.4 参数对象的 toJSON 方法（对象自定义toJSON方法，转字符串只取该方法返回值）</h3><p>如果参数对象有自定义的<code>toJSON</code>方法，那么<code>JSON.stringify</code>会<strong>使用这个方法的返回值作为参数，而忽略原对象的其他属性</strong>。</p>
<p>下面是一个普通的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&#x27;三&#x27;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&#x27;张&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">fullName</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">lastName</span> + <span class="variable language_">this</span>.<span class="property">firstName</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(user)</span><br><span class="line"><span class="comment">// &quot;&#123;&quot;firstName&quot;:&quot;三&quot;,&quot;lastName&quot;:&quot;张&quot;,&quot;fullName&quot;:&quot;张三&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>现在，为这个对象加上<code>toJSON</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&#x27;三&#x27;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&#x27;张&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">fullName</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">lastName</span> + <span class="variable language_">this</span>.<span class="property">firstName</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">toJSON</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 只使用toJSON的返回值作为参数，忽略user对象的其他参数</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="variable language_">this</span>.<span class="property">lastName</span> + <span class="variable language_">this</span>.<span class="property">firstName</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(user)</span><br><span class="line"><span class="comment">// &quot;&#123;&quot;name&quot;:&quot;张三&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>JSON.stringify</code>发现参数对象有<code>toJSON</code>方法，就直接使用这个方法的返回值作为参数，而<strong>忽略原对象的其他参数</strong>。</p>
<p><code>Date</code>对象就有一个自己的<code>toJSON</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2015-01-01&#x27;</span>);</span><br><span class="line">date.<span class="title function_">toJSON</span>() <span class="comment">// &quot;2015-01-01T00:00:00.000Z&quot;</span></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(date) <span class="comment">// &quot;&quot;2015-01-01T00:00:00.000Z&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>JSON.stringify</code>发现处理的是<code>Date</code>对象实例，就会调用这个实例对象的<code>toJSON</code>方法，将该方法的返回值作为参数。</p>
<p><code>toJSON</code>方法的一个应用是，<strong>将正则对象自动转为字符串</strong>。因为<code>JSON.stringify</code>默认不能转换正则对象，但是设置了<code>toJSON</code>方法以后，就可以转换正则对象了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">reg</span>: <span class="regexp">/foo/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不设置 toJSON 方法时</span></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj) <span class="comment">// &quot;&#123;&quot;reg&quot;:&#123;&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 toJSON 方法时</span></span><br><span class="line"><span class="title class_">RegExp</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toJSON</span> = <span class="title class_">RegExp</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>;</span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="regexp">/foo/</span>) <span class="comment">// &quot;&quot;/foo/&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码在正则对象的原型上面部署了<code>toJSON()</code>方法，将其指向<code>toString()</code>方法，因此转换成 JSON 格式时，正则对象就先调用<code>toJSON()</code>方法转为字符串，然后再被<code>JSON.stringify()</code>方法处理。</p>
<h2 id="4、JSON-parse"><a href="#4、JSON-parse" class="headerlink" title="4、JSON.parse()"></a>4、JSON.parse()</h2><p><code>JSON.parse</code>方法<strong>用于将 JSON 字符串转换成对应的JSON值</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="string">&#x27;&#123;&#125;&#x27;</span>) <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="string">&#x27;true&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="string">&#x27;&quot;foo&quot;&#x27;</span>) <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="string">&#x27;[1, 5, &quot;false&quot;]&#x27;</span>) <span class="comment">// [1, 5, &quot;false&quot;]</span></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="string">&#x27;null&#x27;</span>) <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="string">&#x27;&#123;&quot;name&quot;: &quot;张三&quot;&#125;&#x27;</span>);</span><br><span class="line">o.<span class="property">name</span> <span class="comment">// 张三</span></span><br></pre></td></tr></table></figure>

<p>如果传入的字符串不是有效的 JSON 格式，<code>JSON.parse</code>方法将报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="string">&quot;&#x27;String&#x27;&quot;</span>) <span class="comment">// illegal single quotes</span></span><br><span class="line"><span class="comment">// SyntaxError: Unexpected token ILLEGAL</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，双引号字符串中是一个单引号字符串，因为单引号字符串不符合 JSON 格式，所以报错。</p>
<p>为了<strong>处理解析错误</strong>，可以将<code>JSON.parse</code>方法放在<code>try...catch</code>代码块中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="string">&quot;&#x27;String&#x27;&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;parsing error&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>JSON.parse</code>方法<strong>可以接受一个处理函数，作为第二个参数，用法与<code>JSON.stringify</code>方法类似</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">key, value</span>) &#123;<span class="comment">// 参数：键名、键值</span></span><br><span class="line">  <span class="keyword">if</span> (key === <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value + <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="string">&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125;&#x27;</span>, f)</span><br><span class="line"><span class="comment">// &#123;a: 11, b: 2&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>JSON.parse</code>的第二个参数是一个函数，如果键名是<code>a</code>，该函数会将键值加上10。</p>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>学习文档：<a href="https://wangdoc.com/javascript/">https://wangdoc.com/javascript/</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
